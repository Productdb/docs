import DyteEventEmitter from '../../utils/DyteEventEmitter';
import { ConnectedMeetingsStateManagerEvents } from '../../utils/DyteEvents';
import DyteConnectedMeetings, { ConnectedMeetingParticipantPayload, ConnectedMeetingResponsePayload } from '../DyteConnectedMeetings';
import DyteMeta from '../DyteMeta';
import DyteParticipants from '../DyteParticipants';
import DyteSelf from '../DyteSelf';
export declare type StateManagerMeetingType = ConnectedMeetingResponsePayload & {
    shouldPersistInDB?: boolean;
    shouldDelete?: boolean;
    shouldRename?: boolean;
    isTitleEditorOpen?: boolean;
};
export declare const StateManagerMeetingIdPrefix = "NewConnectedMeeting_";
export default class StateManager extends DyteEventEmitter<ConnectedMeetingsStateManagerEvents> {
    #private;
    private clientSpecificIdToParticipantMap;
    private clientSpecificIdToMeetingIdMap;
    constructor(connectedMeetings: DyteConnectedMeetings, participants: Readonly<DyteParticipants>, meta: Readonly<DyteMeta>, self: Readonly<DyteSelf>);
    private meetingsList;
    getUnassignedParticipants(): ConnectedMeetingParticipantPayload[];
    openTitleEditorForConnectedMeeting(meetingId: string): void;
    closeTitleEditorForConnectedMeeting(meetingId: string): void;
    assignParticipants(meetingId: string, clientSpecificIds: string[], skipEmit?: boolean): void;
    assignParticipantsRandomly(clientSpecificIds?: string[]): void;
    unassignParticipants(clientSpecificIds: string[]): void;
    unassignAllParticipants(): void;
    addNewConnectedMeeting(title?: string): void;
    renameConnectedMeeting(meetingId: string, title: string): void;
    deleteConnectedMeetings(meetingIds: string[]): void;
    getConnectedMeetings(): StateManagerMeetingType[];
    applyChanges(): Promise<void>;
    startConnectedMeetings(): Promise<void>;
    reset(): void;
    init(): void;
}
