var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { getAPIClient } from '../api';
import { config } from '../utils/config';
import DyteEventEmitter from '../utils/DyteEventEmitter';
import DyteError, { CatchAll } from './DyteError';
import DyteSelf from './DyteSelf';
import { pluginEvents } from '../socketService/socketEvents';
import PluginSocketHandler from '../socketService/PluginSocketHandler';
import { SessionEvents } from '../store/SessionEvents';
import DyteParticipants from './DyteParticipants';
import { postMessageSanitizer } from '../utils/sanitizer';
import DyteLogger from './internals/DyteLogger';
import { getRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
export const localPluginEvents = {
    getPeer: 14,
    getPeers: 15,
    chatMessage: 16,
    getRoomName: 17,
    getDisplayTitle: 18,
    getPluginInitiator: 19,
    customPluginEventToParent: 20,
    peerJoined: 22,
    peerLeft: 23,
    sendData: 24,
};
let DytePlugin = class DytePlugin extends DyteEventEmitter {
    #pluginSocketHandler;
    #socketServerName;
    baseURL;
    createdAt;
    description;
    id;
    name;
    #self;
    #participants;
    #chat;
    organizationId;
    picture;
    private;
    published;
    staggered;
    tags;
    type;
    updatedAt;
    config;
    #authToken;
    active;
    iframes;
    enabledBy;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    get roomJoined() {
        return this.#roomNodeClient?.roomJoined === true;
    }
    constructor({ baseURL, createdAt, description, id, name, organizationId, picture, private: isPrivate, published, staggered, tags, type, updatedAt, }, pluginSocketHandler, socketServerName, self, participants, chat) {
        super();
        this.baseURL = baseURL;
        this.createdAt = new Date(createdAt);
        this.description = description;
        this.id = id;
        this.name = name;
        this.#self = self;
        this.organizationId = organizationId;
        this.picture = picture;
        this.private = isPrivate;
        this.published = published;
        this.staggered = staggered;
        this.tags = tags;
        this.type = type;
        this.updatedAt = new Date(updatedAt);
        this.active = false;
        this.iframes = new Map();
        this.#pluginSocketHandler = pluginSocketHandler;
        this.#socketServerName = socketServerName;
        this.#participants = participants;
        this.#chat = chat;
        this.enabledBy = '';
    }
    sendIframeEvent(message) {
        if (!this.iframes.size) {
            return;
        }
        [...this.iframes.keys()].forEach((viewId) => {
            const { iframe } = this.iframes.get(viewId);
            if (!iframe)
                return;
            iframe.contentWindow.postMessage(message, '*');
        });
    }
    async handleIframeMessage(iframeMessage) {
        let response;
        if (this.#socketServerName === 'socket-service') {
            const message = iframeMessage;
            const { payload, uuid, type } = message;
            switch (type) {
                case pluginEvents.customPluginEventToRoom: {
                    this.#pluginSocketHandler.customPluginEventToRoom(this.id, payload, uuid);
                    break;
                }
                case pluginEvents.customPluginEventToPeers: {
                    this.#pluginSocketHandler.customPluginEventToPeers(this.id, payload, payload.peerIds, uuid);
                    break;
                }
                case pluginEvents.enablePluginForRoom: {
                    this.#pluginSocketHandler.enablePluginForRoom(this.id, uuid);
                    break;
                }
                case pluginEvents.enablePluginForPeers: {
                    this.#pluginSocketHandler.enablePluginForPeers(this.id, payload.peerIds, uuid);
                    break;
                }
                case pluginEvents.disablePluginForRoom: {
                    this.#pluginSocketHandler.disablePluginForRoom(this.id, uuid);
                    break;
                }
                case pluginEvents.disablePluginForPeers: {
                    this.#pluginSocketHandler.disablePluginForPeers(this.id, payload.peerIds, uuid);
                    break;
                }
                case pluginEvents.storeInsertKeys: {
                    this.#pluginSocketHandler.storeInsertKeys(this.id, payload.store, payload.insertKeys, uuid);
                    break;
                }
                case pluginEvents.storeGetKeys: {
                    this.#pluginSocketHandler.storeGetKeys(this.id, payload.store, payload.getKeys, uuid);
                    break;
                }
                case pluginEvents.storeDeleteKeys: {
                    this.#pluginSocketHandler.storeDeleteKeys(this.id, payload.store, payload.deleteKeys, uuid);
                    break;
                }
                case pluginEvents.storeDelete: {
                    this.#pluginSocketHandler.storeDelete(this.id, payload.store, uuid);
                    break;
                }
                case localPluginEvents.chatMessage: {
                    const { messagePayload, peerIds, } = payload;
                    if (!this.#chat) {
                        this.sendIframeEvent({
                            type: localPluginEvents.chatMessage,
                            uuid: message.uuid,
                            payload: { error: 'Chat is disabled for this room.' },
                        });
                        return;
                    }
                    try {
                        await this.#chat.sendMessage(messagePayload, peerIds);
                        this.sendIframeEvent({
                            type: localPluginEvents.chatMessage,
                            uuid: message.uuid,
                            payload: { success: true },
                        });
                    }
                    catch (e) {
                        this.sendIframeEvent({
                            type: localPluginEvents.chatMessage,
                            uuid: message.uuid,
                            payload: {
                                error: e,
                            },
                        });
                    }
                    break;
                }
                case localPluginEvents.getPeer: {
                    let peer;
                    const { peerId } = payload;
                    const self = {
                        ...this.#self,
                        isRecorder: this.#self.permissions?.isRecorder,
                    };
                    if (peerId) {
                        peer = this.#participants.joined.get(payload.peerId);
                        if (this.#self.id === peerId) {
                            peer = self;
                        }
                    }
                    else
                        peer = self;
                    this.sendIframeEvent({
                        type: localPluginEvents.getPeer,
                        payload: { peer: peer && postMessageSanitizer(peer) },
                        uuid: message.uuid,
                    });
                    break;
                }
                case localPluginEvents.getPeers: {
                    const peers = this.#participants.joined
                        .toArray()
                        .map((p) => postMessageSanitizer(p));
                    this.sendIframeEvent({
                        type: localPluginEvents.getPeers,
                        payload: { peers },
                        uuid: message.uuid,
                    });
                    break;
                }
                case localPluginEvents.getPluginInitiator: {
                    this.sendIframeEvent({
                        type: localPluginEvents.getPluginInitiator,
                        payload: { enabledBy: this.enabledBy },
                        uuid: message.uuid,
                    });
                    break;
                }
                case localPluginEvents.getDisplayTitle: {
                    this.sendIframeEvent({
                        type: localPluginEvents.getDisplayTitle,
                        payload: { displayTitle: this.#roomNodeClient.meetingTitle },
                        uuid: message.uuid,
                    });
                    break;
                }
                case localPluginEvents.getRoomName: {
                    this.sendIframeEvent({
                        type: localPluginEvents.getRoomName,
                        payload: { roomName: this.#roomNodeClient.roomName },
                        uuid: message.uuid,
                    });
                    break;
                }
                case localPluginEvents.customPluginEventToParent: {
                    this.emit(message.payload.eventName, message.payload.data);
                    break;
                }
                default: break;
            }
            return;
        }
        const getEnabledByPeerId = (enabledBy, peers) => {
            if (this.#self.userId === enabledBy)
                return this.#self.id;
            let enabledById;
            peers.forEach((p) => {
                if (p.userId === enabledBy)
                    enabledById = p.id;
            });
            return enabledById;
        };
        const message = iframeMessage;
        switch (message.type) {
            case 'pluginEvent':
            case 'storePluginData':
            case 'getPluginData':
            case 'enablePluginForAll':
            case 'enablePluginForUser':
            case 'disablePluginForUser':
            case 'chatMessage': {
                response = await this.#roomNodeClient.sendMessage(message);
                this.sendIframeEvent(response);
                break;
            }
            case 'getJoinedPeers': {
                response = await this.#roomNodeClient.getRoomState();
                this.sendIframeEvent({
                    type: 'websocket/get-joined-peers',
                    payload: {
                        ...message.payload,
                        peers: response.payload.roomState.peers,
                    },
                });
                break;
            }
            case 'getPeerInfo': {
                response = await this.#roomNodeClient.sendMessage({
                    type: message.type,
                    payload: {
                        ...message.payload,
                        peerId: message.payload?.peerId ?? this.#self.id,
                    },
                });
                this.sendIframeEvent(response);
                break;
            }
            case 'getRoomState': {
                response = await this.#roomNodeClient.getRoomState();
                const { plugins, peers } = response.payload.roomState;
                const { enabledBy } = plugins.find((x) => x.id === this.id);
                const enabledByPeerId = getEnabledByPeerId(enabledBy, peers);
                this.sendIframeEvent({
                    type: 'websocket/get-room-state',
                    payload: {
                        ...message.payload,
                        roomName: response.payload.roomState.roomName,
                        pluginInitiatorPeerId: enabledByPeerId,
                        pluginInitiatorUserId: enabledBy,
                        peers: response.payload.roomState.peers,
                        displayTitle: response.payload.roomState.displayTitle,
                        roomUUID: response.payload.roomState.roomUUID,
                        currentPeer: this.#self.id,
                        isRecorder: this.#self.permissions?.isRecorder,
                    },
                });
                break;
            }
            case 'getPluginInitiatorId': {
                response = await this.#roomNodeClient.getRoomState();
                const { plugins, peers } = response.payload.roomState;
                const { enabledBy } = plugins.find((x) => x.id === this.id);
                const enabledByPeerId = getEnabledByPeerId(enabledBy, peers);
                this.sendIframeEvent({
                    type: 'websocket/get-plugin-initiator-peer-id',
                    payload: {
                        ...message.payload,
                        pluginInitiatorPeerId: enabledByPeerId,
                    },
                });
                break;
            }
            case 'getPluginInitiatorUserId': {
                response = await this.#roomNodeClient.getRoomState();
                const { plugins } = response.payload.roomState;
                const { enabledBy } = plugins.find((x) => x.id === this.id);
                this.sendIframeEvent({
                    type: 'websocket/get-plugin-initiator-user-id',
                    payload: {
                        ...message.payload,
                        pluginInitiatorUserId: enabledBy,
                    },
                });
                break;
            }
            case 'pluginEventToParent': {
                this.emit(message.payload.eventName, message.payload.data);
                break;
            }
            case 'toggleViewMode': {
                this.emit('toggleViewMode', message.payload.data);
                break;
            }
            default: break;
        }
    }
    sendData(payload) {
        if (this.#socketServerName === 'socket-service') {
            this.sendIframeEvent({
                type: localPluginEvents.sendData,
                uuid: '',
                payload,
            });
            return;
        }
        this.sendIframeEvent({
            type: SessionEvents.PLUGIN_INTERNAL_DATA,
            payload: {
                pluginId: this.id,
                data: payload,
            },
        });
    }
    removePluginView(viewId = 'default') {
        const { iframe, listener } = this.iframes.get(viewId) ?? {};
        if (iframe || listener) {
            window.removeEventListener('message', listener);
            this.iframes.delete(viewId);
        }
    }
    addPluginView(iframe, viewId = 'default') {
        if (!this.#authToken) {
            DyteLogger.error('DytePlugin::addPluginView::no_auth_token_set_for_plugin');
            throw new DyteError('No auth token set for plugin.');
        }
        if (!iframe) {
            DyteLogger.error('DytePlugin::addPluginView::iframe_was_not_provided');
            throw new DyteError('Iframe was not provided.');
        }
        this.removePluginView(viewId);
        const iframeElement = iframe;
        const url = new URL(this.baseURL);
        const params = {
            auth: this.#authToken,
            parent: !navigator.isReactNative && window.location.origin,
            backend: config.apiBase,
            pluginId: this.id,
            roomName: this.#roomNodeClient.roomName ?? '',
            displayTitle: this.#roomNodeClient.meetingTitle,
        };
        Object.keys(params).forEach((param) => {
            url.searchParams.set(param, params[param]);
        });
        iframeElement.src = url.href;
        iframeElement.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframeElement.title = viewId;
        const listener = async (message) => {
            if (message.source === iframe.contentWindow) {
                await this.handleIframeMessage(message.data);
            }
        };
        window.addEventListener('message', listener);
        this.iframes.set(viewId, { iframe: iframeElement, listener });
    }
    setActive(active) {
        this.active = active;
        if (active) {
            this.emit('stateUpdate', {
                active: this.active,
                pluginId: this.id,
                bind: this.addPluginView.bind(this),
                views: this.config?.views,
            });
            return;
        }
        this.active = false;
        this.emit('stateUpdate', {
            active: this.active,
            pluginId: this.id,
            views: this.config?.views,
        });
    }
    async activateForSelf() {
        const APIClient = getAPIClient();
        const authToken = await APIClient.authorizePlugin(this.id);
        this.#authToken = authToken;
        try {
            const pluginConfig = await APIClient.getPluginConfig(this.baseURL);
            this.config = pluginConfig;
        }
        catch (error) {
            DyteLogger.error('DytePlugin::activateForSelf', { error });
        }
        this.setActive(true);
        this.emit('enabled');
    }
    deactivateForSelf() {
        [...this.iframes.keys()].forEach((viewId) => {
            this.removePluginView(viewId);
        });
        this.iframes.clear();
        this.setActive(false);
        this.emit('closed');
    }
    async enable() {
        return this.activateForSelf();
    }
    disable() {
        return this.deactivateForSelf();
    }
    async activate() {
        if (!this.#self.permissions?.plugins?.canStart) {
            return;
        }
        if (this.#socketServerName === 'socket-service') {
            this.#pluginSocketHandler.addPlugin(this.id, this.staggered);
            return;
        }
        await this.#roomNodeClient.addRoomPlugin(this);
    }
    async deactivate() {
        if (!this.#self.permissions?.plugins?.canClose) {
            return;
        }
        if (this.#socketServerName === 'socket-service') {
            this.#pluginSocketHandler.removePlugin(this.id);
            return;
        }
        await this.#roomNodeClient.removeRoomPlugin(this);
    }
};
DytePlugin = __decorate([
    CatchAll((err) => { throw new DyteError(err.message, '0600'); }),
    __metadata("design:paramtypes", [Object, PluginSocketHandler, String, DyteSelf,
        DyteParticipants, Object])
], DytePlugin);
export default DytePlugin;
