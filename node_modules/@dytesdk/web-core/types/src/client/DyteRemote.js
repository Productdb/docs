import { v4 as uuid } from 'uuid';
import DyteEventEmitter from '../utils/DyteEventEmitter';
import DyteError from './DyteError';
import DyteRemoteRequest, { RemoteEventType, RemoteRequestState, RemoteUpdateType, } from './DyteRemoteRequest';
import DyteRemoteMap from './map/DyteRemoteMap';
import { getRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
export default class DyteRemote extends DyteEventEmitter {
    incomingRequests;
    outgoingRequests;
    active;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    #self;
    #participants;
    constructor(self, participants) {
        super();
        this.#participants = participants;
        this.#self = self;
        this.incomingRequests = new DyteRemoteMap();
        this.outgoingRequests = new DyteRemoteMap();
        this.active = null;
        this.mouseEvent = this.mouseEvent.bind(this);
        this.keyboardEvent = this.keyboardEvent.bind(this);
    }
    async requestControl(peerId) {
        const peer = this.#participants.joined.get(peerId);
        if (!peer) {
            throw new DyteError('Invalid peer.');
        }
        const duplicateRequest = this.outgoingRequests
            ?.toArray().find((request) => request.hostPeerId === peerId);
        if (duplicateRequest) {
            return duplicateRequest.id;
        }
        const requestId = uuid();
        const request = new DyteRemoteRequest({
            requestId,
            hostPeerId: peerId,
            remotePeerId: this.#self.id,
            state: RemoteRequestState.PENDING,
        });
        this.outgoingRequests.add(request);
        await this.#roomNodeClient.requestRemoteControl(request);
        this.emit('remoteUpdate', {
            payload: {
                request: {
                    id: request.id,
                    hostPeerId: request.hostPeerId,
                    remotePeerId: request.remotePeerId,
                },
            },
            type: RemoteUpdateType.REQUEST_SENT,
        });
        return requestId;
    }
    async acceptControl(requestId) {
        if (this.active?.id === requestId) {
            return;
        }
        const request = this.incomingRequests.get(requestId);
        if (!request)
            throw new DyteError('No request found.');
        request.state = RemoteRequestState.ACCEPTED;
        this.endControl();
        this.active = request;
        this.#roomNodeClient.acceptRemoteControl(request);
        this.emit('remoteUpdate', {
            payload: {
                request: {
                    id: this.active.id,
                    hostPeerId: this.active.hostPeerId,
                    remotePeerId: this.active.remotePeerId,
                },
            },
            type: RemoteUpdateType.INCOMING_REQUEST_ACCEPTED,
        });
    }
    async endControl() {
        if (!this.active) {
            return;
        }
        const lastActiveControl = { ...this.active };
        this.#roomNodeClient.terminateRemoteControl(this.active.hostPeerId === this.#self.id
            ? this.active.remotePeerId : this.active.hostPeerId, this.active);
        this.active = null;
        this.emit('remoteUpdate', {
            payload: {
                request: {
                    id: lastActiveControl.id,
                    hostPeerId: lastActiveControl.hostPeerId,
                    remotePeerId: lastActiveControl.remotePeerId,
                },
            },
            type: lastActiveControl.hostPeerId === this.#self.id
                ? RemoteUpdateType.INCOMING_REQUEST_ENDED
                : RemoteUpdateType.OUTGOING_REQUEST_ENDED,
        });
    }
    async keyboardEvent(event) {
        if (!this.active) {
            return;
        }
        const keyboardEvent = DyteRemote.getFormattedKeyboardEvent(event);
        if (keyboardEvent) {
            const data = {
                eventType: RemoteEventType.KEYBOARD,
                keyboardEvent,
            };
            this.#roomNodeClient
                .sendEventRemoteControl(this.active.hostPeerId, this.active.id, data);
        }
    }
    async mouseEvent(event, screenShareVideoElement) {
        if (!this.active) {
            return;
        }
        const mouseEvent = DyteRemote.getFormattedRemoteMouseEvent(event, screenShareVideoElement);
        if (mouseEvent) {
            const data = {
                eventType: RemoteEventType.MOUSE,
                mouseEvent,
            };
            this.#roomNodeClient
                .sendEventRemoteControl(this.active.hostPeerId, this.active.id, data);
        }
    }
    static getFormattedRemoteMouseEvent(event, screenShareVideoElement) {
        const remoteRect = screenShareVideoElement.getBoundingClientRect();
        const formattedEvent = {
            type: event.type,
            position: {
                x: Math.floor(event.x - remoteRect.left),
                y: Math.floor(event.y - remoteRect.top),
            },
            boundingRect: {
                width: remoteRect.width,
                height: remoteRect.height,
            },
        };
        return formattedEvent;
    }
    static getFormattedKeyboardEvent(event) {
        if (event.type === 'keydown') {
            const formattedEvent = {
                type: event.type,
                key: event.key,
            };
            return formattedEvent;
        }
        return null;
    }
}
