var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import DyteTelemetry from '../utils/opentelemetry';
import DyteEventEmitter from '../utils/DyteEventEmitter';
import DyteError, { CatchAll } from './DyteError';
import DyteSelf from './DyteSelf';
import ChatController from '../controllers/ChatController';
import ChatSocketHandler, { ChatMessageType } from '../socketService/ChatSocketHandler';
import DyteParticipants from './DyteParticipants';
import DyteLogger from './internals/DyteLogger';
import { getAPIClient } from '../api';
import { getRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
export var MessageType;
(function (MessageType) {
    MessageType["text"] = "text";
    MessageType["image"] = "image";
    MessageType["file"] = "file";
    MessageType["poll"] = "poll";
})(MessageType || (MessageType = {}));
export const messageTypes = ['text', 'image', 'file', 'poll'];
let DyteChat = class DyteChat extends DyteEventEmitter {
    messages;
    #self;
    #participants;
    #chatSocketHandler;
    #socketServerName;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    get roomJoined() {
        return this.#roomNodeClient?.roomJoined === true;
    }
    constructor(chatSocketHandler, socketServerName, self, participants) {
        super();
        this.#chatSocketHandler = chatSocketHandler;
        this.#socketServerName = socketServerName;
        this.#self = self;
        this.#participants = participants;
        this.messages = [];
    }
    async sendTextMessage(message, peerIds) {
        if (!this.#self.permissions?.chatPublic?.canSend
            || !this.#self.permissions?.chatPublic?.text) {
            DyteLogger.error('sendTextMessage::public_chat_permission_denied');
            throw new DyteError('Could not send message to public chat.', '0501');
        }
        if ((peerIds && peerIds.length > 0)
            && (!this.#self.permissions?.chatPrivate.canSend
                || !this.#self.permissions?.chatPrivate.text)) {
            DyteLogger.error('sendTextMessage::private_chat_permission_denied');
            throw new DyteError('Could not send message to private chat.', '0501');
        }
        if (!message) {
            DyteLogger.error('sendTextMessage::message_can_not_be_empty');
            throw new DyteError('Message can not be empty.', '0502');
        }
        if (this.#socketServerName === 'socket-service') {
            let userIds = [];
            if (peerIds && peerIds.length > 0) {
                peerIds.push(this.#self.id);
                userIds = this.#participants.joined.toArray()
                    .filter((p) => peerIds.includes(p.id))
                    .map((p) => p.userId);
                userIds.push(this.#self.userId);
            }
            this.#chatSocketHandler.sendMessage(message, ChatMessageType.TEXT, peerIds);
            return;
        }
        if (peerIds !== undefined && peerIds.length > 0) {
            DyteLogger.error('sendTextMessage::private_chat_unsupported');
            return;
        }
        const text = {
            userId: this.#self.userId,
            displayName: this.#self.name,
            message,
            type: messageTypes.indexOf(MessageType.text),
            time: +new Date(),
        };
        if (!this.roomJoined) {
            DyteLogger.error('DyteChat.sendTextMessage.RoomNodeClientSocketUsed_WithoutRoomJoin');
            throw new DyteError('Can`t sendTextMessage without joining room');
        }
        await this.#roomNodeClient.sendChatMessage(text);
    }
    async sendImageMessage(image, peerIds) {
        if (peerIds && peerIds.length > 0) {
            if (!this.#self.permissions?.chatPrivate.canSend
                || !this.#self.permissions?.chatPrivate.files) {
                DyteLogger.error('sendImageMessage::private_chat_permission_denied');
                return;
            }
        }
        else if (!this.#self.permissions?.chatPublic?.canSend
            || !this.#self.permissions?.chatPublic?.files) {
            DyteLogger.error('sendImageMessage::permission_denied');
            return;
        }
        if (!image) {
            DyteLogger.error('sendImageMessage::required_argument_image_can_not_be_empty');
            return;
        }
        const acceptedImageTypes = ['image/gif', 'image/jpeg', 'image/png'];
        if (!acceptedImageTypes.includes(image.type)) {
            DyteLogger.error('sendImageMessage::image_type_not_supported', { dyteChat: { imageType: image.type } });
            return;
        }
        try {
            const APIClient = getAPIClient();
            const { getLocation, putLocation } = await APIClient.getPresignedUrls(image.name);
            await APIClient.uploadFile(image, putLocation);
            if (this.#socketServerName === 'socket-service') {
                let userIds = [];
                if (peerIds && peerIds.length > 0) {
                    peerIds.push(this.#self.id);
                    userIds = this.#participants.joined.toArray()
                        .filter((p) => peerIds.includes(p.id))
                        .map((p) => p.userId);
                    userIds.push(this.#self.userId);
                }
                this.#chatSocketHandler.sendMessage(getLocation, ChatMessageType.IMAGE, peerIds);
                return;
            }
            if (peerIds !== undefined && peerIds.length > 0) {
                DyteLogger.error('sendImageMessage::private_chat_unsupported');
                return;
            }
            const imageObj = {
                userId: this.#self.userId,
                displayName: this.#self.name,
                type: messageTypes.indexOf(MessageType.image),
                link: getLocation,
                time: +new Date(),
            };
            if (!this.roomJoined) {
                DyteLogger.error('DyteChat.sendImageMessage.RoomNodeClientSocketUsed_WithoutRoomJoin');
                throw new DyteError('Can`t sendImageMessage without joining room');
            }
            await this.#roomNodeClient.sendChatMessage(imageObj);
        }
        catch (err) {
            throw new DyteError('Error sending image message.');
        }
    }
    async sendFileMessage(file, peerIds) {
        if (peerIds && peerIds.length > 0) {
            if (!this.#self.permissions?.chatPrivate.canSend
                || !this.#self.permissions?.chatPrivate.files) {
                DyteLogger.error('sendFileMessage::private_chat_permission_denied');
                return;
            }
        }
        else if (!this.#self.permissions?.chatPublic?.canSend
            || !this.#self.permissions?.chatPublic?.files) {
            DyteLogger.error('sendFileMessage::permission_denied');
            return;
        }
        if (!file) {
            DyteLogger.error('sendFileMessage::required_argument_file_can_not_be_empty');
            return;
        }
        try {
            const APIClient = getAPIClient();
            const { getLocation, putLocation } = await APIClient.getPresignedUrls(file.name);
            await APIClient.uploadFile(file, putLocation);
            if (this.#socketServerName === 'socket-service') {
                let userIds = [];
                if (peerIds && peerIds.length > 0) {
                    peerIds.push(this.#self.id);
                    userIds = this.#participants.joined.toArray()
                        .filter((p) => peerIds.includes(p.id))
                        .map((p) => p.userId);
                    userIds.push(this.#self.userId);
                }
                const message = JSON.stringify({
                    link: getLocation,
                    name: file.name,
                    size: file.size,
                });
                this.#chatSocketHandler.sendMessage(message, ChatMessageType.FILE, peerIds);
                return;
            }
            if (peerIds !== undefined && peerIds.length > 0) {
                DyteLogger.error('sendFileMessage::private_chat_unsupported');
                return;
            }
            const fileObj = {
                userId: this.#self.userId,
                displayName: this.#self.name,
                type: messageTypes.indexOf(MessageType.file),
                link: getLocation,
                name: file.name,
                size: file.size,
                time: +new Date(),
            };
            if (!this.roomJoined) {
                DyteLogger.error('DyteChat.sendFileMessage.RoomNodeClientSocketUsed_WithoutRoomJoin');
                throw new DyteError('Can`t sendFileMessage without joining room');
            }
            await this.#roomNodeClient.sendChatMessage(fileObj);
        }
        catch (err) {
            throw new DyteError('Error sending file message.');
        }
    }
    async sendMessage(message, participantIds) {
        switch (message.type) {
            case MessageType.text:
                await this.sendTextMessage(message.message, participantIds);
                break;
            case MessageType.image:
                await this.sendImageMessage(message.image, participantIds);
                break;
            case MessageType.file:
                await this.sendFileMessage(message.file, participantIds);
                break;
            default:
                DyteLogger.error('sendMessage::message_type_not_supported', {
                    dyteChat: { messageType: message.type },
                });
                break;
        }
    }
    async editTextMessage(messageId, message) {
        if (this.#socketServerName !== 'socket-service') {
            DyteLogger.warn('editTextMessage::Coming soon!');
            return;
        }
        if (!this.#self.permissions?.chatPublic?.canSend
            || !this.#self.permissions?.chatPublic?.text) {
            DyteLogger.error('editTextMessage::permission_denied');
            return;
        }
        if (!message) {
            DyteLogger.error('editTextMessage::message_can_not_be_empty');
            return;
        }
        this.#chatSocketHandler.editMessage(messageId, message, ChatMessageType.TEXT);
    }
    async editImageMessage(messageId, image) {
        if (this.#socketServerName !== 'socket-service') {
            DyteLogger.warn('editImageMessage::Coming soon!');
            return;
        }
        if (!this.#self.permissions?.chatPublic?.canSend
            || !this.#self.permissions?.chatPublic?.files) {
            DyteLogger.error('editImageMessage::permission_denied');
            return;
        }
        if (!image) {
            DyteLogger.error('editImageMessage::required_argument_image_can_not_be_empty');
            return;
        }
        const acceptedImageTypes = ['image/gif', 'image/jpeg', 'image/png'];
        if (!acceptedImageTypes.includes(image.type)) {
            DyteLogger.error('sendImageMessage::image_type_not_supported', {
                dyteChat: { imageType: image.type },
            });
            return;
        }
        try {
            const APIClient = getAPIClient();
            const { getLocation, putLocation } = await APIClient
                .getPresignedUrls(image.name);
            await APIClient.uploadFile(image, putLocation);
            this.#chatSocketHandler.editMessage(messageId, getLocation, ChatMessageType.IMAGE);
        }
        catch {
            throw new DyteError('Error editing image message.');
        }
    }
    async editFileMessage(messageId, file) {
        if (this.#socketServerName !== 'socket-service') {
            DyteLogger.warn('editFileMessage::Coming soon!');
            return;
        }
        if (!this.#self.permissions?.chatPublic?.canSend
            || !this.#self.permissions?.chatPublic?.files) {
            DyteLogger.error('sendFileMessage::permission_denied');
            return;
        }
        if (!file) {
            DyteLogger.error('sendFileMessage::required_argument_file_can_not_be_empty');
            return;
        }
        try {
            const APIClient = getAPIClient();
            const { getLocation, putLocation } = await APIClient.getPresignedUrls(file.name);
            await APIClient.uploadFile(file, putLocation);
            this.#chatSocketHandler.editMessage(messageId, JSON.stringify({
                link: getLocation,
                name: file.name,
                size: file.size,
            }), ChatMessageType.FILE);
        }
        catch {
            throw new DyteError('Error editing file message.');
        }
    }
    async editMessage(messageId, message) {
        if (this.#socketServerName !== 'socket-service') {
            DyteLogger.warn('editMessage::Coming soon!');
            return;
        }
        switch (message.type) {
            case MessageType.text: {
                this.editTextMessage(messageId, message.message);
                break;
            }
            case MessageType.image: {
                this.editImageMessage(messageId, message.image);
                break;
            }
            case MessageType.file: {
                this.editFileMessage(messageId, message.file);
                break;
            }
            default: {
                DyteLogger.error('editMessage::message_type_not_supported', {
                    dyteChat: { messageType: message.type },
                });
                break;
            }
        }
    }
    async deleteMessage(messageId) {
        if (this.#socketServerName !== 'socket-service') {
            DyteLogger.warn('editMessage::Coming soon!');
            return;
        }
        this.#chatSocketHandler.deleteMessage(messageId);
    }
    getMessagesByUser(userId) {
        return this.messages.filter((message) => message.userId === userId);
    }
    getMessagesByType(type) {
        return this.messages.filter((message) => message.type === type);
    }
    async pin(id) {
        if (this.#socketServerName === 'socket-service') {
            return;
        }
        if (!this.roomJoined) {
            throw new DyteError('Can`t pin message without joining room');
        }
        await this.#roomNodeClient.pinChatMessage({ id });
    }
    async unpin(id) {
        if (this.#socketServerName === 'socket-service') {
            return;
        }
        if (!this.roomJoined) {
            throw new DyteError('Can`t unpin message without joining room');
        }
        await this.#roomNodeClient.unpinChatMessage({ id });
    }
    async getMessages(timeStamp, size, reversed, offset = 0) {
        const messageResponse = await this.#chatSocketHandler
            .getChatMessagesPaginated(timeStamp, size, reversed, offset);
        return {
            messages: messageResponse.messages.map((message) => ChatController.formatSocketServiceMessage(message)),
            next: messageResponse.next,
        };
    }
    get pinned() {
        return this.messages.filter((message) => message.pinned);
    }
};
__decorate([
    DyteTelemetry.trace('DyteChat.sendTextMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "sendTextMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.sendImageMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [File, Array]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "sendImageMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.sendFileMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [File, Array]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "sendFileMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.sendMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "sendMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.editTextMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "editTextMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.editImageMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, File]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "editImageMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.editFileMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, File]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "editFileMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.editMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "editMessage", null);
__decorate([
    DyteTelemetry.trace('DyteChat.deleteMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DyteChat.prototype, "deleteMessage", null);
DyteChat = __decorate([
    CatchAll((err) => { throw new DyteError(err.message, '0500'); }),
    __metadata("design:paramtypes", [ChatSocketHandler, String, DyteSelf,
        DyteParticipants])
], DyteChat);
export default DyteChat;
