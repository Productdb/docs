import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import DyteEventEmitter from '../utils/DyteEventEmitter';
import constants from '../utils/constants';
import { FlagsmithFeatureFlags } from '../utils/flags';
import ConnectedMeetingsSocketHandler from '../socketService/ConnectedMeetingsSocketHandler';
export default class DyteConnectedMeetings extends DyteEventEmitter {
    #self;
    constructor(meeting) {
        super();
        this.#self = meeting.self;
    }
    meetings = [];
    parentMeeting = null;
    get supportsConnectedMeetings() {
        return this.#self.id !== ''
            && constants.isV2AuthToken
            && flagsmith.hasFeature(FlagsmithFeatureFlags.CONNECTED_MEETINGS);
    }
    get isActive() {
        return this.meetings.length !== 0;
    }
    get currentMeetingId() {
        return ConnectedMeetingsSocketHandler.currentMeetingId;
    }
    validateConnectedMeetingsAction() {
        if (!this.supportsConnectedMeetings) {
            throw new Error(`You are not allowed to perform this action.
            Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
        }
    }
    async getConnectedMeetings() {
        this.validateConnectedMeetingsAction();
        const response = await ConnectedMeetingsSocketHandler.getConnectedRoomsDump();
        return response;
    }
    async createMeetings(request) {
        this.validateConnectedMeetingsAction();
        const response = await ConnectedMeetingsSocketHandler.createConnectedRooms(request);
        return response.map((meeting) => ({
            id: meeting.id,
            title: meeting.title,
        }));
    }
    async updateMeetings(request) {
        this.validateConnectedMeetingsAction();
        await ConnectedMeetingsSocketHandler.updateConnectedRooms(request.map((req) => ({ meetingId: req.id, title: req.title })));
    }
    async deleteMeetings(meetingIds) {
        this.validateConnectedMeetingsAction();
        const promises = this.meetings.map((meeting) => {
            if (meetingIds.includes(meeting.id) && meeting.participants.length !== 0) {
                return this.moveParticipants(meeting.id, this.parentMeeting.id, meeting.participants.map((p) => p.customParticipantId));
            }
            return Promise.resolve();
        });
        await Promise.all(promises);
        const response = await ConnectedMeetingsSocketHandler.disableConnectedRooms(meetingIds);
        return response;
    }
    async moveParticipants(sourceMeetingId, destinationMeetingId, customParticipantIds) {
        this.validateConnectedMeetingsAction();
        const allParticipants = new Map();
        [
            ...this.parentMeeting.participants,
            ...this.meetings.flatMap((meeting) => meeting.participants),
        ].forEach((participant) => allParticipants.set(participant.customParticipantId, participant));
        const participantUserIds = customParticipantIds.map((customParticipantId) => allParticipants.get(customParticipantId).id);
        const response = await ConnectedMeetingsSocketHandler.movePeersBetweenRooms({
            sourceMeetingId,
            destinationMeetingId,
            participants: participantUserIds.map((pId) => ({ id: pId })),
        });
        if (response.success) {
            if (destinationMeetingId === this.parentMeeting.id) {
                this.parentMeeting.participants = this.parentMeeting.participants.concat(customParticipantIds.map((id) => allParticipants.get(id)));
            }
            if (sourceMeetingId === this.parentMeeting.id) {
                this.parentMeeting.participants = this.parentMeeting.participants.filter((participant) => !customParticipantIds.includes(participant.customParticipantId));
            }
            this.meetings = this.meetings.map((meeting) => {
                if (destinationMeetingId === meeting.id) {
                    const participants = meeting.participants.concat(customParticipantIds.map((id) => allParticipants.get(id)));
                    return {
                        ...meeting,
                        participants,
                    };
                }
                if (sourceMeetingId === meeting.id) {
                    const filteredParticipants = meeting.participants.filter((participant) => !customParticipantIds.includes(participant.customParticipantId));
                    return {
                        ...meeting,
                        participants: filteredParticipants,
                    };
                }
                return meeting;
            });
        }
        return response;
    }
}
