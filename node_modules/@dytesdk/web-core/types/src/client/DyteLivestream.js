var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { getAPIClient } from '../api';
import DyteEventEmitter from '../utils/DyteEventEmitter';
import DyteTelemetry from '../utils/opentelemetry';
import DyteError from './DyteError';
import DyteLogger from './internals/DyteLogger';
export default class DyteLivestream extends DyteEventEmitter {
    #self;
    state = 'IDLE';
    playbackUrl;
    viewerCount;
    constructor(self) {
        super();
        this.#self = self;
        this.viewerCount = 0;
    }
    setLivestreamState(livestreamState) {
        const previousState = this.state;
        this.state = livestreamState;
        if (previousState !== livestreamState)
            this.emitCurrentLivestreamState();
    }
    emitCurrentLivestreamState() {
        this.emit('livestreamUpdate', this.state);
    }
    async start() {
        if (!this.#self.permissions.canLivestream) {
            DyteLogger.error('DyteLivestream::start::permission_denied');
            throw new DyteError('User does not have permission to start livestreaming');
        }
        this.setLivestreamState('STARTING');
        try {
            const APIClient = getAPIClient();
            const playbackUrl = await APIClient.startLivestreaming();
            this.playbackUrl = playbackUrl;
        }
        catch (error) {
            DyteLogger.error('DyteRecording::stop::livestream_failed_to_start', {
                error,
            });
            this.setLivestreamState('IDLE');
            throw new DyteError('Error while starting livestream');
        }
    }
    async stop() {
        if (!this.#self.permissions.canLivestream) {
            DyteLogger.error('DyteLivestream::stop::permission_denied');
            throw new DyteError('User does not have permission to stop livestreaming');
        }
        if (this.state !== 'LIVESTREAMING') {
            DyteLogger.error('DyteLivestream::stop::inconsistent_state');
            throw new DyteError('Livestream not started yet');
        }
        try {
            this.setLivestreamState('STOPPING');
            const APIClient = getAPIClient();
            await APIClient.stopLivestreaming();
        }
        catch (error) {
            DyteLogger.error('DyteLivestream::stop::livestream_failed_to_stop', { error });
            this.setLivestreamState('STOPPING');
            throw new DyteError('Error while stopping livestream');
        }
    }
}
__decorate([
    DyteTelemetry.trace('livestream.start'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DyteLivestream.prototype, "start", null);
__decorate([
    DyteTelemetry.trace('livestream.stop'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DyteLivestream.prototype, "stop", null);
