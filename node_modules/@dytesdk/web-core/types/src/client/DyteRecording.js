var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { getAPIClient } from '../api';
import { config } from '../utils/config';
import DyteEventEmitter from '../utils/DyteEventEmitter';
import DyteTelemetry from '../utils/opentelemetry';
import DyteError, { CatchAll } from './DyteError';
import DyteLogger from './internals/DyteLogger';
let DyteRecording = class DyteRecording extends DyteEventEmitter {
    #self;
    recordingState = 'IDLE';
    recordingId;
    recordingPeerId;
    constructor(self) {
        super();
        this.#self = self;
    }
    setRecordingState(recordingState) {
        const previousState = this.recordingState;
        this.recordingState = recordingState;
        if (previousState !== recordingState)
            this.emitCurrentRecordingState();
    }
    emitCurrentRecordingState() {
        this.emit('recordingUpdate', this.recordingState);
    }
    async start() {
        if (!this.#self.permissions.canRecord) {
            DyteLogger.error('DyteRecording::start::permission_denied');
            throw new DyteError('User does not have permission to start recording');
        }
        if (this.recordingState === 'STARTING'
            || this.recordingState === 'RECORDING'
            || this.recordingState === 'STOPPING') {
            DyteLogger.error('DyteRecording::start::recording_in_progress', {
                recording: {
                    state: this.recordingState,
                },
            });
            throw new DyteError(`Cant start recording, recordingState irregular: ${this.recordingState}`);
        }
        this.setRecordingState('STARTING');
        try {
            const APIClient = getAPIClient();
            const { recording = {} } = config.defaults;
            const recordingId = await APIClient.startRecording(recording);
            this.recordingId = recordingId;
        }
        catch (error) {
            DyteLogger.error('DyteRecording::stop::recording_failed_to_start', { error });
            this.setRecordingState('IDLE');
            throw new DyteError('Error while starting recording');
        }
    }
    async stop() {
        if (!this.#self.permissions.canRecord) {
            DyteLogger.error('DyteRecording::stop::permission_denied');
            throw new DyteError('User does not have permission to stop recording');
        }
        if (!(this.recordingState === 'RECORDING') || !(this.recordingId)) {
            DyteLogger.error('DyteRecording::stop::recording_not_in_progress', {
                recording: {
                    state: this.recordingState,
                    id: this.recordingId,
                },
            });
            await this.getRecordingId();
        }
        if (!(this.recordingState === 'RECORDING') || !(this.recordingId)) {
            DyteLogger.error('DyteRecording::stop::recording_not_in_progress', {
                recording: {
                    state: this.recordingState,
                    id: this.recordingId,
                },
            });
            throw new DyteError(`Cant stop recording, recordingState irregular: ${this.recordingState}`);
        }
        this.setRecordingState('STOPPING');
        try {
            const APIClient = getAPIClient();
            await APIClient.stopRecording(this.recordingId);
            this.setRecordingState('IDLE');
        }
        catch (error) {
            DyteLogger.error('DyteRecording::stop::recording_failed_to_stop', { error });
            this.setRecordingState('RECORDING');
            throw new DyteError('Error while stopping recording');
        }
    }
    async getRecordingId() {
        if (!this.#self.permissions.canRecord) {
            DyteLogger.error('DyteRecording::getRecordingId::permission_denied');
            throw new DyteError('User does not have permission to stop recording');
        }
        try {
            const APIClient = getAPIClient();
            const { status, id } = await APIClient.getActiveRecording();
            if (status === 'RECORDING') {
                this.recordingState = 'RECORDING';
                this.recordingId = id;
            }
        }
        catch (error) {
            DyteLogger.error('DyteRecording::getRecordingId::unable_to_get_recording_id', { error });
            throw new DyteError('Unable to get recording');
        }
    }
};
__decorate([
    DyteTelemetry.trace('DyteRecording.start'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DyteRecording.prototype, "start", null);
__decorate([
    DyteTelemetry.trace('DyteRecording.stop'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DyteRecording.prototype, "stop", null);
__decorate([
    DyteTelemetry.trace('DyteRecording.getRecordingId'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DyteRecording.prototype, "getRecordingId", null);
DyteRecording = __decorate([
    CatchAll((err) => { throw new DyteError(err.message, '1000'); }),
    __metadata("design:paramtypes", [Object])
], DyteRecording);
export default DyteRecording;
