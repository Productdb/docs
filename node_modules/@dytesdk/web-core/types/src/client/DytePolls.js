var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import DyteEventEmitter from '../utils/DyteEventEmitter';
import DyteSelf from './DyteSelf';
import DyteLogger from './internals/DyteLogger';
import DyteError, { CatchAll } from './DyteError';
import { getRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
import PollSocketHandler from '../socketService/PollSocketHandler';
let DytePolls = class DytePolls extends DyteEventEmitter {
    items;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    get roomJoined() {
        return this.#roomNodeClient?.roomJoined === true;
    }
    #self;
    #pollSocketHandler;
    #socketServerName;
    constructor(self, pollSocketHandler, socketServerName) {
        super();
        this.#self = self;
        this.#pollSocketHandler = pollSocketHandler;
        this.#socketServerName = socketServerName;
        this.items = [];
    }
    async create(question, options, anonymous = false, hideVotes = false) {
        if (this.#self.config.viewType !== 'LIVESTREAM' && !this.roomJoined) {
            throw new DyteError('Can\'t create polls without joining room');
        }
        if (!this.#self.permissions.polls.canCreate) {
            DyteLogger.error('DytePolls::create::permission_denied');
            return;
        }
        if (!question || !options) {
            DyteLogger.error('DytePolls::question_and_options_can_not_be_empty', {
                dytePolls: {
                    hasQuestion: !!question,
                    optionsLength: options?.length,
                },
            });
            return;
        }
        if (options.length < 2) {
            DyteLogger.error('DytePolls::there_must_be_at_least_two_options', {
                dytePolls: { hasQuestion: !!question, optionsLength: options.length },
            });
            return;
        }
        if (this.#socketServerName === 'socket-service') {
            await this.#pollSocketHandler.createPoll(question, options, anonymous, hideVotes);
            return;
        }
        const pollCreateMessage = {
            question,
            options,
            anonymous,
            hideVotes,
            createdBy: this.#self.name,
            createdByUserId: this.#self.userId,
        };
        await this.#roomNodeClient.newPoll(pollCreateMessage);
    }
    async vote(id, index) {
        if (!this.#self.permissions.polls.canVote) {
            DyteLogger.error('DytePolls::vote::permission_denied');
            return;
        }
        if (this.#socketServerName === 'socket-service') {
            await this.#pollSocketHandler.votePoll(id, index);
            return;
        }
        const pollVoteMessage = {
            pollId: id,
            index,
        };
        await this.#roomNodeClient.votePoll(pollVoteMessage);
    }
};
DytePolls = __decorate([
    CatchAll((err) => { throw new DyteError(err.message, '0700'); }),
    __metadata("design:paramtypes", [DyteSelf,
        PollSocketHandler, String])
], DytePolls);
export default DytePolls;
