import DyteLogger from './internals/DyteLogger';
const MODULE_CODE_MAPPINGS = {
    '00': 'DyteClient',
    '01': 'Controller',
    '02': 'RoomNodeClient',
    '03': 'HiveNodeClient',
    '04': 'SocketService',
    '05': 'Chat',
    '06': 'Plugin',
    '07': 'Polls',
    '08': 'Meta',
    '09': 'Preset',
    '10': 'Recording',
    '11': 'Self',
    '12': 'Participant',
    '13': 'Spotlight',
    '14': 'Remote Request',
    '15': 'Webinar',
    '16': 'LocalMediaHandler',
};
const ERROR_CODES = {
    '0000': 'Internal exception.',
    '0001': 'Failed to initialize.',
    '0002': 'Failed to join room.',
    '0003': 'Failed to leave room.',
    '0100': 'Internal exception',
    '0200': 'Internal exception.',
    '0300': 'Internal exception',
    '0400': 'Internal exception',
    '0500': 'Internal exception',
    '0501': 'Permission denied.',
    '0502': 'Invalid message body.',
    '0600': 'Internal exception',
    '0700': 'Internal exception',
    '0800': 'Internal exception',
    '0900': 'Internal exception',
    '1000': 'Internal exception',
    '1100': 'Internal exception',
    '1200': 'Internal exception',
    '1300': 'Internal exception',
    '1400': 'Internal exception',
    '1500': 'Internal exception',
    '1600': 'Internal exception',
    '1601': 'Failed to get audio track',
    '1602': 'Failed to get video track',
    '1603': 'Incorrect device',
    '1604': 'Failed to change device',
};
Object.keys(ERROR_CODES).forEach((key) => {
    ERROR_CODES[key] = `{${MODULE_CODE_MAPPINGS[key.slice(0, 2)]}} ${ERROR_CODES[key]}`;
});
export default class DyteError extends Error {
    code;
    constructor(message, code, log = false) {
        super(message);
        this.code = code;
        this.name = 'DyteError';
        this.message = `[ERR${this.code}]: ${ERROR_CODES[this.code]}\n${this.message}`;
        try {
            let shouldLog = log;
            if (code && code.endsWith('00')) {
                shouldLog = true;
            }
            if (shouldLog) {
                DyteLogger.error('DyteError', { error: { message: this.message, name: this.name, code } });
            }
        }
        catch {
        }
    }
}
function _handleError(ctx, errorType, handler, error) {
    if (typeof handler === 'function' && error instanceof errorType) {
        handler.call(null, error, ctx);
    }
    else {
        throw error;
    }
}
function _generateDescriptor(descriptor, errorType, handler) {
    if (!descriptor.value) {
        const getter = descriptor.get;
        const setter = descriptor.set;
        if (getter) {
            descriptor.get = function () {
                try {
                    return getter.apply(this);
                }
                catch (error) {
                    _handleError(this, errorType, handler, error);
                }
            };
        }
        if (setter) {
            descriptor.set = function (v) {
                try {
                    return setter.apply(this, [v]);
                }
                catch (error) {
                    _handleError(this, errorType, handler, error);
                }
            };
        }
        return descriptor;
    }
    const originalMethod = descriptor.value;
    descriptor.value = function (...args) {
        try {
            const result = originalMethod.apply(this, args);
            if (result && result instanceof Promise) {
                return result.catch((error) => {
                    _handleError(this, errorType, handler, error);
                });
            }
            return result;
        }
        catch (error) {
            _handleError(this, errorType, handler, error);
        }
    };
    return descriptor;
}
export function Catch(errorType, handler) {
    return (target, _propertyKey, descriptor) => {
        if (descriptor) {
            return _generateDescriptor(descriptor, errorType, handler);
        }
        for (const propertyName of Reflect.ownKeys(target.prototype).filter((prop) => prop !== 'constructor')) {
            const desc = Object.getOwnPropertyDescriptor(target.prototype, propertyName);
            const isMethod = desc.value instanceof Function
                || desc.get instanceof Function
                || desc.set instanceof Function;
            if (!isMethod)
                continue;
            Object.defineProperty(target.prototype, propertyName, _generateDescriptor(desc, errorType, handler));
        }
    };
}
export const CatchAll = (handler) => Catch(Error, handler);
