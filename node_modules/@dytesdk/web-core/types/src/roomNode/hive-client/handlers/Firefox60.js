import Logger from '../Logger';
import { HandlerInterface, } from './HandlerInterface';
const logger = Logger.getLogger('Firefox60');
export class Firefox60 extends HandlerInterface {
    _direction;
    _pc;
    _sendWebStream = new MediaStream();
    _sendScreenShareStream = new MediaStream();
    _transportReady = false;
    static createFactory() {
        return () => new Firefox60();
    }
    constructor() {
        super();
    }
    get name() {
        return 'Firefox60';
    }
    get pc() {
        return this._pc;
    }
    close() {
        logger.debug('close()');
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) {
                logger.error('pc.close()', error);
            }
        }
    }
    init({ direction, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, onTrackHandler, }) {
        logger.debug('init()');
        this._direction = direction;
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        if (onTrackHandler) {
            this._pc.addEventListener('track', (event) => {
                onTrackHandler(event);
            });
        }
        this._addEventListeners();
    }
    async connect() {
        const dc = this._pc.createDataChannel('dyte');
        const offer = await this._pc.createOffer();
        logger.info('connect offer', offer);
        await this._pc.setLocalDescription(offer);
        const callback = async (answer) => {
            logger.debug('connect() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            dc.close();
        };
        return {
            offerSdp: offer,
            callback,
        };
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        throw new Error('not supported');
    }
    async restartIce() {
        logger.debug('restartIce()');
        const offer = await this.pc.createOffer({
            iceRestart: true,
        });
        logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
        const callback = async (answer) => {
            logger.info('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        };
        return {
            offerSdp: offer,
            callback,
        };
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, screenShare, }) {
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        logger.debug('creating new transceiver');
        const trans = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [screenShare ? this._sendScreenShareStream : this._sendWebStream],
        });
        if (encodings) {
            encodings.reverse();
            const parameters = trans.sender.getParameters();
            parameters.encodings = encodings;
            await trans.sender.setParameters(parameters);
        }
        const offer = await this._pc.createOffer();
        if (!this._transportReady)
            throw new Error('webrtc transport not connected');
        await this._pc.setLocalDescription(offer);
        offer.sdp = offer.sdp.replace('minptime=10;useinbandfec=1', 'minptime=10;useinbandfec=1;usedtx=1;maxaveragebitrate=16000');
        const setAnswer = async (answer) => {
            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this.midTransceiverMap.set(trans.mid, trans);
            return trans.mid;
        };
        return {
            offerSdp: offer,
            callback: setAnswer,
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        transceiver.direction = 'inactive';
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const callback = async (answer) => {
            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this.midTransceiverMap.delete(localId);
        };
        return {
            offerSdp: offer,
            callback,
        };
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        const updatedSpatialLayer = parameters.encodings.length - 1 - spatialLayer;
        parameters.encodings.forEach((encoding, idx) => {
            if (idx >= updatedSpatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
    }
    getSenderStats(localId) {
        this._assertSendDirection();
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        logger.info('active transcievers: %o', this._pc.getTransceivers());
        const offer = await this._pc.createOffer();
        logger.debug('stopRecieving() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const callback = async (answer) => {
            logger.debug('stopRecieving() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this.midTransceiverMap.delete(localId);
        };
        return {
            offerSdp: offer,
            callback,
        };
    }
    async pauseReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('pauseReceiving() [localId:%s]', localId);
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        const offer = await this._pc.createOffer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const callback = async (answer) => {
            logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        };
        return {
            offerSdp: offer,
            callback,
        };
    }
    async resumeReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('resumeReceiving() [localId:%s]', localId);
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'recvonly';
        const offer = await this._generateOffer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [offer:%o]', offer);
        const callback = async (answer) => {
            logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        };
        return {
            offerSdp: offer,
            callback,
        };
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const transceiver = this.midTransceiverMap.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
    async _generateOffer() {
        const offer = await this._pc.createOffer();
        await this._pc.setLocalDescription(offer);
        return offer;
    }
    async _setAnswer(answer) {
        logger.debug('_setAnswer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    _addEventListeners() {
        this._pc.addEventListener('datachannel', (event) => {
            logger.info('data channel created: ', event.channel.label);
            const { channel } = event;
            channel.onopen = () => {
                logger.info('data channel open: ', event.channel.label);
            };
            channel.onclose = () => {
                logger.warn('data channel closed: ', event.channel.label);
            };
            channel.onerror = (error) => {
                logger.error('data channel error: ', event.channel.label, error);
            };
            channel.onmessage = async (msg) => {
                logger.debug('data channel message: ', event.channel.label, msg);
                const buffer = await msg.data.arrayBuffer();
                this.safeEmit('datachannel', event.channel, String.fromCharCode.apply(null, new Uint8Array(buffer)));
            };
        });
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    this._transportReady = true;
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
                default:
                    logger.warn('unknown state');
                    break;
            }
        });
        this._pc.addEventListener('icecandidate', (event) => {
            if (event.candidate) {
                this.emit('@icecandidate', {
                    candidate: event.candidate,
                });
            }
        });
        this._pc.addEventListener('negotiationneeded', () => {
            this.emit('@negotiationneeded', {});
            logger.debug('negotiationneeded');
        });
        this._pc.addEventListener('icegatheringstatechange', () => {
            switch (this._pc.iceGatheringState) {
                case 'gathering':
                    logger.debug('icegatheringstatechange | gathering');
                    this.emit('@icegatheringstatechange', 'gathering');
                    break;
                case 'complete':
                    logger.debug('icegatheringstatechange | complete');
                    this.emit('@icegatheringstatechange', 'complete');
                    break;
                default:
                    logger.warn('unknown state');
                    break;
            }
        });
        this._pc.addEventListener('icecandidateerror', (e) => {
            logger.info('chrome74::icecandidateerror', e);
        });
    }
}
