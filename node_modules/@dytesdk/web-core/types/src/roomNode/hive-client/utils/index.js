export function clone(data, defaultValue) {
    if (typeof data === 'undefined') {
        return defaultValue;
    }
    return JSON.parse(JSON.stringify(data));
}
export const REASON_TRANSPORT_CLOSED = 'transport closed';
export const sleep = (duration) => new Promise((resolve) => {
    setTimeout(resolve, duration);
});
export class DytePromise extends Promise {
    constructor(executor, timeout, message = new Error('Promise timed out'), onTimeout) {
        super(executor);
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                if (onTimeout) {
                    onTimeout();
                }
                reject(message);
            }, timeout);
            executor((result) => {
                clearTimeout(timeoutId);
                resolve(result);
            }, (reason) => {
                clearTimeout(timeoutId);
                reject(reason);
            });
        });
    }
    static withTimeout(promise, timeout, msg, onTimeout) {
        return new DytePromise((resolve, reject) => {
            promise.then((v) => {
                resolve(v);
            }).catch((e) => {
                reject(e);
            });
        }, timeout, msg, onTimeout);
    }
    static all(promises, ignoreError) {
        return Promise.all(promises.map(async (promise) => {
            try {
                const result = await promise;
                return result;
            }
            catch (reason) {
                if (ignoreError) {
                    return reason;
                }
                throw new Error(reason);
            }
        }));
    }
}
