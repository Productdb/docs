import { AwaitQueue } from 'awaitqueue';
import * as transform from 'sdp-transform';
import * as utils from './utils';
import { Producer } from './Producer';
import { Consumer } from './Consumer';
import { InvalidStateError, UnsupportedError } from './Errors';
import { EnhancedEventEmitter } from './EnhancedEventEmitter';
import Logger from './Logger';
import { REASON_TRANSPORT_CLOSED } from './utils';
const logger = Logger.getLogger('Transport');
export class Transport extends EnhancedEventEmitter {
    _id;
    _serverId;
    _closed = false;
    _direction;
    _maxSctpMessageSize;
    _handler;
    _connectionState = 'new';
    _producers;
    _consumers;
    _datachannels;
    _connected = false;
    _transportConnectionPromise = null;
    awaitQueue;
    observer;
    consumerTrackEvents;
    unknownTracksMap;
    _appData;
    datachannelCache = new Map();
    constructor({ id, direction, handlerFactory, iceServers, iceTransportPolicy, proprietaryConstraints, additionalSettings, appData, }) {
        super();
        logger.debug('constructor() [id: %s, direction: %s]', id, direction);
        this._id = id;
        this._direction = direction;
        const additionalSettingsCloned = utils.clone(additionalSettings, {});
        delete additionalSettingsCloned.iceServers;
        delete additionalSettingsCloned.iceTransportPolicy;
        delete additionalSettingsCloned.bundlePolicy;
        delete additionalSettingsCloned.rtcpMuxPolicy;
        delete additionalSettingsCloned.sdpSemantics;
        this._producers = new Map();
        this._consumers = new Map();
        this._datachannels = new Map();
        this.consumerTrackEvents = new Map();
        this.unknownTracksMap = new Map();
        this.awaitQueue = new AwaitQueue();
        this.observer = new EnhancedEventEmitter();
        this._handler = handlerFactory();
        this._handler.init({
            onTrackHandler: this._ontrack.bind(this),
            direction,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
        });
        this._appData = appData || {};
        this._transportConnectionPromise = new Promise((resolve) => {
            this.observer.once('connected', () => { resolve(true); });
            this.observer.once('disconnect', () => { resolve(false); });
            this.observer.once('close', () => { resolve(false); });
        });
        this._handler.on('@connectionstatechange', (connectionState) => {
            if (connectionState === this._connectionState) {
                return;
            }
            logger.debug('connection state changed to %s', connectionState);
            this._connectionState = connectionState;
            if (connectionState === 'connected') {
                this._connected = true;
                this.observer.emit('connected');
            }
            if (connectionState === 'disconnected') {
                this._connected = false;
                this.observer.emit('disconnect');
            }
            if (connectionState === 'failed' || connectionState === 'closed') {
                this._connected = false;
                this.observer.emit('close');
            }
            if (!this._closed) {
                this.safeEmit('connectionstatechange', connectionState);
            }
        });
        this._handler.on('@icecandidate', ({ candidate }) => {
            if (this._closed) {
                return;
            }
            this.safeEmit('icecandidate', candidate);
        });
        this._handler.on('datachannel', (channel, msg) => {
            if (!this._datachannels.has(channel.label)) {
                this._datachannels.set(channel.label, channel);
            }
            const dcmsg = JSON.parse(msg);
            if (!this.datachannelCache.has(dcmsg.id)) {
                this.datachannelCache.set(dcmsg.id, []);
            }
            this.datachannelCache.get(dcmsg.id)?.push(dcmsg);
            if (this.datachannelCache.get(dcmsg.id)?.length === dcmsg.count) {
                const chunks = this.datachannelCache.get(dcmsg.id);
                const message = chunks?.reduce((acc, chunk) => acc + chunk.chunk, '');
                this.datachannelCache.delete(dcmsg.id);
                try {
                    const parsedMessage = JSON.parse(message);
                    this.safeEmit(`datachannel:${channel.label}`, channel, parsedMessage);
                }
                catch (e) {
                    logger.error('error parsing message', e);
                }
            }
        });
    }
    get id() {
        return this._id;
    }
    get serverId() {
        return this._serverId;
    }
    get connected() {
        return this._connected;
    }
    get isConnected() {
        return this._transportConnectionPromise;
    }
    get datachannels() {
        return this._datachannels;
    }
    get closed() {
        return this._closed;
    }
    get direction() {
        return this._direction;
    }
    get handler() {
        return this._handler;
    }
    get connectionState() {
        return this._connectionState;
    }
    get appData() {
        return this._appData;
    }
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    setServerId(id) {
        this._serverId = id;
    }
    getDatachannel(label) {
        return this._datachannels.get(label);
    }
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._connected = false;
        this._closed = true;
        this._handler.close();
        [...this._producers.values()]
            .forEach((producer) => producer.close(REASON_TRANSPORT_CLOSED));
        this._producers.clear();
        [...this._consumers.values()]
            .forEach((consumer) => consumer.close(REASON_TRANSPORT_CLOSED));
        this._consumers.clear();
        this.emit('close');
        this.observer.emit('close');
    }
    async getStats() {
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        return this._handler.getTransportStats();
    }
    async connect() {
        try {
            const { offerSdp, callback } = await this._handler.connect();
            const { answer } = await this.safeEmitAsPromise('connect', { offer: offerSdp });
            await callback(answer);
            if (!await this.isConnected) {
                throw new Error('ice connection failed');
            }
        }
        catch (error) {
            logger.error('transport failed to connect:', error);
            throw error;
        }
    }
    async restartIce() {
        logger.debug('restartIce()');
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        return this._handler.restartIce();
    }
    async updateIceServers({ iceServers } = {}) {
        logger.debug('updateIceServers()');
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        this._handler.updateIceServers(iceServers);
    }
    async produce({ track, encodings, codecOptions, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {}, } = {}) {
        logger.debug(`produce() [track:${track.id}]`);
        if (!track) {
            throw new TypeError('missing track');
        }
        else if (this._direction !== 'send') {
            throw new UnsupportedError('not a sending Transport');
        }
        else if (track.readyState === 'ended') {
            throw new InvalidStateError('track ended');
        }
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('produce') === 0) {
            throw new TypeError('no "produce" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        if (!await this.isConnected) {
            return Promise.reject(new Error('Transport not connected'));
        }
        const { producerId, localId } = await this.awaitQueue.push(async () => {
            const { offerSdp, callback } = await this._handler.send({
                track,
                encodings,
                codecOption: codecOptions,
                screenShare: appData?.screenShare,
            });
            const { answer, producerId: pId } = await this.safeEmitAsPromise('produce', {
                offer: offerSdp,
                kind: track.kind,
                paused: disableTrackOnPause ? !track.enabled : false,
                appData,
            });
            const lId = await callback(answer);
            return { producerId: pId, localId: lId };
        });
        const producer = new Producer({
            id: producerId,
            localId,
            track,
            stopTracks,
            disableTrackOnPause,
            zeroRtpOnPause,
            appData,
            handler: this.handler,
        });
        this._producers.set(producerId, producer);
        producer.observer.on('close', () => {
            this._producers.delete(producer.id);
        });
        this.emit('newproducer', producer);
        this.observer.emit('newproducer', producer);
        return producer;
    }
    async consumePeer(producingPeerId, appData = {}) {
        logger.debug('consumePeer() producingPeerId:', producingPeerId);
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new UnsupportedError('not a receiving Transport');
        }
        else if (typeof producingPeerId !== 'string') {
            throw new TypeError('missing producingPeerId');
        }
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        if (!await this.isConnected) {
            return Promise.reject(new Error('Transport not connected'));
        }
        const promises = [];
        const { consumersMap } = await this.safeEmitAsPromise('consumePeer', { producingPeerId });
        consumersMap.forEach((entry, producerId) => {
            const { consumerId, trackId, screenShare, paused, streamId, kind, } = entry;
            promises.push(this._consumerCreationTask({
                consumerId,
                trackId,
                streamId,
                kind,
                producerId,
                producingPeerId,
                paused,
                screenShare,
                appData,
            }));
        });
        logger.info('promises', promises);
        return Promise.allSettled(promises);
    }
    async consume({ producerId, producingPeerId, appData = {}, }) {
        logger.debug('consume()');
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new UnsupportedError('not a receiving Transport');
        }
        else if (typeof producerId !== 'string') {
            throw new TypeError('missing producerId');
        }
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        if (!await this.isConnected) {
            return Promise.reject(new Error('Transport not connected'));
        }
        try {
            const { consumerId, screenShare, trackId, paused, streamId, kind, } = await this.safeEmitAsPromise('consume', { producerId, producingPeerId });
            return this._consumerCreationTask({
                consumerId,
                screenShare,
                trackId,
                streamId,
                kind,
                paused,
                producerId,
                producingPeerId,
                appData,
            });
        }
        catch (error) {
            logger.error('consume failed:', error);
            throw error;
        }
    }
    async _consumerCreationTask({ consumerId, producerId, producingPeerId, streamId, trackId, paused, screenShare, appData, kind, }) {
        const key = `${streamId}:${kind}`;
        const error = {
            consumerId,
            producerId,
            producingPeerId,
            streamId,
            trackId,
            appData,
            kind,
            paused,
            screenShare,
            name: 'consumer creation task error',
            message: 'consumer creation failed',
        };
        const consumerPromise = new Promise((resolve, reject) => {
            const timeoutTimer = setTimeout(() => {
                this.consumerTrackEvents.delete(key);
                error.isTimedout = true;
                this.consumerTrackEvents.delete(key);
                reject(error);
            }, 5000);
            const handler = async (event) => {
                try {
                    if (event.track.readyState === 'ended') {
                        clearTimeout(timeoutTimer);
                        reject(error);
                    }
                    else {
                        const { transceiver } = event;
                        this.handler.midTransceiverMap.set(transceiver.mid, transceiver);
                        const consumer = new Consumer({
                            id: consumerId,
                            localId: event.transceiver.mid,
                            track: event.track,
                            paused,
                            producerId,
                            producingPeerId,
                            handler: this._handler,
                            appData: { ...appData, screenShare },
                        });
                        this._consumers.set(consumerId, consumer);
                        consumer.once('close', () => {
                            this._consumers.delete(consumer.id);
                            this.handler.midTransceiverMap.delete(transceiver.mid);
                        });
                        logger.info('consumer created for ', { producerId, trackId, producingPeerId });
                        this.observer.emit('newconsumer', consumer);
                        clearTimeout(timeoutTimer);
                        resolve(consumer);
                    }
                }
                catch (err) {
                    logger.warn('error while creating consumer:', err);
                    clearTimeout(timeoutTimer);
                    reject(error);
                }
            };
            const existingTrack = this.unknownTracksMap.get(key);
            if (existingTrack) {
                this.unknownTracksMap.delete(key);
                handler(existingTrack);
            }
            else {
                this.consumerTrackEvents.set(key, handler);
            }
        });
        return consumerPromise;
    }
    _ontrack(event) {
        logger.info('track event received', event);
        const key = `${event.streams[0].id}:${event.track.kind}`;
        const eventHandler = this.consumerTrackEvents.get(key);
        if (eventHandler) {
            eventHandler(event);
            this.consumerTrackEvents.delete(key);
        }
        else {
            logger.warn(`track event handler not found ${key}`);
            this.unknownTracksMap.set(key, event);
        }
    }
    async setRemoteDescription(sdp) {
        await this._handler.pc.setRemoteDescription(sdp);
    }
    async setLocalDescription(sdp) {
        logger.debug(`${this.direction}() {transportId: ${this.serverId}} | calling pc.setLocalDescription() [offer:%o]`, sdp);
        await this._handler.pc.setLocalDescription(sdp);
    }
    async setRemoteOffer(offer) {
        await this.setRemoteDescription(offer);
        const ans = await this._handler.pc.createAnswer();
        const parsedSdp = transform.parse(ans.sdp);
        const opusPayloadType = 111;
        const opusRtcpFb = {
            payload: opusPayloadType,
            type: 'nack',
        };
        parsedSdp.media = parsedSdp.media.map((mediaSection) => {
            if (mediaSection.type === 'audio') {
                const updatedMediaSection = { ...mediaSection };
                if (!updatedMediaSection.rtcpFb) {
                    updatedMediaSection.rtcpFb = [];
                }
                const hasNack = updatedMediaSection.rtcpFb.some((rtcpFb) => rtcpFb.type === 'nack' && rtcpFb.payload === opusPayloadType);
                if (!hasNack) {
                    updatedMediaSection.rtcpFb.push(opusRtcpFb);
                }
                return updatedMediaSection;
            }
            return mediaSection;
        });
        ans.sdp = transform.write(parsedSdp);
        await this.setLocalDescription(ans);
        return ans;
    }
    async retryFailedConsumerCreationTasks(tasks) {
        return Promise.allSettled(tasks.map((task) => {
            logger.warn('retrying failed consumer creation task', task);
            return this._consumerCreationTask({
                ...task,
            });
        }));
    }
}
export function isConsumerCreationTaskError(error) {
    return 'name' in error && error.name === 'consumer creation task error';
}
