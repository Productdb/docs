import { AwaitQueue } from 'awaitqueue';
import { GenericHandlerResult, HandlerFactory, HandlerInterface } from './handlers/HandlerInterface';
import { Producer, ProducerOptions } from './Producer';
import { Consumer, ConsumerOptions } from './Consumer';
import { EnhancedEventEmitter } from './EnhancedEventEmitter';
export interface TransportOptions {
    iceServers?: RTCIceServer[];
    iceTransportPolicy?: RTCIceTransportPolicy;
    additionalSettings?: any;
    proprietaryConstraints?: any;
    appData?: Record<string, unknown>;
}
export interface InternalTransportOptions extends TransportOptions {
    id?: string;
    direction: 'send' | 'recv';
    handlerFactory?: HandlerFactory;
}
export declare type ConnectionState = 'new' | 'connecting' | 'connected' | 'failed' | 'disconnected' | 'closed';
export interface ConsumerStateObject {
    consumerId: string;
    trackId: string;
    streamId: string;
    screenShare: boolean;
    paused: boolean;
    kind: 'audio' | 'video';
}
export interface ConsumerCreationTaskOptions extends ConsumerStateObject {
    producerId: string;
    producingPeerId: string;
    appData: Object;
}
export interface ConsumerCreationTaskError extends Error {
    consumerId: string;
    producerId: string;
    producingPeerId: string;
    paused: boolean;
    screenShare: boolean;
    streamId: string;
    trackId: string;
    kind: 'audio' | 'video';
    appData: Object;
    name: string;
    isTimedout?: boolean;
}
export declare class Transport extends EnhancedEventEmitter {
    private readonly _id;
    private _serverId;
    private _closed;
    private readonly _direction;
    private readonly _maxSctpMessageSize?;
    private readonly _handler;
    private _connectionState;
    private _producers;
    private _consumers;
    private _datachannels;
    private _connected;
    private _transportConnectionPromise;
    awaitQueue: AwaitQueue;
    observer: EnhancedEventEmitter;
    private consumerTrackEvents;
    private unknownTracksMap;
    private readonly _appData;
    private datachannelCache;
    constructor({ id, direction, handlerFactory, iceServers, iceTransportPolicy, proprietaryConstraints, additionalSettings, appData, }: InternalTransportOptions);
    get id(): string;
    get serverId(): string;
    get connected(): boolean;
    get isConnected(): Promise<Boolean>;
    get datachannels(): Map<string, RTCDataChannel>;
    get closed(): boolean;
    get direction(): 'send' | 'recv';
    get handler(): HandlerInterface;
    get connectionState(): ConnectionState;
    get appData(): Record<string, unknown>;
    set appData(appData: Record<string, unknown>);
    setServerId(id: string): void;
    getDatachannel(label: string): RTCDataChannel;
    close(): void;
    getStats(): Promise<RTCStatsReport>;
    connect(): Promise<void>;
    restartIce(): Promise<GenericHandlerResult>;
    updateIceServers({ iceServers }?: {
        iceServers?: RTCIceServer[];
    }): Promise<void>;
    produce({ track, encodings, codecOptions, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }?: ProducerOptions): Promise<Producer>;
    consumePeer(producingPeerId: string, appData?: {}): Promise<PromiseSettledResult<Consumer | ConsumerCreationTaskError>[]>;
    consume({ producerId, producingPeerId, appData, }: ConsumerOptions): Promise<Consumer>;
    private _consumerCreationTask;
    private _ontrack;
    private setRemoteDescription;
    private setLocalDescription;
    setRemoteOffer(offer: RTCSessionDescriptionInit): Promise<RTCSessionDescriptionInit>;
    retryFailedConsumerCreationTasks(tasks: ConsumerCreationTaskError[]): Promise<PromiseSettledResult<Consumer>[]>;
}
export declare function isConsumerCreationTaskError(error: any): error is ConsumerCreationTaskError;
