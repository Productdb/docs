import { EnhancedEventEmitter } from './EnhancedEventEmitter';
import { InvalidStateError, UnsupportedError } from './Errors';
import Logger from './Logger';
import { REASON_TRANSPORT_CLOSED } from './utils';
const logger = Logger.getLogger('Producer');
export class Producer extends EnhancedEventEmitter {
    _id;
    _localId;
    _closed = false;
    _handler;
    _track;
    _kind;
    _paused;
    _maxSpatialLayer;
    _stopTracks;
    _disableTrackOnPause;
    _zeroRtpOnPause;
    _appData;
    observer;
    constructor({ id, localId, track, stopTracks, disableTrackOnPause, zeroRtpOnPause, handler, appData, }) {
        super();
        this._id = id;
        this._localId = localId;
        this._track = track;
        this._kind = track.kind;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = undefined;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData || {};
        this._onTrackEnded = this._onTrackEnded.bind(this);
        this._handler = handler;
        this.observer = new EnhancedEventEmitter();
        this._handleTrack();
    }
    get id() {
        return this._id;
    }
    get localId() {
        return this._localId;
    }
    get closed() {
        return this._closed;
    }
    get kind() {
        return this._kind;
    }
    get track() {
        return this._track;
    }
    get paused() {
        return this._paused;
    }
    get maxSpatialLayer() {
        return this._maxSpatialLayer;
    }
    get appData() {
        return this._appData;
    }
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    close(reason) {
        if (this._closed) {
            return;
        }
        logger.debug('close() with reason:', reason);
        this._closed = true;
        this._destroyTrack();
        if (reason === REASON_TRANSPORT_CLOSED) {
            this.observer.emit('close');
            return;
        }
        this._handler.stopSending(this.localId).then(({ offerSdp: offer, callback }) => {
            this.safeEmit('close', offer, callback, reason);
        }).finally(() => {
            this.observer.emit('close');
        });
    }
    async getStats() {
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        return this._handler.getSenderStats(this.localId);
    }
    pause() {
        logger.debug(`producer(${this.id}):pause()`);
        if (this._closed) {
            logger.error('pause() | Producer closed');
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
        }
        if (this._zeroRtpOnPause) {
            this._handler.replaceTrack(this.localId, null);
        }
        this.observer.emit('pause');
    }
    resume() {
        logger.debug(`producer(${this.id}):resume()`);
        if (this._closed) {
            logger.error('resume() | Producer closed');
            return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
        }
        if (this._zeroRtpOnPause) {
            this._handler.replaceTrack(this.localId, this._track);
        }
        this.observer.emit('resume');
    }
    async replaceTrack({ track }) {
        logger.debug('replaceTrack() [track:%o]', track);
        if (this._closed) {
            if (track && this._stopTracks) {
                try {
                    track.stop();
                }
                catch (error) {
                    logger.error(error);
                }
            }
            throw new InvalidStateError('closed');
        }
        else if (track && track.readyState === 'ended') {
            throw new InvalidStateError('track ended');
        }
        if (track === this._track) {
            logger.debug('replaceTrack() | same track, ignored');
            return;
        }
        if (!this._zeroRtpOnPause || !this._paused) {
            await this._handler.replaceTrack(this.localId, track);
        }
        this._destroyTrack();
        this._track = track;
        if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
                this._track.enabled = true;
            }
            else if (this._paused) {
                this._track.enabled = false;
            }
        }
        this._handleTrack();
    }
    async setMaxSpatialLayer(spatialLayer) {
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        else if (this._kind !== 'video') {
            throw new UnsupportedError('not a video Producer');
        }
        else if (typeof spatialLayer !== 'number') {
            throw new TypeError('invalid spatialLayer');
        }
        await this._handler.setMaxSpatialLayer(this.localId, spatialLayer);
        this._maxSpatialLayer = spatialLayer;
    }
    async setRtpEncodingParameters(params) {
        if (this._closed) {
            throw new InvalidStateError('closed');
        }
        else if (typeof params !== 'object') {
            throw new TypeError('invalid params');
        }
        await this._handler.setRtpEncodingParameters(this.localId, params);
    }
    _onTrackEnded() {
        logger.debug('track "ended" event');
        this.observer.emit('trackended');
        this.safeEmit('trackended', this.track.id);
    }
    _handleTrack() {
        if (!this._track) {
            return;
        }
        this._track.addEventListener('ended', this._onTrackEnded);
    }
    _destroyTrack() {
        if (!this._track) {
            return;
        }
        try {
            this._track.removeEventListener('ended', this._onTrackEnded);
            if (this._stopTracks) {
                this._track.stop();
            }
        }
        catch (error) {
            logger.error(error);
        }
    }
}
