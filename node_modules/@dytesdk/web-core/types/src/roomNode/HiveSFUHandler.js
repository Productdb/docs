type callStats = any; 
type ConsumerToggleRequest = any; type ProducerKind = any; type RenegotiateRequest = any; type Target = any; type  = any; 
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import * as sdpTransform from 'sdp-transform';
import { getAPIClient } from '../api';
import { mediaEvents } from '../socketService/socketEvents';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import { FlagsmithFeatureFlags } from '../utils/flags';
import { BaseSFUHandler } from './BaseSFUHandler';
import { Device } from './hive-client/Device';
import Logger from './hive-client/Logger';
import { isConsumerCreationTaskError, } from './hive-client/Transport';
import HiveSFUSocketHandler from '../socketService/HiveSFUSocketHandler';
import DyteLogger from '../client/internals/DyteLogger';
export var TransportState;
(function (TransportState) {
    TransportState["CONNECTING"] = "connecting";
    TransportState["RECONNECTING"] = "reconnecting";
    TransportState["DISCONNECTED"] = "disconnected";
    TransportState["CONNECTED"] = "connected";
    TransportState["FAILED"] = "failed";
})(TransportState || (TransportState = {}));
export default class HiveSFUHandler extends BaseSFUHandler {
    _device;
    _sendTransport;
    _recvTransport;
    _consumers;
    _producers;
    _producerIdToConsumerIdMap;
    _logger;
    _socket;
    _socketHandler;
    transportConnectionStatus;
    constructor(socket) {
        super();
        this._producers = new Map();
        this._consumers = new Map();
        this._producerIdToConsumerIdMap = new Map();
        this.transportConnectionStatus = new Map();
        this._device = new Device();
        this._logger = Logger.getLogger('HiveSFUHandler');
        this._socket = socket;
        this._socketHandler = new HiveSFUSocketHandler(socket);
    }
    get socket() {
        return this._socket;
    }
    get producers() {
        return this._producers;
    }
    get consumers() {
        return this._consumers;
    }
    get producerIdToConsumerIdMap() {
        return this._producerIdToConsumerIdMap;
    }
    get hiveSocketHandler() {
        return this._socketHandler;
    }
    async setupTransports(transportTypes) {
        const APIClient = getAPIClient();
        const iceServers = await APIClient.getICEServers();
        const promises = transportTypes.map((transportType) => {
            const tres = this.transportConnectionStatus.get(transportType);
            if (tres) {
                return tres;
            }
            switch (transportType) {
                case 'send':
                    {
                        const promise = this.createSendTransport({ iceServers });
                        this.transportConnectionStatus.set(transportType, promise);
                        return promise;
                    }
                case 'recv':
                    {
                        const promise = this.createRecvTransport({ iceServers });
                        this.transportConnectionStatus.set(transportType, promise);
                        return promise;
                    }
                default: {
                    this._logger.warn(`what are you thinking when passing this ${transportType}?`);
                    return Promise.reject(Error('TYPE_OF_TRANSPORT_UNKNOWN'));
                }
            }
        });
        await Promise.all(promises).finally(() => {
            transportTypes.forEach((type) => {
                this.transportConnectionStatus.delete(type);
            });
        });
    }
    async stopAllTransports() {
        this._logger.info('closing all the transports');
        this._sendTransport?.close();
        this._recvTransport?.close();
        this._sendTransport = undefined;
        this._recvTransport = undefined;
    }
    async createSendTransport(transportOpts) {
        if (this._sendTransport && this._sendTransport.connected) {
            return;
        }
        this._logger.info('sendTransport::initializing_transport');
        const transport = this._device.createSendTransport(transportOpts);
        this._logger.info('sendTransport::initialized_transport');
        this.handleTransport(transport, false);
        this._logger.info('sendTransport::connecting_transport');
        try {
            await transport.connect();
        }
        catch (error) {
            this._logger.error('fail to connect send transport:', transport.id, '[Error]:', error, 'retrying once.');
            await transport.connect().catch((e) => {
                this._logger.error('failed to connect send transport after retry:', transport.id, '[Error]:', e);
            });
        }
        this._logger.info('sendTransport::connected_transport');
        this._sendTransport = transport;
        callStats.onSafeInitialization(() => {
            callStats.configureSendTransport(transport);
        });
        Object.assign(window, { sendTransport: transport });
    }
    async createRecvTransport(transportOpts) {
        if (this._recvTransport && this._recvTransport.connected) {
            return;
        }
        this._logger.info('recvTransport::initializing_transport');
        const transport = this._device.createRecvTransport({
            ...transportOpts,
            additionalSettings: {
                rtcAudioJitterBufferMaxPackets: 25,
                rtcAudioJitterBufferFastAccelerate: true,
                rtcAudioJitterBufferMinDelayMs: 20,
            },
        });
        callStats.onSafeInitialization(() => {
            callStats.configureRecvTransport(transport);
        });
        this._logger.info('recvTransport::initialized_transport');
        this.handleTransport(transport, true);
        this._logger.info('recvTransport::connecting_transport');
        try {
            await transport.connect();
        }
        catch (error) {
            this._logger.error('fail to connect recv transport:', transport.id, '[Error]:', error, 'retrying once.');
            await transport.connect().catch((e) => {
                this._logger.error('failed to connect recv transport after retry:', transport.id, '[Error]:', e);
            });
        }
        this._logger.info('recvTransport::connected_transport');
        this._recvTransport = transport;
        this.producerIdToConsumerIdMap.clear();
    }
    handleTransport(transport, consuming) {
        transport.on('connect', async ({ offer }, callback, err) => {
            try {
                const req = {
                    consuming,
                    description: {
                        sdp: offer.sdp,
                        type: offer.type,
                        target: consuming ? Target.SUBSCRIBER : Target.PUBLISHER,
                    },
                };
                const { transportId, answer, } = await this._socketHandler.connectTransport(req);
                transport.setServerId(transportId);
                callback({ answer });
            }
            catch (error) {
                this._logger.error(`${consuming ? 'consumer' : 'producer'} transport connection error:`, error);
                err(error);
            }
        });
        transport.on('connectionstatechange', async (state) => {
            this._logger.info(`${consuming ? 'consumer' : 'producer'} transport connectionState:`, state);
            switch (state) {
                case 'failed':
                case 'disconnected':
                    if (transport.closed)
                        return;
                    this._logger.info(`${consuming ? 'consumer' : 'producer'} transport disconnected or failed, reconnecting...`);
                    if (flagsmith.hasFeature(FlagsmithFeatureFlags.ENABLE_HIVE_TRANSPORT_RECONNECTION_ON_ICE_FAILED)) {
                        SessionStore.emit(SessionEvents.HIVE_TRANSPORT_STATE_CHANGED, { state: TransportState.RECONNECTING, transportDirection: consuming ? 'recv' : 'send' });
                        this.emit('reconnect_transport', transport);
                    }
                    else {
                        SessionStore.emit(SessionEvents.HIVE_TRANSPORT_STATE_CHANGED, { state: state, transportDirection: consuming ? 'recv' : 'send' });
                    }
                    break;
                case 'new':
                case 'closed':
                    break;
                default:
                    SessionStore.emit(SessionEvents.HIVE_TRANSPORT_STATE_CHANGED, { state: state, transportDirection: consuming ? 'recv' : 'send' });
                    break;
            }
        });
        transport.on('icecandidate', async (candidate) => {
            this._logger.debug('sending icecandidate:', candidate.toJSON());
        });
        transport.on('datachannel:events', async (channel, msg) => {
            this._logger.debug('got data channel message on event:', msg);
            try {
                switch (msg.type) {
                    case 'offer': {
                        const offer = {
                            sdp: msg.payload.sdp,
                            type: 'offer',
                        };
                        let resPayload;
                        try {
                            const ans = await transport.setRemoteOffer(offer);
                            resPayload = {
                                type: 'answer',
                                payload: {
                                    type: ans.type,
                                    sdp: ans.sdp,
                                },
                            };
                        }
                        catch (e) {
                            this._logger.error('datachannel:events::Error:', e);
                            resPayload = {
                                type: 'error',
                                payload: {
                                    error: e.message,
                                },
                            };
                        }
                        this._logger.debug('datachannel answer:', resPayload);
                        channel.send(JSON.stringify(resPayload));
                        break;
                    }
                    case 'consumer_toggle': {
                        const { mute, trackId } = msg.payload;
                        this._logger.info('consumer toggled for', trackId, 'muted:', mute);
                        const consumer = this.consumers.get(trackId);
                        if (!consumer) {
                            this._logger.warn('consumer with id', trackId, ' not found');
                            return;
                        }
                        if (consumer.paused !== mute) {
                            this._logger.debug('consumer state is not same', { consumerPaused: consumer.paused, mute });
                            if (mute) {
                                consumer.pause();
                                SessionStore.emit(SessionEvents.CONSUMER_PAUSED, { id: consumer.id });
                            }
                            else {
                                consumer.resume();
                                SessionStore.emit(SessionEvents.CONSUMER_RESUMED, { id: consumer.id });
                            }
                        }
                        break;
                    }
                    default:
                        this._logger.warn('unknown event received from hive node, event:', msg.type);
                        break;
                }
            }
            catch (error) {
                this._logger.error('Unable to handle the incoming datachannel message on', channel.label);
            }
        });
        transport.on('negotiate', async ({ description }, callback, err) => {
            try {
                const offer = {
                    sdp: description?.sdp,
                    type: description?.type,
                };
                const answer = await this.negotiate(transport, offer);
                callback({
                    answer,
                });
            }
            catch (e) {
                this._logger.error('negotiate error:', e);
                err(e);
            }
        });
        transport.on('close', () => {
            this._logger.info(`${consuming ? 'consumer' : 'producer'} transport closed`, transport.id);
            if (consuming) {
                this._recvTransport = undefined;
                return;
            }
            this._sendTransport = undefined;
        });
        if (!consuming) {
            transport.on('produce', async ({ offer, kind, paused, appData, }, callback, err) => {
                const parsedSdp = sdpTransform.parse(offer.sdp);
                const msid = parsedSdp.media.filter((m) => (kind === 'video'
                    ? m.type === 'video'
                    : m.type === 'audio')).at(-1)
                    .msid;
                const req = {
                    description: {
                        sdp: offer.sdp,
                        type: offer.type,
                        target: Target.PUBLISHER,
                    },
                    paused,
                    kind,
                    msid,
                    screenShare: appData.screenShare ?? false,
                };
                try {
                    const { answer, producerId } = await this._socketHandler.produce(req);
                    callback({ answer, producerId });
                }
                catch (e) {
                    this._logger.error('create producer error:', e);
                    err(e);
                }
            });
            return;
        }
        transport.on('datachannel:negotiation', async (channel, msg) => {
            try {
                this._logger.info('datachannel message recieved:', channel.label, msg);
                const offer = {
                    sdp: msg,
                    type: 'offer',
                };
                const ans = await transport.setRemoteOffer(offer);
                this._logger.info('datachannel answer:', ans);
                channel.send(ans.sdp);
            }
            catch (e) {
                this._logger.error('datachannel:negotiation::Error:', e);
            }
        });
        transport.on('consumePeer', async ({ producingPeerId }, callback, err) => {
            this._logger.info('consumePeer:', producingPeerId);
            const req = {
                producingPeerId,
            };
            try {
                const consumerStateMap = await this._socketHandler.consume(req);
                this._logger.debug(`consumePeer response for ${producingPeerId}:`, { consumerStateMap });
                const consumersMap = new Map();
                Object.entries(consumerStateMap).forEach(([producerId, consumerState]) => {
                    consumersMap.set(producerId, {
                        consumerId: consumerState.consumerId,
                        trackId: consumerState.producerTrack?.trackId,
                        streamId: consumerState.producerTrack.streamId,
                        kind: consumerState.producerState.kind === ProducerKind.VIDEO ? 'video' : 'audio',
                        screenShare: consumerState.producerState?.screenShare,
                        paused: consumerState.producerState?.pause,
                    });
                });
                callback({ consumersMap });
            }
            catch (e) {
                this._logger.error('consumePeer error:', e);
                err(e);
            }
        });
        transport.on('consume', async ({ producerId, producingPeerId }, callback, err) => {
            const req = {
                producingPeerId,
                producerId,
            };
            try {
                const consumerStateMap = await this._socketHandler.consume(req);
                const consumerState = consumerStateMap[producerId];
                this._logger.info('consumer create response:', {
                    consumerState,
                    paused: consumerState.producerState?.pause,
                });
                callback({
                    consumerId: consumerState.consumerId,
                    screenShare: consumerState.producerState?.screenShare,
                    trackId: consumerState.producerTrack?.trackId,
                    streamId: consumerState.producerTrack.streamId,
                    kind: consumerState.producerState.kind === ProducerKind.VIDEO ? 'video' : 'audio',
                    paused: consumerState.producerState?.pause,
                });
            }
            catch (e) {
                this._logger.error('error during consuming on server:', e);
                err(e);
            }
        });
    }
    async createProducer(producerType, producerOptions, onDisconnect) {
        if (this._sendTransport === undefined || this._sendTransport.closed) {
            return;
        }
        const producer = await this._sendTransport.produce(producerOptions);
        producer.on('close', async (offer, cb, reason) => {
            this._logger.info('producer id:', producer.id, 'closed with reason:', reason);
            const req = {
                producerId: producer.id,
                description: {
                    sdp: offer.sdp,
                    type: offer.type,
                    target: Target.PUBLISHER,
                },
            };
            try {
                const remoteAnswer = await this._socketHandler.closeProducer(req);
                this._logger.info('response', remoteAnswer);
                const answer = {
                    sdp: remoteAnswer?.sdp,
                    type: remoteAnswer?.type,
                };
                cb(answer);
            }
            catch (e) {
                this._logger.error('producer close error:', e);
            }
            this._producers.delete(producerType);
            onDisconnect();
            if (producerType === "screenshare_video") {
                this._switchWebcamLayers(3);
            }
        });
        producer.on('trackended', () => {
            DyteLogger.info('producer::trackended', {
                producer: {
                    id: producer?.id,
                    kind: producerType,
                    status: 'UNKNOWN',
                    appData: producer?.appData,
                },
            });
            if (!["mic", "webcam"].includes(producerType)) {
                onDisconnect();
            }
        });
        this._producers.set(producerType, producer);
        if (this._producers.has("screenshare_video")) {
            this._switchWebcamLayers(0);
        }
    }
    async _switchWebcamLayers(layer) {
        const webCamProducer = this._producers.get("webcam");
        if (!webCamProducer) {
            return;
        }
        try {
            this._logger.debug('switching layer of webcam producer to:', layer);
            await webCamProducer.setMaxSpatialLayer(layer);
        }
        catch (error) {
            this._logger.error('failed to switch spatial layer', error);
        }
    }
    _initConsumer(consumer) {
        if (!consumer)
            return;
        consumer.observer.on('close', async (reason) => {
            this._logger.debug('consumer closed', reason);
            this._consumers.delete(consumer.id);
            SessionStore.emit(SessionEvents.CONSUMER_CLOSED, { id: consumer.id });
        });
        this._consumers.set(consumer.id, consumer);
        this.producerIdToConsumerIdMap.set(consumer.producerId, consumer.id);
        SessionStore.emit(SessionEvents.NEW_CONSUMER, { id: consumer.id });
    }
    async consumePeer(producingPeerId) {
        if (this._recvTransport === undefined || this._recvTransport.closed
            || !this._recvTransport.connected) {
            throw Error('Receiving transport not connected');
        }
        try {
            const results = await this._recvTransport
                .consumePeer(producingPeerId);
            const failedTasks = [];
            results.forEach((result) => {
                if (result.status === 'rejected') {
                    failedTasks.push(result.reason);
                }
                else {
                    this._initConsumer(result.value);
                }
            });
            this._recvTransport.retryFailedConsumerCreationTasks(failedTasks)
                .then((retriedConsumersResult) => {
                retriedConsumersResult.forEach((result) => {
                    if (result.status === 'rejected') {
                        this._logger.error('consumer creation failed 2nd time, this should never happen second time.', result.reason);
                    }
                    else {
                        this._initConsumer(result.value);
                    }
                });
            });
        }
        catch (error) {
            this._logger.error('got error in consumePeer', error);
            throw error;
        }
    }
    async createConsumer(consumerOpts) {
        if (this._recvTransport === undefined || this._recvTransport.closed
            || !this._recvTransport.connected) {
            return;
        }
        const { producerId, producingPeerId, appData, } = consumerOpts;
        const producer = this.getProducer(producerId);
        if (producer) {
            this._logger.warn('why are you creating a consumer for local producer?');
            return;
        }
        try {
            const consumer = await this._recvTransport.consume({
                producerId,
                producingPeerId,
                appData,
            });
            this._initConsumer(consumer);
        }
        catch (error) {
            if (isConsumerCreationTaskError(error)) {
                this._recvTransport.retryFailedConsumerCreationTasks([error])
                    .then(([result]) => {
                    if (result.status === 'fulfilled') {
                        this._initConsumer(result.value);
                    }
                    else {
                        this._logger.error('failed to complete consumer creation task again.', 'this should not happen', result.reason);
                    }
                });
            }
        }
        Object.assign(window, { consumers: this._consumers });
    }
    async pauseProducer(type) {
        const producer = this._producers.get(type);
        if (!producer) {
            this._logger.warn('producer type:', type, 'not found');
            return;
        }
        producer.pause();
        this._logger.info(type, 'producer id:', producer.id, 'paused');
    }
    async resumeProducer(type) {
        const producer = this._producers.get(type);
        if (!producer) {
            this._logger.warn('producer type:', type, 'not found');
            return;
        }
        producer.resume();
        this._logger.info(type, 'producer id:', producer.id, 'resumed');
    }
    async replaceTrack(type, track) {
        const producer = this._producers.get(type);
        if (!producer) {
            this._logger.warn('producer type:', type, 'not found');
            return;
        }
        await producer.replaceTrack({ track });
        this._logger.info('track replaced with id:', track.id, 'on producer:', type);
    }
    async removeProducer(type, stopTrack) {
        const producer = this._producers.get(type);
        if (!producer) {
            this._logger.warn('producer type:', type, 'not found');
            return;
        }
        if (stopTrack) {
            producer.track.stop();
        }
        producer.close();
    }
    async pauseConsumer(consumerId) {
        const consumer = this._consumers.get(consumerId);
        if (!consumer) {
            this._logger.warn('consumer id:', consumerId, 'not found');
            return;
        }
        try {
            const request = {
                consumerId,
                pause: true,
            };
            await this.socket.sendMessagePromise(mediaEvents.toggleConsumer, ConsumerToggleRequest.toBinary(request));
            consumer.pause();
            SessionStore.emit(SessionEvents.CONSUMER_PAUSED, { id: consumer.id });
            this._logger.info('consumer:', consumerId, 'paused');
        }
        catch (error) {
            this._logger.error('error on pausing consumer', error);
        }
    }
    async toggleConsumerOverDC(consumerId, mute) {
        const req = {
            type: 'consumer_toggle',
            payload: {
                consumerId,
                mute,
            },
        };
        const dc = this._recvTransport.getDatachannel('events');
        if (!dc) {
            this._logger.warn('events datachannel not found');
            return;
        }
        dc.send(JSON.stringify(req));
    }
    async resumeConsumer(consumerId) {
        const consumer = this._consumers.get(consumerId);
        if (!consumer) {
            this._logger.warn('consumer id:', consumerId, 'not found');
            return;
        }
        if (!consumer.paused) {
            this._logger.warn('consumer is not paused so not resuming', consumerId);
            return;
        }
        try {
            const request = {
                consumerId,
                pause: false,
            };
            await this.socket.sendMessagePromise(mediaEvents.toggleConsumer, ConsumerToggleRequest.toBinary(request));
            consumer.resume();
            SessionStore.emit(SessionEvents.CONSUMER_RESUMED, { id: consumer.id });
            this._logger.info('consumer:', consumerId, 'resumed');
        }
        catch (error) {
            this._logger.error('error on resuming consumer', error);
        }
    }
    async closeConsumer(consumerId, force) {
        return this.closeConsumers([consumerId], force);
    }
    async closeConsumers(consumerIds, force = false) {
        this._logger.info('Closing consumers:', consumerIds, 'with force:', force);
        let closeProvidedConsumers = true;
        const availableConsumerIds = consumerIds.filter((id) => {
            const consumer = this._consumers.get(id);
            if (!consumer) {
                this._logger.warn('consumer id:', id, 'not found');
                return false;
            }
            return true;
        });
        const req = {
            consumerIds: availableConsumerIds,
        };
        const closeFn = async () => this._recvTransport?.awaitQueue.push(async () => {
            await this._socketHandler.closeConsumer(req);
        }).catch((e) => {
            this._logger.warn('error on closing consumer:', e);
            closeProvidedConsumers = force;
        });
        if (!force) {
            await closeFn();
        }
        else {
            closeFn();
        }
        if (closeProvidedConsumers) {
            availableConsumerIds.forEach((id) => {
                const consumer = this.consumers.get(id);
                this.producerIdToConsumerIdMap.delete(consumer.producerId);
                consumer.close(force ? 'manually closed' : undefined);
            });
        }
    }
    async cleanupConsumers(peerId) {
        const consumers = [];
        this._consumers.forEach((consumer) => {
            if (peerId) {
                if (consumer.peerId === peerId) {
                    consumers.push(consumer.id);
                }
            }
            else {
                consumers.push(consumer.id);
            }
        });
        this.closeConsumers(consumers, true);
    }
    async stopAllProducers() {
        this._logger.info('stopping all available producers');
        this._producers.forEach((producer, type) => {
            this._logger.debug('closing producer type', type);
            producer.close();
        });
    }
    getProducer(producerId) {
        return [...this.producers.values()]
            .filter((producer) => producer.id === producerId).at(0);
    }
    async negotiate(transport, offer) {
        this._logger.info('initiating negotiation', offer);
        this._logger.info('setting remote offer :', offer, 'on transport', transport.serverId);
        const answer = await transport.setRemoteOffer(offer);
        const regReq = {
            transportId: transport.serverId,
            description: {
                sdp: answer.sdp,
                type: answer.type,
                target: Target.SUBSCRIBER,
            },
        };
        this._logger.info('sending renegotiate request', regReq);
        await this.socket.sendMessagePromise(mediaEvents.renegotiateSessionDescription, RenegotiateRequest.toBinary(regReq));
        this._logger.info('renegotiation done', transport.serverId);
        return answer;
    }
}
