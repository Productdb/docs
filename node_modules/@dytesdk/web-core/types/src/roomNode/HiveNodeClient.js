var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
type callStats = any; 
type GlobalPeerPinningBroadcastResponse = any; type GlobalPeerPinningRequest = any; type PeerDisplayNameEditBroadcastResponse = any; type PeerJoinBroadcastResponse = any; type PeerLeaveBroadcastResponse = any; type PeerLeaveRequest = any; type PeerLeaveResponse = any; type PeerProducerCloseBroadcastResponse = any; type PeerProducerCreateBroadcastResponse = any; type PeerProducerToggleBroadcastResponse = any; type ProducerKind = any; type ProducerToggleRequest = any; type RecordingStartedBroadcastResponse = any; type RecordingStoppedBroadcastResponse = any; type SelectedPeersDiffResponse = any; type SelectedPeersResponse = any; type  = any; 
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import { getAPIClient } from '../api';
import { browserSpecs } from '../browser/BrowserCapabilities';
import DyteLogger from '../client/internals/DyteLogger';
import { mediaEvents } from '../socketService/socketEvents';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import constants from '../utils/constants';
import { FlagsmithFeatureFlags } from '../utils/flags';
import DyteTelemetry from '../utils/opentelemetry';
import BaseRoomNodeClient from './BaseRoomNodeClient';
import HiveSFUHandler from './HiveSFUHandler';
import { WEBCAM_SIMULCAST_ENCODINGS_HIVE_CLIENT, } from './RoomNodeConfig';
import Logger from './hive-client/Logger';
import { Transport } from './hive-client/Transport';
export default class HiveNodeClient extends BaseRoomNodeClient {
    #socketClient;
    #sfuHandler;
    #onSocketReconnection;
    #roomJoiningInProgress;
    legacyMode;
    roomNodeUrl;
    peerDisplayName;
    activatedProducingPeerIds;
    logger;
    constructor(options) {
        super();
        const { roomName, peerId, authToken, legacyMode, socketClient, meetingTitle, } = options;
        this.roomName = roomName;
        this.peerId = peerId;
        this.authToken = authToken;
        this.legacyMode = legacyMode;
        this.roomJoined = false;
        this.meetingTitle = meetingTitle;
        this.#roomJoiningInProgress = false;
        this.#socketClient = socketClient;
        this.#sfuHandler = new HiveSFUHandler(socketClient);
        this.maxPreferredStreams = 6;
        this.activatedProducingPeerIds = new Set();
        this.logger = Logger.getLogger('HiveNodeClient()');
        callStats.legacySwitch(legacyMode);
        this.handleSocketEvents();
        this.handleSFUEvents();
        this.#onSocketReconnection = () => {
            this.logger.info('noop reconnection handler');
        };
    }
    static async init(options) {
        const { legacyMode = true, roomName, peerId, authToken, meetingTitle, socket, } = options;
        const roomNodeClient = new HiveNodeClient({
            legacyMode,
            authToken,
            socketClient: socket,
            peerId,
            roomName,
            meetingTitle,
        });
        socket.onStateEvent('disconnected', (event) => {
            roomNodeClient.isDisconnected = true;
            roomNodeClient.#sfuHandler?.cleanupConsumers();
            SessionStore.emit(SessionEvents.ROOM_NODE_DISCONNECTED, event);
            roomNodeClient.roomJoined = false;
            DyteLogger.info('HIVE_NODE_DISCONNECTED');
        });
        socket.onStateEvent('reconnected', async () => {
            DyteLogger.info('HIVE_NODE_RECONNECTED');
            await roomNodeClient.#sfuHandler?.cleanupConsumers();
            roomNodeClient.#onSocketReconnection();
        });
        socket.onStateEvent('connected', async (event) => {
            SessionStore.emit(SessionEvents.ROOM_NODE_CONNECTED, event);
            DyteLogger.info('HIVE_NODE_CONNECTED');
        });
        return roomNodeClient;
    }
    get sfuHandler() {
        return this.#sfuHandler;
    }
    set onSocketReconnection(fn) {
        this.#onSocketReconnection = fn;
    }
    async reconnectTransport(transport) {
        this.logger.info('Room joining state', this.#roomJoiningInProgress);
        if (!transport || this.#roomJoiningInProgress)
            return;
        transport.close();
        if (transport.direction === 'send') {
            await this.sfuHandler.setupTransports(['send']);
            this.logger.info('send transport reconected!');
            SessionStore.emit(SessionEvents.RESET_PRODUCER_STATE);
            return;
        }
        this.sfuHandler.cleanupConsumers();
        await this.sfuHandler.setupTransports(['recv']);
        this.logger.info('recv transport reconnected!');
        this.activatedProducingPeerIds = new Set();
        SessionStore.emit(SessionEvents.REFRESH_GRID, true);
    }
    async setupTransports() {
        await this.#sfuHandler.setupTransports(['recv', 'send']);
    }
    async joinRoom(displayName, audioMuted, roomUuid, roomTitle, currentUserSharedMediaStates = {}) {
        await this.sfuHandler.stopAllTransports();
        this.peerDisplayName = displayName;
        this.#roomJoiningInProgress = true;
        try {
            await this.sfuHandler.hiveSocketHandler.joinRoom(roomUuid, displayName);
            await this.setupTransports();
            if (flagsmith.hasFeature(FlagsmithFeatureFlags.INTERNAL_CALL_STATS)
                && navigator.product !== 'ReactNative') {
                setTimeout(async () => {
                    const APIClient = getAPIClient();
                    const userResponse = await APIClient.getUserDetails();
                    const user = constants.isV2AuthToken
                        ? userResponse.participant
                        : userResponse;
                    const peerData = {
                        userId: user.id ?? user.participant.id,
                        peerId: this.peerId,
                        displayName,
                        roomUUID: this.roomUUID,
                        roomViewType: 'groupCall',
                        roomName: this.roomName,
                        deviceInfo: {
                            ...browserSpecs.getDeviceInfo(),
                            userAgent: navigator.userAgent,
                            memory: navigator.deviceMemory,
                            cpus: navigator.hardwareConcurrency,
                        },
                        metaData: {},
                        permissions: {},
                    };
                    callStats.roomJoined(peerData);
                    if (currentUserSharedMediaStates?.audio) {
                        callStats.audioOn();
                    }
                    else {
                        callStats.audioOff();
                    }
                    if (currentUserSharedMediaStates?.video) {
                        callStats.videoOn();
                    }
                    else {
                        callStats.videoOff();
                    }
                });
            }
            const joined = await this.completeJoinRoom();
            return { roomJoined: joined };
        }
        catch (error) {
            this.logger.error('error on sending join room request', error);
            return { roomJoined: false };
        }
    }
    async completeJoinRoom() {
        try {
            const { maxPreferredStreams, participants, roomState, selectedPeers, } = await this.sfuHandler.hiveSocketHandler.notifySelfJoinComplete();
            this.logger.debug('peerJoinCompleteResponse', { participants, roomState, selectedPeers });
            this.roomUUID = roomState.roomUuid;
            this.maxPreferredStreams = maxPreferredStreams;
            const peers = participants.map((p) => {
                const producerState = p.producerStates;
                const participant = {
                    id: p.peerId,
                    isHost: false,
                    displayName: p.displayName,
                    flags: {},
                    userId: p.userId,
                    audioMuted: true,
                    videoEnabled: false,
                    audioTrack: null,
                    videoTrack: null,
                    producers: [],
                };
                producerState.forEach((state) => {
                    if (state.kind === ProducerKind.AUDIO) {
                        participant.audioMuted = state.pause;
                    }
                    else {
                        participant.videoEnabled = !state.pause;
                    }
                    participant.producers.push({
                        producerId: state.producerId,
                        kind: state.kind === ProducerKind.AUDIO ? 'audio' : 'video',
                        pause: state.pause,
                        screenShare: state.screenShare,
                    });
                });
                return participant;
            });
            const { audioPeers, compulsoryPeers } = selectedPeers ?? {};
            const joinedPeers = peers.filter((p) => p.id !== this.peerId);
            this.logger.debug('audioPeers: ', audioPeers, 'compulsoryPeer', compulsoryPeers);
            this.#roomJoiningInProgress = false;
            this.roomJoined = true;
            DyteLogger.info('RoomNodeClient::joinRoom::pre_emitasync_room_joined');
            await SessionStore.emitAsync(SessionEvents.ROOM_JOINED, {
                peers: joinedPeers,
            });
            if (roomState.isRecording) {
                SessionStore.emit(SessionEvents.HIVE_RECORDING_STARTED, roomState.recorderParticipantId);
            }
            DyteLogger.info('RoomNodeClient::joinRoom::post_emitasync_room_joined');
            SessionStore.emit(SessionEvents.SELF_ROOM_JOINED);
            SessionStore.emit(SessionEvents.SELECTED_PEERS, {
                peerIds: audioPeers ?? [],
                compulsoryPeers,
            });
            SessionStore.emit(SessionEvents.REFRESH_GRID);
            return true;
        }
        catch (error) {
            this.logger.error('error on completing join room:', error);
            return false;
        }
    }
    async leaveRoom() {
        await this.#sfuHandler.stopAllTransports();
        const req = {
            closeRoom: false,
        };
        this.#socketClient.sendMessagePromise(mediaEvents.leaveRoom, PeerLeaveRequest.toBinary(req)).then((response) => {
            const closed = PeerLeaveResponse.fromBinary(response.payload)?.closed;
            if (!closed) {
                this.logger.warn('weird state on peer closed and should not happen');
            }
        }).catch((e) => {
            this.logger.error('error on sending leave room request', e);
        });
        callStats.callEnded();
        DyteTelemetry.destruct();
    }
    getConsumers() {
        return this.#sfuHandler.consumers;
    }
    async activatePeers(producerInfos) {
        const promises = producerInfos.map(({ peerId, producers, force }) => {
            if (producers.length === 0) {
                return Promise.resolve();
            }
            let consume = false;
            const consumersToResume = [];
            producers.every((producer) => {
                const consumerId = this.sfuHandler.producerIdToConsumerIdMap
                    .get(producer.producerId);
                if (!consumerId) {
                    consume = true;
                    return false;
                }
                const consumer = this.sfuHandler.consumers.get(consumerId);
                if (consumer && !producer.pause && consumer.paused) {
                    consumersToResume.push(consumerId);
                }
                return true;
            });
            if (consume || force) {
                return this.consumePeer(peerId, force);
            }
            if (consumersToResume.length > 0) {
                return this.resumeConsumers(consumersToResume);
            }
            return Promise.resolve();
        });
        await Promise.all(promises);
    }
    async deactivatePeers(producerInfo) {
        this.logger.info('deactivating producers', producerInfo);
        producerInfo.producers.forEach(({ producerId, kind, screenShare }) => {
            if (kind === 'audio' || (kind === 'video' && screenShare)) {
                this.logger.debug('we don\'t want to pause audio or screenshare');
                return;
            }
            const consumer = this.sfuHandler.producerIdToConsumerIdMap.get(producerId);
            if (!consumer) {
                this.logger.warn('consumer not found in deactivate producers:', producerId);
                return;
            }
            this.sfuHandler.pauseConsumer(consumer);
        });
        this.activatedProducingPeerIds.delete(producerInfo.peerId);
    }
    async createConsumer({ producerId, producingPeerId, screenShare, }) {
        return this.sfuHandler.createConsumer({
            producerId,
            producingPeerId,
            appData: {
                screenShare,
            },
        });
    }
    async pauseConsumers(consumerIds) {
        consumerIds.forEach((id) => {
            this.sfuHandler.pauseConsumer(id);
        });
    }
    async resumeConsumers(consumerIds) {
        consumerIds.forEach((id) => {
            this.sfuHandler.resumeConsumer(id);
        });
    }
    async closeConsumers(peers) {
        const consumerIds = [...this.getConsumers().values()]
            .filter((c) => peers.includes(c.peerId))
            .map((c) => c.id);
        peers.forEach((id) => {
            this.activatedProducingPeerIds.delete(id);
        });
        return this.sfuHandler.closeConsumers(consumerIds);
    }
    async consumePeer(producingPeerId, force) {
        this.logger.info('current activated Peer ids', [...this.activatedProducingPeerIds.values()], 'forced?:', force);
        if (!this.activatedProducingPeerIds.has(producingPeerId) || force) {
            try {
                await this.#sfuHandler.consumePeer(producingPeerId);
                this.activatedProducingPeerIds.add(producingPeerId);
            }
            catch (e) {
                this.logger.error('consumePeer failed in HiveNodeClient.ts', e);
            }
        }
        else {
            this.logger.info('not creating consumer for this peerId', producingPeerId);
        }
    }
    async shareWebcam(videoTrack) {
        if (videoTrack === undefined) {
            return;
        }
        if (this.#sfuHandler.producers.has("webcam")) {
            const webcamProducer = this.#sfuHandler.producers.get("webcam");
            if (!webcamProducer.closed) {
                await webcamProducer.replaceTrack({ track: videoTrack });
                await this.resumeWebcam();
                return;
            }
            await this.#sfuHandler.removeProducer(webcamProducer.id);
        }
        const producerOptions = {
            track: videoTrack,
            codecOptions: {
                name: 'VP8',
            },
            appData: {
                screenShare: false,
            },
            stopTracks: false,
        };
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.ENABLE_HIVE_SIMULCAST)) {
            let webcamResolution = videoTrack.getConstraints().width;
            if (!(webcamResolution in WEBCAM_SIMULCAST_ENCODINGS_HIVE_CLIENT)) {
                webcamResolution = 320;
            }
            producerOptions.encodings = WEBCAM_SIMULCAST_ENCODINGS_HIVE_CLIENT[webcamResolution];
        }
        const onDisconnect = () => {
            this.disableWebcam();
        };
        await this.#sfuHandler.createProducer("webcam", producerOptions, onDisconnect);
    }
    async shareScreen(tracks) {
        const { video: videoTrack, audio: audioTrack } = tracks;
        if (videoTrack === undefined) {
            return;
        }
        const producerOptions = {
            track: videoTrack,
            codecOptions: {
                name: 'VP8',
            },
            appData: {
                screenShare: true,
                supportsRemoteControl: browserSpecs.isElectron(),
            },
            stopTracks: false,
        };
        let onDisconnect = () => {
            this.disableScreenShare();
        };
        callStats.screenShareRequested();
        await this.#sfuHandler
            .createProducer("screenshare_video", producerOptions, onDisconnect);
        if (audioTrack) {
            const audioProducerOptions = {
                track: audioTrack,
                codecOptions: {
                    name: 'opus',
                },
                appData: {
                    screenShare: true,
                    supportsRemoteControl: browserSpecs.isElectron(),
                },
                stopTracks: false,
            };
            onDisconnect = () => {
            };
            await this.#sfuHandler.createProducer("screenshare_audio", audioProducerOptions, onDisconnect);
        }
    }
    async shareMic(audioTrack) {
        if (audioTrack === undefined) {
            return;
        }
        if (this.#sfuHandler.producers.has("mic")) {
            const micProducer = this.#sfuHandler.producers.get("mic");
            if (!micProducer.closed) {
                await micProducer.replaceTrack({ track: audioTrack });
                await this.resumeMic();
                return;
            }
            await this.#sfuHandler.removeProducer("mic", false);
        }
        const producerOptions = {
            track: audioTrack,
            encodings: [{
                    priority: 'high',
                }],
            codecOptions: {
                name: 'opus',
            },
            stopTracks: false,
        };
        const onDisconnect = () => {
            this.disableMic();
        };
        await this.#sfuHandler.createProducer("mic", producerOptions, onDisconnect);
    }
    pauseMic() {
        const micProducer = this.#sfuHandler.producers.get("mic");
        if (!micProducer) {
            DyteLogger.error('pauseMic::could_not_find_mic_producer');
            return;
        }
        if (micProducer.paused) {
            DyteLogger.info('pauseMic::mic_producer_already_paused');
            return;
        }
        micProducer.pause();
        const req = {
            producerId: micProducer.id,
            pause: true,
        };
        this.#socketClient.sendMessage(mediaEvents.toggleProducer, ProducerToggleRequest.toBinary(req));
    }
    async pauseWebcam() {
        const webcamProducer = this.#sfuHandler.producers.get("webcam");
        if (!webcamProducer) {
            DyteLogger.error('pauseWebcam::could_not_find_webcam_producer');
            return;
        }
        webcamProducer.pause();
        const req = {
            producerId: webcamProducer.id,
            pause: true,
        };
        this.#socketClient.sendMessage(mediaEvents.toggleProducer, ProducerToggleRequest.toBinary(req));
    }
    async resumeMic() {
        const micProducer = this.#sfuHandler.producers.get("mic");
        if (!micProducer) {
            DyteLogger.error('resumeMic::could_not_find_mic_producer');
            return;
        }
        if (!micProducer.pause) {
            DyteLogger.info('resumeMic::mic_producer_already_resumed');
            return;
        }
        micProducer.resume();
        const req = {
            producerId: micProducer.id,
            pause: false,
        };
        this.#socketClient.sendMessage(mediaEvents.toggleProducer, ProducerToggleRequest.toBinary(req));
    }
    async resumeWebcam() {
        const webcamProducer = this.#sfuHandler.producers.get("webcam");
        if (!webcamProducer) {
            DyteLogger.error('resumeWebcam::could_not_find_webcam_producer');
            return;
        }
        webcamProducer.resume();
        const req = {
            producerId: webcamProducer.id,
            pause: false,
        };
        this.#socketClient.sendMessage(mediaEvents.toggleProducer, ProducerToggleRequest.toBinary(req));
    }
    async disableWebcam() {
        await this.#sfuHandler.removeProducer("webcam");
    }
    async disableMic() {
        await this.#sfuHandler.removeProducer("mic");
    }
    async disableScreenShare() {
        DyteLogger.info('screen_sharing_stopped');
        await this.#sfuHandler.removeProducer("screenshare_video");
        await this.#sfuHandler.removeProducer("screenshare_audio");
    }
    async muteSelf() {
        this.pauseMic();
    }
    async unmuteSelf() {
        await this.resumeMic();
    }
    async resetVideoProducers(videoTrack, screenShareTrack) {
        if (videoTrack) {
            await this.#sfuHandler.removeProducer("webcam", false);
            this.shareWebcam(videoTrack);
        }
        if (screenShareTrack) {
            await this.#sfuHandler.removeProducer("screenshare_video", false);
            this.shareScreen({ video: screenShareTrack });
        }
    }
    async getPolls() {
        return { payload: { polls: {} } };
    }
    async changeDisplayName(displayName, peerId) {
        const req = {
            displayName,
            participantId: peerId ?? this.peerId,
        };
        const changed = await this.sfuHandler.hiveSocketHandler.changeDisplayName(req);
        if (!changed) {
            throw new Error('failed to change display name!');
        }
    }
    async kick(peerId) {
        const req = {
            participantId: peerId,
        };
        const kicked = await this.sfuHandler.hiveSocketHandler.kickPeer(req);
        if (!kicked) {
            throw new Error('failed to kickout the participant!');
        }
    }
    async kickAll() {
        const kicked = await this.sfuHandler.hiveSocketHandler.kickAll();
        if (!kicked) {
            throw new Error('failed to kickout all participant!');
        }
    }
    async muteAll(allowUnMute) {
        const muted = await this.sfuHandler.hiveSocketHandler.hostControlForAll('audio');
        if (!muted) {
            throw new Error('failed to mute all participant');
        }
    }
    async muteAllVideo() {
        const muted = await this.sfuHandler.hiveSocketHandler.hostControlForAll('video');
        if (!muted) {
            throw new Error('failed to mute all participant');
        }
    }
    async mutePeer(peerId) {
        const muted = await this.sfuHandler.hiveSocketHandler.hostControlForPeer(peerId, 'audio');
        if (!muted) {
            throw new Error('failed to mute given participant');
        }
    }
    async mutePeerVideo(peerId) {
        const muted = await this.sfuHandler.hiveSocketHandler.hostControlForPeer(peerId, 'video');
        if (!muted) {
            throw new Error('failed to mute given participant');
        }
    }
    async pinPeer(peerId) {
        const req = {
            participantId: peerId ?? '',
        };
        try {
            await this.#socketClient.sendMessagePromise(mediaEvents.globalPinPeer, GlobalPeerPinningRequest.toBinary(req));
        }
        catch (error) {
            this.logger.error(`Error in pinning peer: ${error}`);
        }
    }
    async handleSocketEvents() {
        this.#socketClient.on(mediaEvents.peerJoinedBroadcast, ({ id, payload }) => {
            if (!this.roomJoined)
                return;
            this.logger.debug('got peer joined with id', id);
            try {
                const { participant: { peerId, displayName, producerStates, userId, }, } = PeerJoinBroadcastResponse.fromBinary(payload);
                if (peerId === this.peerId) {
                    return;
                }
                this.logger.info('peer-joined', { peerId, displayName, producerStates });
                const participant = {
                    id: peerId,
                    isHost: false,
                    displayName,
                    flags: {},
                    userId,
                    audioMuted: true,
                    videoEnabled: false,
                    audioTrack: null,
                    videoTrack: null,
                    producers: [],
                };
                producerStates.forEach((state) => {
                    if (state.kind === ProducerKind.AUDIO) {
                        participant.audioMuted = state.pause;
                    }
                    else {
                        participant.videoEnabled = !state.pause;
                    }
                    participant.producers.push({
                        producerId: state.producerId,
                        kind: state.kind === ProducerKind.AUDIO ? 'audio' : 'video',
                        pause: state.pause,
                        screenShare: state.screenShare,
                    });
                });
                SessionStore.emit(SessionEvents.PEER_JOINED, participant);
                SessionStore.emit(SessionEvents.REFRESH_GRID);
            }
            catch (e) {
                this.logger.error('error in peer-joined-broadcast', e);
            }
        });
        this.#socketClient.on(mediaEvents.peerProducerCreateBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const { participantId, producerState, } = PeerProducerCreateBroadcastResponse.fromBinary(payload);
                if (participantId === this.peerId) {
                    return;
                }
                this.logger.info('producer created broadcast:', participantId, 'producer state', producerState);
                SessionStore.emit(SessionEvents.NEW_PRODUCER, {
                    peerId: participantId,
                    producer: {
                        producerId: producerState.producerId,
                        kind: producerState.kind === ProducerKind.AUDIO ? 'audio' : 'video',
                        pause: producerState.pause,
                        screenShare: producerState.screenShare,
                    },
                });
            }
            catch (e) {
                this.logger.error('error in peer-producer-create-broadcast', e);
            }
        });
        this.#socketClient.on(mediaEvents.peerProducerToggleBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const { participantId, producerState: { kind, pause, producerId }, } = PeerProducerToggleBroadcastResponse.fromBinary(payload);
                const convertedKind = kind === ProducerKind.AUDIO ? 'audio' : 'video';
                this.logger.info('producer toggle broadcast:', participantId, 'producerId', producerId, 'kind', convertedKind, 'paused', pause);
                if (participantId === this.peerId && pause) {
                    SessionStore.emit(convertedKind === 'audio' ? SessionEvents.MUTE_ALL : SessionEvents.MUTE_ALL_VIDEO);
                    return;
                }
                SessionStore.emit(SessionEvents.PRODUCER_TOGGLE, {
                    peerId: participantId, producerId, paused: pause, kind: convertedKind,
                });
                const consumersForThisProducer = [...this.getConsumers().values()]
                    .filter((consumer) => consumer.producerId === producerId);
                consumersForThisProducer.forEach((consumer) => {
                    if (consumer.paused !== pause) {
                        this.logger.debug('consumer state mismatched for', consumer.id, '. updating consumer pause state', consumer.paused, 'to', pause);
                        if (pause) {
                            consumer.pause();
                            SessionStore.emit(SessionEvents.CONSUMER_PAUSED, { id: consumer.id });
                        }
                        else {
                            consumer.resume();
                            SessionStore.emit(SessionEvents.CONSUMER_RESUMED, { id: consumer.id });
                        }
                    }
                });
            }
            catch (e) {
                this.logger.error('error in producer toggle broadcast handler', e);
            }
        });
        this.#socketClient.on(mediaEvents.selectedPeer, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const { audioPeers, compulsoryPeers } = SelectedPeersResponse.fromBinary(payload);
                this.logger.info('selected peers:', audioPeers, compulsoryPeers);
                SessionStore.emit(SessionEvents.SELECTED_PEERS, {
                    peerIds: compulsoryPeers.concat(audioPeers),
                });
            }
            catch (e) {
                this.logger.error('error in selected-peer', e);
            }
        });
        this.#socketClient.on(mediaEvents.selectedPeerDiff, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const { entries } = SelectedPeersDiffResponse.fromBinary(payload);
                this.logger.debug('selected peers diff:', entries);
                const peerIdsWithPriorities = entries.map((entry) => ({
                    peerId: entry.peerId,
                    priority: entry.priority,
                }));
                SessionStore.emit(SessionEvents.SELECTED_PEERS_DIFF, { entries: peerIdsWithPriorities });
            }
            catch (e) {
                this.logger.error('error in selected-peer-diff', e);
            }
        });
        this.#socketClient.on(mediaEvents.peerLeaveBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const { participantId } = PeerLeaveBroadcastResponse.fromBinary(payload);
                if (participantId === this.peerId) {
                    this.logger.warn('peer got kicked out of the room');
                    SessionStore.emit(SessionEvents.KICKED);
                    return;
                }
                this.logger.info('peer left broadcast:', participantId);
                this.sfuHandler.cleanupConsumers(participantId);
                SessionStore.emit(SessionEvents.PEER_CLOSED, { id: participantId });
            }
            catch (e) {
                this.logger.error('error in peer left broadcast', e);
            }
        });
        this.#socketClient.on(mediaEvents.peerProducerCloseBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const { participantId, producerState: { producerId }, } = PeerProducerCloseBroadcastResponse.fromBinary(payload);
                if (participantId === this.peerId) {
                    return;
                }
                this.logger.info('producer closed broadcast:', participantId);
                SessionStore.emit(SessionEvents.PRODUCER_CLOSED, {
                    peerId: participantId,
                    producerId,
                });
                const consumerId = this.sfuHandler.producerIdToConsumerIdMap.get(producerId);
                if (!consumerId) {
                    this.logger.warn('no consumer found for producer', producerId);
                    return;
                }
                this.logger.info('closing consumer', consumerId, 'producer id ', producerId);
                this.sfuHandler.closeConsumer(consumerId).then(() => {
                    this.logger.info('closed consumer', consumerId);
                    this.sfuHandler.producerIdToConsumerIdMap.delete(producerId);
                    SessionStore.emit(SessionEvents.CONSUMER_CLOSED, { id: consumerId });
                }).catch((err) => {
                    this.logger.error('error closing consumer', err);
                });
            }
            catch (e) {
                this.logger.error('error on producer close broadcast', e);
            }
        });
        this.#socketClient.on(mediaEvents.globalPeerPinBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                let peerId;
                if (payload) {
                    const data = GlobalPeerPinningBroadcastResponse.fromBinary(payload);
                    this.logger.info('pinning peerId: ', data);
                    peerId = data.participantId;
                }
                SessionStore.emit(SessionEvents.PEER_PINNED, {
                    peerId,
                });
            }
            catch (error) {
                this.logger.error('error on global peer pin broadcast', error);
            }
        });
        this.#socketClient.on(mediaEvents.recordingStartedBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                let peerId;
                if (payload) {
                    const data = RecordingStartedBroadcastResponse.fromBinary(payload);
                    this.logger.info('recording started. peerId: ', data);
                    peerId = data.participantId;
                }
                SessionStore.emit(SessionEvents.HIVE_RECORDING_STARTED, peerId);
            }
            catch (error) {
                this.logger.error('error on recording started broadcast', error);
            }
        });
        this.#socketClient.on(mediaEvents.recordingStoppedBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                let peerId;
                if (payload) {
                    const data = RecordingStoppedBroadcastResponse.fromBinary(payload);
                    this.logger.info('recording stopped. peerId: ', data);
                    peerId = data.participantId;
                }
                SessionStore.emit(SessionEvents.HIVE_RECORDING_STOPPED, peerId);
            }
            catch (error) {
                this.logger.error('error on recording started broadcast', error);
            }
        });
        this.#socketClient.on(mediaEvents.peerDisplayNameEditBroadcast, ({ payload }) => {
            if (!this.roomJoined)
                return;
            try {
                const data = PeerDisplayNameEditBroadcastResponse.fromBinary(payload);
                this.logger.debug('peer display name changed to:', data.displayName);
                SessionStore.emit(SessionEvents.PEER_DISPLAY_NAME_CHANGED, data.participantId);
            }
            catch (error) {
                this.logger.error('failed to handle peerDisplayNameEditBroadcast:', error);
            }
        });
    }
    handleSFUEvents() {
        this.#sfuHandler.on('reconnect_transport', async (transport) => {
            try {
                await this.reconnectTransport(transport);
                this.logger.info('transport reconnected [id:%s]', transport.id);
            }
            catch (error) {
                this.logger.error('error on reconnection transports', error);
            }
        });
    }
}
__decorate([
    DyteTelemetry.trace('HiveClient.reconnect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Transport]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "reconnectTransport", null);
__decorate([
    DyteTelemetry.trace('HiveClient.setupTransport'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "setupTransports", null);
__decorate([
    DyteTelemetry.trace('HiveClient.joinRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean, String, String, Object]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "joinRoom", null);
__decorate([
    DyteTelemetry.trace('HiveClient.leaveRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "leaveRoom", null);
__decorate([
    DyteTelemetry.trace('HiveClient.activatePeers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "activatePeers", null);
__decorate([
    DyteTelemetry.trace('HiveClient.deactivatePeers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "deactivatePeers", null);
__decorate([
    DyteTelemetry.trace('HiveClient.createConsumer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "createConsumer", null);
__decorate([
    DyteTelemetry.trace('HiveClient.pauseConsumers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "pauseConsumers", null);
__decorate([
    DyteTelemetry.trace('HiveClient.resumeConsumers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "resumeConsumers", null);
__decorate([
    DyteTelemetry.trace('HiveClient.closeConsumers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "closeConsumers", null);
__decorate([
    DyteTelemetry.trace('HiveClient.consumePeer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "consumePeer", null);
__decorate([
    DyteTelemetry.trace('HiveClient.shareWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "shareWebcam", null);
__decorate([
    DyteTelemetry.trace('HiveClient.shareScreen'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "shareScreen", null);
__decorate([
    DyteTelemetry.trace('HiveClient.shareMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "shareMic", null);
__decorate([
    DyteTelemetry.trace('HiveClient.pauseMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], HiveNodeClient.prototype, "pauseMic", null);
__decorate([
    DyteTelemetry.trace('HiveClient.pauseWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "pauseWebcam", null);
__decorate([
    DyteTelemetry.trace('HiveClient.resumeMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "resumeMic", null);
__decorate([
    DyteTelemetry.trace('HiveClient.resumeWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "resumeWebcam", null);
__decorate([
    DyteTelemetry.trace('HiveClient.disableWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "disableWebcam", null);
__decorate([
    DyteTelemetry.trace('HiveClient.disableMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "disableMic", null);
__decorate([
    DyteTelemetry.trace('HiveClient.disableScreenShare'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "disableScreenShare", null);
__decorate([
    DyteTelemetry.trace('HiveClient.muteSelf'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "muteSelf", null);
__decorate([
    DyteTelemetry.trace('HiveClient.unmuteSelf'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "unmuteSelf", null);
__decorate([
    DyteTelemetry.trace('HiveClient.resetVideoProducers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack,
        MediaStreamTrack]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "resetVideoProducers", null);
__decorate([
    DyteTelemetry.trace('HiveClient.pinPeer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], HiveNodeClient.prototype, "pinPeer", null);
__decorate([
    DyteTelemetry.trace('HiveClient.init'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HiveNodeClient, "init", null);
