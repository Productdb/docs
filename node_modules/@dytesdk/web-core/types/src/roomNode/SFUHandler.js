var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import EventEmitter from 'events';
import { Device, types as MediaSoup } from '@dyteinternals/mediasoup-client';
type callStats = any; 
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import { PC_PROPRIETARY_CONSTRAINTS, SCREENSHARE_SIMULCAST_ENCODINGS_RTP, } from './RoomNodeConfig';
import { SessionStore } from '../store/SessionStore';
import { SessionEvents } from '../store/SessionEvents';
import DyteTelemetry from '../utils/opentelemetry';
import { getAPIClient } from '../api';
import { FlagsmithFeatureFlags } from '../utils/flags';
import DyteError from '../client/DyteError';
import DyteLogger from '../client/internals/DyteLogger';
import { browserSpecs } from '../browser/BrowserCapabilities';
export var ProducerStatus;
(function (ProducerStatus) {
    ProducerStatus["INITIALIZING"] = "INITIALIZING";
    ProducerStatus["INITIALIZED"] = "INITIALIZED";
    ProducerStatus["NOT_INITIALIZED"] = "NOT_INITIALIZED";
})(ProducerStatus || (ProducerStatus = {}));
export default class SFUHandler extends EventEmitter {
    device;
    sendTransport;
    recvTransport;
    sendTransportIceStateDisconnectTime;
    recvTransportIceStateDisconnectTime;
    producerCreationStatus;
    consumers;
    producers;
    socketClient;
    iceRestartInProgress;
    constructor(socketClient) {
        super();
        this.producers = new Map();
        this.consumers = new Map();
        this.producerCreationStatus = new Map();
        this.iceRestartInProgress = { sendTransport: false, recvTransport: false };
        this.device = new Device();
        this.socketClient = socketClient;
    }
    async setupTransports() {
        const APIClient = getAPIClient();
        const iceServers = await APIClient.getICEServers();
        await this.loadRouter();
        await Promise.all([
            this.createRecvTransport(iceServers),
            this.createSendTransport(iceServers),
        ]);
    }
    async loadRouter() {
        if (this.recvTransport || this.sendTransport) {
            await this.stopAllTransports();
        }
        const routerMessage = await this.socketClient.sendMessage({
            type: 'getRouterRtpCapabilities',
        });
        const routerRtpCapabilities = routerMessage?.payload;
        if (this.device.loaded) {
            this.device = new Device();
        }
        if (routerRtpCapabilities) {
            routerRtpCapabilities.headerExtensions = routerRtpCapabilities.headerExtensions
                .filter((ext) => ext.uri !== 'urn:3gpp:video-orientation');
        }
        return this.device.load({ routerRtpCapabilities });
    }
    getRTPCapabilities() {
        return this.device.rtpCapabilities;
    }
    async createRecvTransport(iceServers) {
        if (!this.socketClient) {
            return;
        }
        const payload = {
            forceTcp: false,
            producing: false,
            consuming: true,
        };
        const transportOptions = (await this.socketClient.sendMessage({
            type: 'createWebRtcTransport',
            payload,
        })).payload;
        DyteLogger.info('recvTransport::initializing_transport');
        this.recvTransport = this.device.createRecvTransport({
            ...transportOptions,
            iceServers,
            proprietaryConstraints: PC_PROPRIETARY_CONSTRAINTS,
        });
        DyteLogger.info('recvTransport::initialized_transport');
        callStats.onSafeInitialization(() => {
            callStats.configureRecvTransport(this.recvTransport);
        });
        this.recvTransport.on('connect', async ({ dtlsParameters }, callback, err) => {
            const message = await this.socketClient.sendMessage({
                type: 'connectWebRtcTransport',
                payload: {
                    transportId: this.recvTransport.id,
                    dtlsParameters,
                },
            });
            if (!message.payload?.error) {
                callback();
                DyteLogger.info('recvTransport::transport_status', {
                    transport: {
                        id: this?.recvTransport?.id,
                        status: 'connected',
                        type: 'recv',
                    },
                });
            }
            else {
                DyteLogger.error('recvTransport::transport_status', {
                    error: message.payload?.error,
                    transport: {
                        id: this?.recvTransport?.id,
                        status: 'failed',
                        type: 'recv',
                    },
                });
                err(new Error('failed'));
            }
        });
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.ENABLE_ICE_STATE_LOGGING)) {
            DyteLogger.info('enabling_ice_state_logging_for_recv_transport');
            let iceRestartOnDisconnectValue;
            this.recvTransport.on('connectionstatechange', async (state) => {
                DyteLogger.info('recvTransport::connection_state_change', {
                    transport: {
                        id: this?.recvTransport?.id,
                        status: state,
                        type: 'recv',
                    },
                });
                switch (state) {
                    case 'failed':
                        SessionStore.emit(SessionEvents.ICE_FAILED, { transport: 'recv' });
                        DyteLogger.warn('recvTransport::ice_state_failed');
                        if (flagsmith.hasFeature(FlagsmithFeatureFlags.ICE_RESTART_ON_FAILED_STATE)) {
                            try {
                                await this.restartIceTillSuccess(this.recvTransport);
                            }
                            catch (error) {
                                DyteLogger.error('recvTransport::ice_restart_failed', {
                                    error,
                                    transport: {
                                        id: this?.recvTransport?.id,
                                        status: 'failed',
                                        type: 'recv',
                                    },
                                });
                            }
                        }
                        break;
                    case 'disconnected':
                        SessionStore.emit(SessionEvents.ICE_DISCONNECTED, { transport: 'recv' });
                        DyteLogger.warn('recvTransport::ice_state_disconnected');
                        if (this.recvTransportIceStateDisconnectTime) {
                            DyteLogger.warn('recvTransport::ice_state_disconnected_again', {
                                transport: {
                                    id: this?.recvTransport?.id,
                                    status: 'disconnected',
                                    type: 'recv',
                                    lastDisconnectedTime: this
                                        .recvTransportIceStateDisconnectTime?.toISOString(),
                                    lastDisconnectedTimeOffset: this
                                        .recvTransportIceStateDisconnectTime?.getTimezoneOffset(),
                                    durationPassed: (new Date().getTime()
                                        - this.recvTransportIceStateDisconnectTime.getTime()),
                                },
                            });
                        }
                        this.recvTransportIceStateDisconnectTime = new Date();
                        try {
                            iceRestartOnDisconnectValue = flagsmith.getValue(FlagsmithFeatureFlags.ICE_RESTART_ON_DISCONNECTED_STATE);
                            if (typeof iceRestartOnDisconnectValue !== 'number')
                                iceRestartOnDisconnectValue = undefined;
                        }
                        catch (e) {
                            iceRestartOnDisconnectValue = undefined;
                        }
                        if (iceRestartOnDisconnectValue) {
                            setTimeout(async () => {
                                if (this.recvTransportIceStateDisconnectTime === undefined) {
                                    return;
                                }
                                SessionStore.emit(SessionEvents.ICE_RECONNECTING, { transport: 'recv' });
                                DyteLogger.info('recvTransport::attempting_ice_restart', {
                                    transport: {
                                        id: this?.recvTransport?.id,
                                        type: 'recv',
                                        status: 'reconnecting',
                                        lastDisconnectedTime: this
                                            .recvTransportIceStateDisconnectTime?.toISOString(),
                                        lastDisconnectedTimeOffset: this
                                            .recvTransportIceStateDisconnectTime
                                            ?.getTimezoneOffset(),
                                    },
                                    iceRestart: {
                                        isSendTransport: this?.iceRestartInProgress?.sendTransport,
                                        isRecvTransport: this?.iceRestartInProgress?.recvTransport,
                                    },
                                });
                                try {
                                    await this.restartIceTillSuccess(this.recvTransport);
                                }
                                catch (error) {
                                    DyteLogger.info('SFUHandler.disconnected.restartIceFailed', {
                                        error,
                                        iceRestart: {
                                            status: 'failed',
                                            isRecvTransport: true,
                                        },
                                    });
                                }
                            }, iceRestartOnDisconnectValue);
                        }
                        break;
                    case 'connected':
                        SessionStore.emit(SessionEvents.ICE_CONNECTED, { transport: 'recv' });
                        DyteLogger.info('recvTransport::ice_state_connected', {
                            transport: {
                                id: this?.recvTransport?.id,
                                type: 'recv',
                                status: 'connected',
                                lastDisconnectedTime: this
                                    .recvTransportIceStateDisconnectTime?.toISOString(),
                                lastDisconnectedTimeOffset: this
                                    .recvTransportIceStateDisconnectTime?.getTimezoneOffset(),
                                durationPassed: (this.recvTransportIceStateDisconnectTime
                                    ? (new Date().getTime()
                                        - this.recvTransportIceStateDisconnectTime.getTime())
                                    : null),
                            },
                        });
                        this.recvTransportIceStateDisconnectTime = undefined;
                        break;
                    default:
                }
            });
        }
        this.recvTransport.observer.on('close', () => {
            this.recvTransport = undefined;
            DyteLogger.warn('recvTransport_closed');
        });
    }
    async createSendTransport(iceServers) {
        const payload = {
            forceTcp: false,
            producing: true,
            consuming: false,
        };
        const transportOptions = (await this.socketClient.sendMessage({
            type: 'createWebRtcTransport',
            payload,
        })).payload;
        DyteLogger.info('sendTransport::initializing_transport');
        this.sendTransport = this.device.createSendTransport({
            ...transportOptions,
            iceServers,
            proprietaryConstraints: PC_PROPRIETARY_CONSTRAINTS,
        });
        DyteLogger.info('sendTransport::initialized_transport');
        callStats.onSafeInitialization(() => {
            callStats.configureSendTransport(this.sendTransport);
        });
        this.sendTransport.on('connect', async ({ dtlsParameters }, callback, err) => {
            const message = await this.socketClient.sendMessage({
                type: 'connectWebRtcTransport',
                payload: {
                    transportId: this.sendTransport?.id,
                    dtlsParameters,
                },
            });
            if (!message.payload?.error) {
                DyteLogger.info('sendTransport::transport_status', {
                    transport: {
                        id: this?.sendTransport?.id,
                        status: 'connected',
                        type: 'send',
                    },
                });
                callback();
            }
            else {
                DyteLogger.error('sendTransport::transport_status', {
                    transport: {
                        id: this?.sendTransport?.id,
                        status: 'failed',
                        type: 'send',
                    },
                });
                err(new Error('failed'));
            }
        });
        this.sendTransport.on('produce', async ({ kind, rtpParameters, appData, }, callback, err) => {
            const message = await this.socketClient.sendMessage({
                type: 'produce',
                payload: {
                    transportId: this.sendTransport?.id,
                    kind,
                    rtpParameters,
                    appData,
                },
            });
            if (!message.payload?.error) {
                DyteLogger.info('sendTransport::producer_status::producing', {
                    producer: {
                        kind,
                        appData: appData,
                        status: 'producing',
                        id: message?.payload?.id,
                    },
                });
                callback({ id: message.payload?.id });
            }
            else {
                DyteLogger.info('sendTransport::producer_status::failed', {
                    producer: {
                        kind,
                        appData: appData,
                        status: 'failed',
                        id: message?.payload?.id,
                    },
                });
                err(message.payload?.error);
            }
        });
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.ENABLE_ICE_STATE_LOGGING)) {
            DyteLogger.info('Enabling ice state logging for send transport');
            let iceRestartOnDisconnectValue;
            this.sendTransport.on('connectionstatechange', async (state) => {
                DyteLogger.info('sendTransport::connection_state_change', {
                    transport: {
                        id: this?.sendTransport?.id,
                        status: state,
                        type: 'send',
                    },
                });
                switch (state) {
                    case 'failed':
                        SessionStore.emit(SessionEvents.ICE_FAILED, { transport: 'send' });
                        DyteLogger.warn('sendTransport::ice_state_failed');
                        if (flagsmith.hasFeature(FlagsmithFeatureFlags.ICE_RESTART_ON_FAILED_STATE)) {
                            try {
                                await this.restartIceTillSuccess(this.sendTransport);
                            }
                            catch (error) {
                                DyteLogger.error('sendTransport::ice_restart_failed', {
                                    error,
                                });
                            }
                        }
                        break;
                    case 'disconnected':
                        SessionStore.emit(SessionEvents.ICE_DISCONNECTED, { transport: 'send' });
                        DyteLogger.warn('sendTransport::ice_state_disconnected');
                        if (this.sendTransportIceStateDisconnectTime) {
                            DyteLogger.warn('sendTransport::ice_state_disconnected_again', {
                                transport: {
                                    id: this?.sendTransport?.id,
                                    status: 'disconnected',
                                    lastDisconnectedTime: this.sendTransportIceStateDisconnectTime.toLocaleTimeString(),
                                    durationPassed: (new Date().getTime() - this.sendTransportIceStateDisconnectTime.getTime()),
                                    type: 'send',
                                },
                            });
                        }
                        this.sendTransportIceStateDisconnectTime = new Date();
                        try {
                            iceRestartOnDisconnectValue = flagsmith.getValue(FlagsmithFeatureFlags.ICE_RESTART_ON_DISCONNECTED_STATE);
                            if (typeof iceRestartOnDisconnectValue !== 'number')
                                iceRestartOnDisconnectValue = undefined;
                        }
                        catch (e) {
                            iceRestartOnDisconnectValue = undefined;
                        }
                        if (iceRestartOnDisconnectValue) {
                            setTimeout(async () => {
                                if (this.sendTransportIceStateDisconnectTime === undefined) {
                                    return;
                                }
                                SessionStore.emit(SessionEvents.ICE_RECONNECTING, { transport: 'send' });
                                DyteLogger.info('sendTransport::attempting_ice_restart', {
                                    transport: {
                                        id: this?.sendTransport?.id,
                                        status: 'reconnecting',
                                        type: 'send',
                                        lastDisconnectedTime: this.sendTransportIceStateDisconnectTime?.toISOString(),
                                        lastDisconnectedTimeOffset: this
                                            .sendTransportIceStateDisconnectTime
                                            ?.getTimezoneOffset(),
                                    },
                                    iceRestart: {
                                        status: 'connecting',
                                    },
                                });
                                try {
                                    await this.restartIceTillSuccess(this.sendTransport);
                                }
                                catch (error) {
                                    DyteLogger.info('SFUHandler.disconnected.restartIceFailed', {
                                        error,
                                        transport: {
                                            id: this?.sendTransport?.id,
                                            type: 'send',
                                            status: 'failed',
                                        },
                                    });
                                }
                            }, iceRestartOnDisconnectValue);
                        }
                        break;
                    case 'connected':
                        SessionStore.emit(SessionEvents.ICE_CONNECTED, { transport: 'send' });
                        DyteLogger.info('sendTransport::ice_state_connected', {
                            transport: {
                                id: this?.sendTransport?.id,
                                type: 'send',
                                status: 'connected',
                                lastDisconnectedTime: this
                                    .sendTransportIceStateDisconnectTime
                                    ?.toLocaleTimeString(),
                                durationPassed: this.sendTransportIceStateDisconnectTime
                                    ? (new Date().getTime() - this.sendTransportIceStateDisconnectTime.getTime())
                                    : null,
                            },
                        });
                        this.sendTransportIceStateDisconnectTime = undefined;
                        break;
                    default:
                }
            });
        }
        this.sendTransport.observer.on('close', () => {
            this.sendTransport = undefined;
            DyteLogger.warn('sendTransport_closed');
        });
    }
    async restartIce(transport) {
        const { direction } = transport;
        const iceRestartInProgress = direction === 'recv' ? this.iceRestartInProgress.recvTransport : this.iceRestartInProgress.sendTransport;
        if (iceRestartInProgress)
            return;
        if (direction === 'recv') {
            this.iceRestartInProgress.recvTransport = true;
        }
        else {
            this.iceRestartInProgress.sendTransport = true;
        }
        try {
            const iceParameters = (await this.socketClient.sendMessage({
                type: 'restartIce',
                payload: {
                    transportId: transport.id,
                },
            })).payload;
            await transport.restartIce(iceParameters);
        }
        catch (error) {
            DyteLogger.error('SFUHandler.restartIce.Failed', {
                error,
                iceRestart: {
                    status: 'failed',
                },
                transport: {
                    id: transport?.id,
                    status: 'failed',
                    type: direction,
                },
            });
        }
        if (direction === 'recv') {
            this.iceRestartInProgress.recvTransport = false;
        }
        else {
            this.iceRestartInProgress.sendTransport = false;
        }
    }
    async createConsumer(request) {
        if (this.recvTransport === undefined || this.recvTransport.closed) {
            return;
        }
        const { peerId, producerId, id, kind, rtpParameters, appData, remotelyPaused, } = request;
        DyteLogger.info('createConsumer::initializing_consumer', {
            consumer: {
                id,
                peerId,
                kind,
                appData,
                remotelyPaused,
            },
        });
        const consumer = await this.recvTransport.consume({
            id,
            producerId,
            kind,
            rtpParameters,
            appData: { ...appData, peerId },
        });
        DyteLogger.info('createConsumer::initialized_consumer', {
            consumer: {
                id,
                peerId,
                kind,
                appData,
                remotelyPaused,
            },
        });
        const extendedConsumer = consumer;
        extendedConsumer.peerId = peerId;
        extendedConsumer.remotelyPaused = remotelyPaused;
        extendedConsumer.score = 10;
        this.consumers.set(consumer.id, extendedConsumer);
    }
    async closeConsumer(request) {
        const { id } = request;
        const consumer = this.consumers.get(id);
        if (!consumer)
            return;
        DyteLogger.info('SFUHandler::close_consumer', {
            consumer,
        });
        consumer.close();
        this.consumers.delete(id);
    }
    async cleanupConsumers() {
        this.consumers?.forEach((consumer) => {
            SessionStore.emit(SessionEvents.CONSUMER_CLOSED, { id: consumer.id });
            this.closeConsumer({ id: consumer.id });
        });
    }
    async pauseConsumer(request) {
        const { id } = request;
        const consumer = this.consumers.get(id);
        if (!consumer)
            return;
        consumer.pause();
    }
    async resumeConsumer(request) {
        const { id } = request;
        const consumer = this.consumers.get(id);
        if (!consumer)
            return;
        consumer.resume();
    }
    async createProducer(producerType, producerOptions, onDisconnect) {
        if (this.sendTransport === undefined || this.sendTransport.closed) {
            return;
        }
        DyteLogger.info('createProducer::initializing_producer', {
            producer: {
                id: 'TO_BE_CREATED',
                kind: producerType,
                status: 'initializing',
                appData: producerOptions?.appData,
            },
        });
        if (this.producerCreationStatus.get(producerType)
            && (this.producerCreationStatus.get(producerType) === "INITIALIZING")) {
            DyteLogger.info('createProducer::producer getting initializing', {
                producer: {
                    id: 'GETTING_CREATED',
                    status: 'initializing',
                    kind: producerType,
                    appData: producerOptions?.appData,
                },
            });
            return;
        }
        this.producerCreationStatus.set(producerType, "INITIALIZING");
        const producer = await Promise.race([
            this.sendTransport.produce(producerOptions),
            new Promise((resolve) => setTimeout(() => resolve(undefined), 6000)),
        ]);
        if (!producer) {
            DyteLogger.error('createProducer::transport_initialization_timed_out', {
                producer: {
                    id: 'FAILED_TO_CREATE',
                    kind: producerType,
                    status: 'failed',
                    appData: producerOptions?.appData,
                },
            });
            this.producerCreationStatus.set(producerType, "NOT_INITIALIZED");
            throw new DyteError(`Producer Creation timed out! ${producerType}`);
        }
        this.producerCreationStatus.set(producerType, "INITIALIZED");
        DyteLogger.info('createProducer::initialized_producer', {
            producer: {
                id: producer?.id,
                kind: producerType,
                status: 'UNKNOWN',
                appData: producerOptions?.appData,
            },
        });
        producer.on('transportclose', () => {
            DyteLogger.info('producer::transportclose', {
                producer: {
                    id: producer?.id,
                    kind: producerType,
                    status: 'UNKNOWN',
                    appData: producerOptions?.appData,
                },
            });
            this.producerCreationStatus.set(producerType, "NOT_INITIALIZED");
            this.producers.delete(producerType);
        });
        producer.on('trackended', () => {
            DyteLogger.info('producer::trackended', {
                producer: {
                    id: producer?.id,
                    kind: producerType,
                    status: 'UNKNOWN',
                    appData: producerOptions?.appData,
                },
            });
            if (!["mic", "webcam"].includes(producerType)) {
                onDisconnect();
            }
        });
        const extendedProducer = producer;
        extendedProducer.score = 10;
        this.producers.set(producerType, extendedProducer);
        await this.reconfigureWebcamLayers();
        await this.reconfigureSafariScreenshareLayers();
    }
    async removeProducer(producerType, stopTrack = true) {
        const producer = this.producers.get(producerType);
        if (!producer || producer.closed) {
            return;
        }
        DyteLogger.info('SFUHandler::remove_producer', {
            producer: {
                id: producer?.id,
                kind: producerType,
                status: 'UNKNOWN',
                appData: producer?.appData,
            },
            debuggingHint: `stopTrack was ${stopTrack}`,
        });
        if (stopTrack) {
            producer.track.stop();
        }
        producer.close();
        await this.socketClient.sendMessage({ type: 'closeProducer', payload: { producerId: producer.id } });
        this.producerCreationStatus.set(producerType, "NOT_INITIALIZED");
        this.producers.delete(producerType);
        await this.reconfigureWebcamLayers();
    }
    stopAllProducers() {
        Array.from(this.producers.keys()).forEach((producerType) => {
            this.removeProducer(producerType);
        });
    }
    async stopAllTransports() {
        if (this.sendTransport) {
            try {
                this.sendTransport.close();
            }
            catch (error) {
                DyteLogger.error('stopAllTransports', { error });
            }
            this.sendTransport = undefined;
        }
        if (this.recvTransport) {
            try {
                this.recvTransport.close();
            }
            catch (error) {
                DyteLogger.error('SFUHandler::stopAllTransports::error', error);
            }
            this.recvTransport = undefined;
        }
    }
    async reconfigureWebcamLayers() {
        if (!flagsmith.hasFeature(FlagsmithFeatureFlags.DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE)) {
            return;
        }
        const webcamProducer = this.producers.get("webcam");
        if (!webcamProducer) {
            return;
        }
        await webcamProducer.setMaxSpatialLayer(this.producers.get("screenshare_video") ? 0 : 1);
    }
    async reconfigureSafariScreenshareLayers() {
        if (!flagsmith.hasFeature(FlagsmithFeatureFlags.SCREENSHARE_SIMULCAST)
            || !browserSpecs.isSafari()) {
            return;
        }
        const screenshareVideoProducer = this.producers.get("screenshare_video");
        if (!screenshareVideoProducer) {
            return;
        }
        const params = screenshareVideoProducer.rtpSender.getParameters();
        params.encodings = SCREENSHARE_SIMULCAST_ENCODINGS_RTP;
        screenshareVideoProducer.rtpSender.setParameters(params);
    }
    async restartIceTillSuccess(transport, maxAttempts = 3) {
        let success = false;
        let currentAttempt = 0;
        while (!success && currentAttempt < maxAttempts) {
            try {
                DyteLogger.info('SFUHandler.restartIceTillSuccess.AttemptRestart', {
                    iceRestart: {
                        currentAttempt,
                        isSendTransport: transport.direction === 'send',
                        isRecvTransport: transport.direction === 'recv',
                    },
                });
                await this.restartIce(transport);
                success = true;
            }
            catch {
                currentAttempt += 1;
            }
        }
        if (!success)
            throw new DyteError('Failed to restart Ice');
    }
}
__decorate([
    DyteTelemetry.trace('SFUHandler.setupTransports'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "setupTransports", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.loadRouter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "loadRouter", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.createRecvTransport'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "createRecvTransport", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.createSendTransport'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "createSendTransport", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.restartIce'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaSoup.Transport]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "restartIce", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.createConsumer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "createConsumer", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.closeConsumer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "closeConsumer", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.cleanupConsumers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "cleanupConsumers", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.pauseConsumer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "pauseConsumer", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.resumeConsumer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "resumeConsumer", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.createProducer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Function]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "createProducer", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.removeProducer'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "removeProducer", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.stopAllProducers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SFUHandler.prototype, "stopAllProducers", null);
__decorate([
    DyteTelemetry.trace('SFUHandler.stopAllTransports'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SFUHandler.prototype, "stopAllTransports", null);
