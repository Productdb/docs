var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
type callStats = any; 
import { browserSpecs } from '../browser/BrowserCapabilities';
import SocketClient from '../sockets/SocketClient';
import { SocketEvents } from '../sockets/SocketEvents';
import { WEBCAM_SIMULCAST_ENCODINGS_VGA, WEBCAM_KSVC_ENCODINGS, SCREENSHARE_SIMULCAST_ENCODINGS, } from './RoomNodeConfig';
import { SessionStore } from '../store/SessionStore';
import { SessionEvents } from '../store/SessionEvents';
import SFUHandler from './SFUHandler';
import { RemoteRequestType } from '../client/DyteRemoteRequest';
import { getAPIClient } from '../api';
import { FlagsmithFeatureFlags } from '../utils/flags';
import DyteTelemetry from '../utils/opentelemetry';
import RoomNodeClient from './BaseRoomNodeClient';
import constants from '../utils/constants';
import { WebinarAcceptRequestType } from '../client/DyteWebinarRequest';
import DyteLogger from '../client/internals/DyteLogger';
export default class MediasoupRoomNodeClient extends RoomNodeClient {
    #socketClient;
    isV2AuthToken;
    #sfuHandler;
    legacyMode;
    roomNodeUrl;
    peerDisplayName;
    constructor(options) {
        super();
        const { roomName, roomNodeUrl, peerId, authToken, legacyMode, socketClient, meetingTitle, } = options;
        this.roomName = roomName;
        this.roomNodeUrl = roomNodeUrl;
        this.peerId = peerId;
        this.authToken = authToken;
        this.legacyMode = legacyMode;
        this.#socketClient = socketClient;
        this.roomJoined = false;
        this.meetingTitle = meetingTitle;
        this.isV2AuthToken = constants.isV2AuthToken;
        this.#sfuHandler = new SFUHandler(socketClient);
        callStats.legacySwitch(legacyMode);
    }
    static async init(options) {
        const { legacyMode = true, roomName, peerId, authToken, meetingTitle, } = options;
        let roomNodeClient;
        const roomNodeUrl = `${options.roomNodeUrl}?roomURL=${roomName}&peerId=${peerId}&authToken=${authToken}&version=0.5.0`;
        const socketClient = new SocketClient({
            callbackHandler: async (message) => {
                await roomNodeClient.handleSocketCallbacks(message);
            },
        });
        socketClient.on(SocketEvents.SOCKET_MESSAGE, async (message, callBack) => {
            await roomNodeClient.handleSockets(message, callBack);
        });
        socketClient.connect(roomNodeUrl);
        roomNodeClient = new MediasoupRoomNodeClient({
            legacyMode,
            authToken,
            peerId,
            roomName,
            roomNodeUrl,
            socketClient,
            meetingTitle,
        });
        socketClient.on(SocketEvents.SOCKET_DISCONNECTED, (event) => {
            roomNodeClient.isDisconnected = true;
            roomNodeClient.sfuHandler?.cleanupConsumers();
            SessionStore.emit(SessionEvents.ROOM_NODE_DISCONNECTED, event);
            roomNodeClient.roomJoined = false;
            DyteLogger.info('ROOM_NODE_DISCONNECTED');
        });
        socketClient.on(SocketEvents.SOCKET_CONNECTED, async (event) => {
            SessionStore.emit(SessionEvents.ROOM_NODE_CONNECTED, event);
            if (roomNodeClient.isDisconnected) {
            }
            roomNodeClient.isDisconnected = false;
            DyteLogger.info('ROOM_NODE_CONNECTED');
        });
        socketClient.on(SocketEvents.SOCKET_CONNECTION_ERROR, async ({ err }) => {
            roomNodeClient.isDisconnected = true;
            roomNodeClient.sfuHandler?.cleanupConsumers();
            SessionStore.emit(SessionEvents.ROOM_NODE_CONNECTION_ERROR, err);
            roomNodeClient.roomJoined = false;
        });
        return roomNodeClient;
    }
    get sfuHandler() {
        return this.#sfuHandler;
    }
    reconnect() {
        this.#socketClient.reconnect();
    }
    async setupTransports() {
        await this.sfuHandler.setupTransports();
    }
    async handleSocketCallbacks(message) {
        switch (message.type) {
            case SessionEvents.NEW_CONSUMER:
                return this.sfuHandler.createConsumer(message.payload);
            default:
                return null;
        }
    }
    async handleSockets(message, callBack) {
        if (!message) {
            return;
        }
        if (!DyteTelemetry.logExclusionList.includes(message?.type)
            || flagsmith.hasFeature(FlagsmithFeatureFlags.BYPASS_LOG_EXCLUSION_LIST)) {
            DyteLogger.info(`RoomNodeClient::handleSockets::${message?.type}`);
        }
        switch (message.type) {
            case SessionEvents.CONSUMER_CLOSED:
                this.sfuHandler.closeConsumer(message.payload);
                break;
            case SessionEvents.CONSUMER_PAUSED:
                this.sfuHandler.pauseConsumer(message.payload);
                break;
            case SessionEvents.CONSUMER_RESUMED:
                this.sfuHandler.resumeConsumer(message.payload);
                break;
            case SessionEvents.CONSUMER_SCORE:
                this.handleConsumerScore(message.payload);
                break;
            case SessionEvents.PRODUCER_SCORE:
                this.handleProducerScore(message.payload);
                break;
            case SessionEvents.PRODUCER_CLOSED:
                this.handleProducerClosed(message.payload);
                break;
            default:
                break;
        }
        if (typeof callBack === 'function') {
            callBack();
        }
    }
    async joinRoom(displayName, audioMuted, roomUUID, roomTitle, currentUserSharedMediaStates = {}) {
        this.peerDisplayName = displayName;
        this.roomUUID = roomUUID;
        const response = await this.#socketClient.sendMessage({
            type: 'joinRoom',
            payload: {
                device: browserSpecs.getDeviceInfo(),
                displayName,
                rtpCapabilities: this.sfuHandler.getRTPCapabilities(),
                isLegacy: this.legacyMode,
                audioMuted,
            },
        });
        if (response.payload?.waitlisted) {
            SessionStore.emit(SessionEvents.WAITLISTED);
            return { roomJoined: false };
        }
        response.payload?.waitlistedPeers?.forEach((data) => {
            SessionStore.emit(SessionEvents.WAITLIST_PEER_ADDED, data);
        });
        this.legacyMode = response.payload.legacyMode || this.legacyMode;
        if (roomTitle && roomTitle !== '') {
            await this.changeRoomDisplayTitle(roomTitle);
        }
        this.maxPreferredStreams = response.payload.maxPreferredStreams;
        this.roomJoined = true;
        const APIClient = getAPIClient();
        DyteLogger.info('RoomNodeClient::joinRoom::pre emitasync room_joined');
        try {
            await SessionStore.emitAsync(SessionEvents.ROOM_JOINED, response.payload);
        }
        catch (error) {
            DyteLogger.error('RoomNodeClient::joinRoom::emitAsync', { error });
        }
        DyteLogger.info('RoomNodeClient::joinRoom::post emitasync room_joined');
        SessionStore.emit(SessionEvents.SELF_ROOM_JOINED);
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.INTERNAL_CALL_STATS)
            && navigator.product !== 'ReactNative') {
            setTimeout(async () => {
                const user = await APIClient.getUserDetails();
                const peerData = {
                    userId: constants.isV2AuthToken
                        ? user.participant.id
                        : user.id,
                    peerId: this.peerId,
                    displayName,
                    roomUUID: this.roomUUID,
                    roomViewType: 'groupCall',
                    roomName: this.roomName,
                    deviceInfo: {
                        ...browserSpecs.getDeviceInfo(),
                        userAgent: navigator.userAgent,
                        memory: navigator.deviceMemory,
                        cpus: navigator.hardwareConcurrency,
                    },
                    metaData: {},
                    permissions: {},
                };
                callStats.roomJoined(peerData);
                if (currentUserSharedMediaStates?.audio) {
                    callStats.audioOn();
                }
                else {
                    callStats.audioOff();
                }
                if (currentUserSharedMediaStates?.video) {
                    callStats.videoOn();
                }
                else {
                    callStats.videoOff();
                }
            });
        }
        return { roomJoined: true };
    }
    async leaveRoom() {
        this.sfuHandler.stopAllProducers();
        await this.sfuHandler.stopAllTransports();
        this.#socketClient.disconnect();
        callStats.callEnded();
        DyteTelemetry.destruct();
    }
    handleProducerClosed({ id }) {
        this.sfuHandler.producers.forEach((producer, type) => {
            if (producer.id === id) {
                this.sfuHandler.removeProducer(type);
            }
        });
    }
    getConsumers() {
        return this.sfuHandler.consumers;
    }
    static getComputedScore(scores) {
        let s = 0;
        try {
            if (Array.isArray(scores)) {
                if (scores.length === 1) {
                    s = scores[0].score;
                }
                else {
                    const allScores = scores.map(({ score }) => score ?? 10).filter((i) => i > 0);
                    s = (allScores.reduce((a, b) => a + b, 0) / scores.length) ?? 10;
                }
            }
            else {
                s = scores?.score ?? 10;
            }
        }
        catch (err) {
            s = scores?.score ?? 10;
        }
        return s;
    }
    handleConsumerScore({ id, score }) {
        const consumer = this.#sfuHandler.consumers.get(id);
        if (!consumer)
            return;
        consumer.score = (score
            && score.producerScore !== undefined
            && score.producerScore >= 0)
            ? score.producerScore
            : (score?.score ?? 10);
        SessionStore.emit(SessionEvents.CONSUMER_SCORE_UPDATE, {
            id: consumer.id,
            kind: consumer.kind,
            peerId: consumer.peerId,
            score: consumer.score,
        });
    }
    handleProducerScore({ id, score }) {
        const producer = [...this.#sfuHandler.producers.values()]
            .find((p) => p.id === id);
        if (!producer) {
            DyteLogger.error(`RoomNodeClient::producer_not_found. ProducerId: ${id}`);
            return;
        }
        if (!producer)
            return;
        const newScore = MediasoupRoomNodeClient.getComputedScore(score);
        if (newScore !== undefined && newScore !== producer.score) {
            producer.score = newScore;
            SessionStore.emit(SessionEvents.PRODUCER_SCORE_UPDATE, {
                id: producer.id,
                kind: producer.kind,
                appData: producer.appData,
                score: producer.score,
            });
        }
    }
    async shareWebcam(videoTrack) {
        if (videoTrack === undefined) {
            return;
        }
        if (this.sfuHandler.producers.has("webcam")) {
            const webcamProducer = this.sfuHandler.producers.get("webcam");
            if (!webcamProducer.closed) {
                await webcamProducer.replaceTrack({ track: videoTrack });
                await this.resumeWebcam();
                return;
            }
            await this.sfuHandler.removeProducer("webcam", false);
        }
        let simulcast = WEBCAM_SIMULCAST_ENCODINGS_VGA;
        const vp9Codec = this.sfuHandler.getRTPCapabilities().codecs
            .find((c) => c.mimeType.toLowerCase() === 'video/vp9') || undefined;
        const vp8Codec = this.sfuHandler.getRTPCapabilities().codecs
            .find((c) => c.mimeType.toLowerCase() === 'video/vp8') || undefined;
        const simulcastOverride = flagsmith
            .getValue(FlagsmithFeatureFlags.OVERRIDE_WEBCAM_SIMULCAST);
        if (vp9Codec && !this.legacyMode) {
            simulcast = WEBCAM_KSVC_ENCODINGS;
        }
        else if (simulcastOverride !== undefined) {
            try {
                simulcast = JSON.parse(simulcastOverride);
            }
            catch (e) {
                DyteLogger.error('Failed to parse flagsmith simulcast');
            }
        }
        const getCodec = () => (this.legacyMode ? vp8Codec : vp9Codec);
        const producerOptions = {
            track: videoTrack,
            encodings: flagsmith.hasFeature(FlagsmithFeatureFlags.DISABLE_WEBCAM_SIMULCAST)
                ? undefined : simulcast,
            codecOptions: {
                videoGoogleStartBitrate: 1000,
            },
            codec: getCodec(),
            appData: {
                screenShare: false,
            },
            stopTracks: false,
        };
        const onDisconnect = () => {
            this.disableWebcam();
        };
        await this.sfuHandler.createProducer("webcam", producerOptions, onDisconnect);
    }
    async shareScreen(tracks) {
        const { video: videoTrack, audio: audioTrack } = tracks;
        if (videoTrack === undefined) {
            return;
        }
        let encodings;
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.SCREENSHARE_SIMULCAST)) {
            encodings = SCREENSHARE_SIMULCAST_ENCODINGS;
        }
        const producerOptions = {
            track: videoTrack,
            appData: {
                screenShare: true,
                supportsRemoteControl: browserSpecs.isElectron(),
            },
            encodings,
            stopTracks: false,
        };
        let onDisconnect = () => {
            this.disableScreenShare();
        };
        callStats.screenShareRequested();
        await this.sfuHandler
            .createProducer("screenshare_video", producerOptions, onDisconnect);
        const codecOptions = {
            opusDtx: false,
            opusStereo: false,
            opusFec: true,
            forceGoogConference: false,
        };
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.SCREENSHARE_FORCE_GOOG_CONFERENCE)) {
            codecOptions.forceGoogConference = true;
        }
        if (audioTrack) {
            const audioProducerOptions = {
                track: audioTrack,
                codecOptions,
                appData: {
                    screenShare: true,
                    supportsRemoteControl: browserSpecs.isElectron(),
                },
                stopTracks: false,
            };
            onDisconnect = () => {
            };
            await this.sfuHandler.createProducer("screenshare_audio", audioProducerOptions, onDisconnect);
        }
        callStats.screenShareStart(this.sfuHandler.producers
            .get("screenshare_video")?.rtpParameters.encodings[0]?.ssrc);
    }
    async shareMic(audioTrack) {
        if (audioTrack === undefined) {
            return;
        }
        if (this.sfuHandler.producers.has("mic")) {
            const micProducer = this.sfuHandler.producers.get("mic");
            if (!micProducer.closed) {
                await micProducer.replaceTrack({ track: audioTrack });
                await this.resumeMic();
                return;
            }
            await this.sfuHandler.removeProducer("mic", false);
        }
        const producerOptions = {
            track: audioTrack,
            codecOptions: {
                opusDtx: false,
                opusStereo: false,
                opusFec: true,
                opusMaxAverageBitrate: 16000,
            },
            stopTracks: false,
        };
        const onDisconnect = () => {
            this.disableMic();
        };
        await this.sfuHandler.createProducer("mic", producerOptions, onDisconnect);
    }
    pauseMic() {
        const micProducer = this.sfuHandler.producers.get("mic");
        if (!micProducer) {
            DyteLogger.error('pauseMic::could_not_find_mic_producer');
            return;
        }
        micProducer.pause();
        this.#socketClient.sendMessage({
            type: 'pauseProducer',
            payload: { producerId: micProducer.id },
        });
    }
    async pauseWebcam() {
        const webcamProducer = this.sfuHandler.producers.get("webcam");
        if (!webcamProducer) {
            DyteLogger.error('pauseWebcam::could_not_find_webcam_producer');
            return;
        }
        webcamProducer.pause();
        await this.#socketClient.sendMessage({
            type: 'pauseProducer',
            payload: { producerId: webcamProducer.id },
        });
    }
    async resumeMic() {
        const micProducer = this.sfuHandler.producers.get("mic");
        if (!micProducer) {
            DyteLogger.error('resumeMic::could_not_find_mic_producer');
            return;
        }
        micProducer.resume();
        await this.#socketClient.sendMessage({
            type: 'resumeProducer',
            payload: { producerId: micProducer.id },
        });
    }
    async resumeWebcam() {
        const webcamProducer = this.sfuHandler.producers.get("webcam");
        if (!webcamProducer) {
            DyteLogger.error('resumeWebcam::could_not_find_webcam_producer');
            return;
        }
        webcamProducer.resume();
        await this.#socketClient.sendMessage({
            type: 'resumeProducer',
            payload: { producerId: webcamProducer.id },
        });
    }
    async disableWebcam() {
        await this.sfuHandler.removeProducer("webcam");
    }
    async disableMic() {
        await this.sfuHandler.removeProducer("mic");
    }
    async disableScreenShare() {
        DyteLogger.info('screen_sharing_stopped');
        callStats.screenShareStop(this.sfuHandler.producers
            .get("screenshare_video")?.rtpParameters.encodings[0]?.ssrc);
        await this.sfuHandler.removeProducer("screenshare_video");
        await this.sfuHandler.removeProducer("screenshare_audio");
    }
    async resetVideoProducers(videoTrack, screenShareTrack) {
        if (videoTrack) {
            await this.sfuHandler.removeProducer("webcam", false);
            this.shareWebcam(videoTrack);
        }
        if (screenShareTrack) {
            await this.sfuHandler.removeProducer("screenshare_video", false);
            this.shareScreen({ video: screenShareTrack });
        }
    }
    async getRoomState() {
        return this.#socketClient.sendMessage({ type: 'getRoomState' });
    }
    async changeRoomDisplayTitle(displayTitle) {
        await this.#socketClient.sendMessage({
            type: 'changeDisplayTitle',
            payload: {
                displayTitle,
            },
        });
    }
    async sendMessage(message) {
        return this.#socketClient.sendMessage(message);
    }
    async broadcastMessage(type, messagePayload) {
        const payload = {
            payload: messagePayload,
            type,
        };
        return this.#socketClient.sendMessage({ type: 'roomMessage', payload });
    }
    async sendChatMessage(message) {
        await this.#socketClient.sendMessage({ type: 'chatMessage', payload: message });
    }
    async getChatMessages() {
        return this.#socketClient.sendMessage({ type: 'getChatMessages' });
    }
    async pinChatMessage(payload) {
        return this.#socketClient.sendMessage({ type: 'pinChatMessage', payload });
    }
    async unpinChatMessage(payload) {
        return this.#socketClient.sendMessage({ type: 'unpinChatMessage', payload });
    }
    async getPolls() {
        return this.#socketClient.sendMessage({ type: 'getPolls' });
    }
    async newPoll(poll) {
        await this.#socketClient.sendMessage({ type: 'newPoll', payload: poll });
    }
    async votePoll(poll) {
        await this.#socketClient.sendMessage({ type: 'votePoll', payload: poll });
    }
    async acceptWaitingRequest(peerId) {
        await this.#socketClient.sendMessage({ type: 'acceptWaitingRequest', payload: { id: peerId } });
    }
    async rejectWaitingRequest(peerId) {
        await this.#socketClient.sendMessage({ type: 'rejectWaitingRequest', payload: { id: peerId } });
    }
    async muteAll(allowUnMute) {
        await this.#socketClient.sendMessage({ type: 'muteAllNew', payload: { allowUnMute } });
    }
    async muteAllVideo() {
        await this.#socketClient.sendMessage({ type: 'muteAllVideo' });
    }
    async pinPeer(peerId) {
        return this.#socketClient.sendMessage({ type: 'pinPeer', payload: { id: peerId } });
    }
    async unpinPeer(peerId) {
        return this.#socketClient.sendMessage({ type: 'unpinPeer', payload: { id: peerId } });
    }
    async disableAudio(peerId) {
        await this.#socketClient.sendMessage({ type: 'disableAudioPeerNew', payload: { id: peerId } });
    }
    async disableVideo(peerId) {
        await this.#socketClient.sendMessage({ type: 'disableVideoPeer', payload: { id: peerId } });
    }
    async kickAll() {
        await this.#socketClient.sendMessage({ type: 'kickAll' });
    }
    async kick(peerId) {
        await this.#socketClient.sendMessage({ type: 'kick', payload: { id: peerId } });
    }
    async getPage(pageNum) {
        return this.#socketClient.sendMessage({ type: 'getPage', payload: { pageNum } });
    }
    async muteSelf() {
        this.pauseMic();
        await this.#socketClient.sendMessage({ type: 'muteSelf' });
    }
    async unmuteSelf() {
        await this.resumeMic();
        await this.#socketClient.sendMessage({ type: 'unmuteSelf' });
    }
    async addRoomPlugin(plugin) {
        return this.#socketClient.sendMessage({
            type: 'addPlugin',
            payload: plugin,
        });
    }
    async removeRoomPlugin(plugin) {
        return this.#socketClient.sendMessage({
            type: 'removePlugin',
            payload: plugin,
        });
    }
    async remoteControlMessage(payload) {
        return this.#socketClient.sendMessage({
            type: 'message',
            payload,
        });
    }
    async requestRemoteControl(request) {
        return this.remoteControlMessage({
            peerId: request.hostPeerId,
            remoteRequestId: request.id,
            hostPeerId: request.hostPeerId,
            remotePeerId: request.remotePeerId,
            remoteRequestType: RemoteRequestType.REQUEST,
        });
    }
    async acceptRemoteControl(request) {
        return this.remoteControlMessage({
            peerId: request.remotePeerId,
            remoteRequestId: request.id,
            hostPeerId: request.hostPeerId,
            remotePeerId: request.remotePeerId,
            remoteRequestType: RemoteRequestType.ACCEPT,
        });
    }
    async terminateRemoteControl(peerId, request) {
        return this.remoteControlMessage({
            peerId,
            remoteRequestId: request.id,
            hostPeerId: request.hostPeerId,
            remotePeerId: request.remotePeerId,
            remoteRequestType: RemoteRequestType.END,
        });
    }
    async sendEventRemoteControl(peerId, remoteRequestId, remoteEvent) {
        return this.remoteControlMessage({
            peerId,
            remoteRequestId,
            remoteEvent,
            hostPeerId: this.peerId,
            remotePeerId: peerId,
            remoteRequestType: RemoteRequestType.EVENT,
        });
    }
    async assertSpotlight(messageType, spotlightAssertMessage) {
        return this.#socketClient.sendMessage({
            type: messageType,
            payload: { ...spotlightAssertMessage, roomMessageType: 'spotlight' },
        });
    }
    async assertSpotlightToRoom(spotlightAssertMessage) {
        return this.assertSpotlight('roomMessage', spotlightAssertMessage);
    }
    async assertSpotlightToPeer(spotlightAssertMessage) {
        return this.assertSpotlight('message', spotlightAssertMessage);
    }
    async requestToJoinStage(requestToJoinType) {
        await this.sendMessage({ type: 'requestToJoinStage', payload: requestToJoinType });
    }
    async acceptAllRequestToJoinStage(peers) {
        await this.sendMessage({
            type: 'acceptAllRequestToJoinStage',
            payload: peers.map((peer) => ({
                ...peer,
                type: WebinarAcceptRequestType.REQUESTED_BY_MODERATOR,
            })),
        });
    }
    async removePeerFromStage(peerId, type) {
        await this.sendMessage({ type: 'removePeerFromStage', payload: { id: peerId, type } });
    }
    stopAllProducers() {
        this.#sfuHandler.stopAllProducers();
    }
    async startPresenting() {
        await this.sendMessage({ type: 'startPresenting' });
    }
    async stopPresenting() {
        this.stopAllProducers();
        await this.sendMessage({ type: 'stopPresenting' });
    }
    async rejectRequestToJoinStage(peerId) {
        await this.sendMessage({ type: 'rejectRequestToJoinStage', payload: { id: peerId } });
    }
}
__decorate([
    DyteTelemetry.trace('RoomNodeClient.reconnect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MediasoupRoomNodeClient.prototype, "reconnect", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.joinRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean, String, String, Object]),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "joinRoom", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.leaveRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "leaveRoom", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.shareWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "shareWebcam", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.shareScreen'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "shareScreen", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.shareMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "shareMic", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.pauseMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MediasoupRoomNodeClient.prototype, "pauseMic", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.pauseWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "pauseWebcam", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.resumeMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "resumeMic", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.resumeWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "resumeWebcam", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.disableWebcam'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "disableWebcam", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.disableMic'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "disableMic", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.disableScreenShare'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "disableScreenShare", null);
__decorate([
    DyteTelemetry.trace('RoomNodeClient.resetVideoProducers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack,
        MediaStreamTrack]),
    __metadata("design:returntype", Promise)
], MediasoupRoomNodeClient.prototype, "resetVideoProducers", null);
