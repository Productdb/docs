var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import DyteError, { CatchAll } from '../../../client/DyteError';
import DyteLogger from '../../../client/internals/DyteLogger';
import LocalMediaException from '../../../media/LocalMediaException';
import { SessionEvents } from '../../../store/SessionEvents';
import { SessionStore } from '../../../store/SessionStore';
import { resolveMediaPermissionError } from '../../../utils/media';
import BaseMediaInterface from '../BaseMediaInterface';
import { ConstraintBuilder, } from './ConstraintBuilder';
let WebMediaInterface = class WebMediaInterface extends BaseMediaInterface {
    #constraintsBuilder;
    constructor(mediaConstraints) {
        super();
        this.#constraintsBuilder = new ConstraintBuilder(mediaConstraints);
    }
    handlePermissionErrors(kind, err) {
        const permissionError = resolveMediaPermissionError(err.name, err.message);
        this.permissions[kind] = permissionError;
        SessionStore.emit(SessionEvents.MEDIA_PERMISSION_ERROR, {
            message: permissionError,
            constraints: err.constraints,
            kind,
        });
    }
    async getAudioAndVideoTrack() {
        const constraints = {
            audio: this.#constraintsBuilder.getAudioConstraints().audio,
            video: this.#constraintsBuilder.getVideoConstraints().video,
        };
        try {
            const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
            const audioTrack = mediaStream.getAudioTracks()[0];
            const videoTrack = mediaStream.getVideoTracks()[0];
            this.permissions.audio = 'ACCEPTED';
            this.permissions.video = 'ACCEPTED';
            SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
                message: this.permissions.audio,
                kind: 'audio',
            });
            SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
                message: this.permissions.video,
                kind: 'video',
            });
            return { audioTrack, videoTrack };
        }
        catch (error) {
            if (error.name === 'NotAllowedError') {
                const audioTrack = await this.getAudioTrack(false);
                const videoTrack = await this.getVideoTrack();
                return { audioTrack, videoTrack };
            }
            DyteLogger.error('WebMediaInterface.getAudioAndVideoTrack', { error });
            throw new DyteError('Couldnt fetch audio and video track');
        }
    }
    async getAudioTrack(isMutedOnInit, deviceId) {
        const constraints = this.#constraintsBuilder.getAudioConstraints(deviceId);
        try {
            const audioTrack = (await navigator.mediaDevices.getUserMedia(constraints))
                .getAudioTracks()[0];
            audioTrack.enabled = !isMutedOnInit;
            this.permissions.audio = 'ACCEPTED';
            SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
                message: this.permissions.audio,
                kind: 'audio',
            });
            return audioTrack;
        }
        catch (error) {
            this.handlePermissionErrors('audio', new LocalMediaException(error.name, error.message, constraints));
            throw new DyteError(error.message, '1601');
        }
    }
    async getScreenShareTracks() {
        const constraints = this.#constraintsBuilder.getScreenShareConstraints();
        try {
            const displayMediaStream = await navigator.mediaDevices.getDisplayMedia(constraints);
            this.permissions.screenshare = 'ACCEPTED';
            SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
                message: this.permissions.screenshare,
                kind: 'screenshare',
            });
            return {
                audioTrack: displayMediaStream.getAudioTracks()[0],
                videoTrack: displayMediaStream.getVideoTracks()[0],
            };
        }
        catch (error) {
            this.handlePermissionErrors('screenshare', new LocalMediaException(error.name, error.message, constraints));
            DyteLogger.error('WebMediaInterface.getScreenShareTracks Error while fetching screenshare tracks', { error });
            throw new DyteError('Couldnt fetch screen share tracks');
        }
    }
    async getVideoTrack(deviceId) {
        const constraints = this.#constraintsBuilder.getVideoConstraints(deviceId);
        try {
            const videoTrack = (await navigator.mediaDevices.getUserMedia(constraints))
                .getVideoTracks()[0];
            this.permissions.video = 'ACCEPTED';
            SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
                message: this.permissions.video,
                kind: 'audio',
            });
            return videoTrack;
        }
        catch (error) {
            this.handlePermissionErrors('video', new LocalMediaException(error.name, error.message, constraints));
            DyteLogger.error('WebMediaInterface.getVideoTrack Error while fetching video track', { error });
            throw new DyteError('Couldnt fetch video track');
        }
    }
    async getAvailableDevices() {
        try {
            return navigator.mediaDevices.enumerateDevices();
        }
        catch (error) {
            DyteLogger.error('enumerate_devices_failed', {
                error,
            });
            throw new DyteError('Failed to get available devices');
        }
    }
    async getAvailableDevicesByKind(kind) {
        try {
            return (await navigator.mediaDevices.enumerateDevices())
                .filter(({ kind: k }) => kind === k);
        }
        catch (error) {
            DyteLogger.error('enumerate_devices_failed', {
                error,
            });
            throw new DyteError('Failed to get available devices by kind');
        }
    }
    async getDevice(deviceId) {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.filter((device) => device.deviceId === deviceId)[0];
        }
        catch (error) {
            DyteLogger.error('enumerate_devices_failed', {
                error,
            });
            throw new DyteError('Failed to get device');
        }
    }
};
WebMediaInterface = __decorate([
    CatchAll((err) => { throw new DyteError(err.message, '1600'); }),
    __metadata("design:paramtypes", [Object])
], WebMediaInterface);
export default WebMediaInterface;
