import { beforeAll, beforeEach, describe, expect, test, vi, } from 'vitest';
import setupMockedWindow from '../../../__mocks__/window';
import WebMediaInterface from '../interface/web/WebMediaInterface';
import BaseMediaHandler from './BaseMediaHandler';
import { browserSpecs } from '../../browser/BrowserCapabilities';
setupMockedWindow();
vi.mock('../../utils/opentelemetry');
vi.mock('../interface/web/WebMediaInterface');
class TestMediaHandler extends BaseMediaHandler {
    dummy() {
        return this;
    }
    async enableTrack() {
        this.dummy();
    }
    async onTrackEnded() {
        this.dummy();
    }
    async onTrackMuted() {
        this.dummy();
    }
    async setDevice() {
        this.dummy();
    }
    async setTransformedTrack() {
        this.dummy();
    }
}
TestMediaHandler.prototype.enableTrack = vi.fn();
TestMediaHandler.prototype.onTrackEnded = vi.fn();
TestMediaHandler.prototype.onTrackMuted = vi.fn();
TestMediaHandler.prototype.setDevice = vi.fn();
TestMediaHandler.prototype.setTransformedTrack = vi.fn();
let testMediaHandler;
let mediaTrack;
const middleware = (ctx) => Promise.resolve(new AudioWorkletNode(ctx, ''));
const whenSetMediaTrackIsCalled = () => describe('When setMediaTrack is called', () => {
    test('Then it should not throw an error when no mediaTrack is passed', () => {
        try {
            testMediaHandler.setMediaTrack(undefined);
        }
        catch (err) {
            expect(err).toBeUndefined();
        }
    });
    describe('When mediaTrack is passed to setMediaTrack', () => {
        beforeEach(() => {
            mediaTrack = new MediaStreamTrack();
            testMediaHandler.setMediaTrack(mediaTrack);
        });
        test('Then it should set the track to the passed mediaTrack', () => {
            expect(testMediaHandler.mediaTrack).toBe(mediaTrack);
        });
        test('Then it should try to setTransformedTrack', () => {
            expect(testMediaHandler.setTransformedTrack).toBeCalled();
        });
    });
});
describe('Given TestMediaHandler is initialized without a mediaTrack', () => {
    beforeEach(() => {
        testMediaHandler = new TestMediaHandler(new WebMediaInterface());
    });
    test('Then mediaTrack should be undefined', () => {
        expect(testMediaHandler.mediaTrack).toBeUndefined();
    });
    test('Then setTransformedTrack should not be called on initialization', () => {
        expect(testMediaHandler.setTransformedTrack).not.toBeCalled();
    });
    test('Then disableTrack() should not throw an error', () => {
        try {
            testMediaHandler.disableTrack();
        }
        catch (err) {
            expect(err).toBeUndefined();
        }
    });
    whenSetMediaTrackIsCalled();
    describe('When addMiddleware is called', () => {
        let response;
        beforeEach(async () => {
            response = await testMediaHandler.addMiddleware(middleware);
        });
        test('Then the middlewares array should be populated', () => {
            expect(testMediaHandler.middlewares).toHaveLength(1);
        });
        test('Then setTransformedTrack should not be called since trackEnabled is false', () => {
            expect(testMediaHandler.setTransformedTrack).not.toBeCalled();
        });
        test('Then expect response to have success true', () => {
            expect(response.success).toBeTruthy();
        });
        test('Then adding the same middleware should not affect the middlewares array', async () => {
            const response2 = await testMediaHandler.addMiddleware(middleware);
            expect(testMediaHandler.middlewares).toHaveLength(1);
            expect(response2.success).toBeFalsy();
        });
    });
    test('Then no error should be thrown when muteTrack is called without a track', () => {
        try {
            testMediaHandler.muteTrack();
        }
        catch (err) {
            expect(err).toBeUndefined();
        }
    });
    describe('When calling unmute track', () => {
        beforeEach(async () => {
            await testMediaHandler.unmuteTrack();
        });
        test('Then enableTrack should be called', () => {
            expect(testMediaHandler.enableTrack).toBeCalled();
        });
        test('Then disableTrack should be called on failure', async () => {
            testMediaHandler.enableTrack = vi.fn().mockRejectedValue('');
            testMediaHandler.disableTrack = vi.fn();
            try {
                await testMediaHandler.unmuteTrack();
            }
            catch (err) {
                expect(testMediaHandler.disableTrack).toBeCalled();
            }
        });
    });
});
describe('Given TestMediaHandler is initialized with a mediaTrack', () => {
    beforeEach(() => {
        mediaTrack = new MediaStreamTrack();
        testMediaHandler = new TestMediaHandler(new WebMediaInterface(), mediaTrack);
    });
    test('Then mediaTrack should be the same as passed', () => {
        expect(testMediaHandler.mediaTrack).toBe(mediaTrack);
    });
    test('Then setTransformedTrack should have been called', () => {
        expect(testMediaHandler.setTransformedTrack).toBeCalled();
    });
    test('Then trackEnabled should be true', () => {
        expect(testMediaHandler.trackEnabled).toBeTruthy();
    });
    describe('When disableTrack() is called', () => {
        beforeEach(() => {
            testMediaHandler.disableTrack();
        });
        test('Then removeMediaTrackListeners should be called', () => {
            expect(mediaTrack.removeEventListener).toBeCalledWith('ended', testMediaHandler.onTrackEnded);
            expect(mediaTrack.removeEventListener).toBeCalledWith('mute', testMediaHandler.onTrackMuted);
        });
        test('Then the mediaTrack should be stopped', () => {
            expect(mediaTrack.stop).toBeCalled();
            expect(mediaTrack.readyState).toBe('ended');
        });
        test('Then the mediaTrack in the mediaHandler should be undefined', () => {
            expect(testMediaHandler.mediaTrack).toBeUndefined();
        });
        test('Then transformedMediaTrack should be undefined', () => {
            expect(testMediaHandler.transformedMediaTrack).toBeUndefined();
        });
        test('Then trackEnabled should be false', () => {
            expect(testMediaHandler.trackEnabled).toBeFalsy();
        });
    });
    whenSetMediaTrackIsCalled();
    describe('When addMiddleware is called', () => {
        beforeAll(() => {
            mediaTrack.customResetReadyState();
        });
        let response;
        test('Then expect response to have success false when browser is safari', async () => {
            browserSpecs.isSafari = vi.fn().mockImplementationOnce(() => true);
            response = await testMediaHandler.addMiddleware(middleware);
            expect(response.success).toBeFalsy();
        });
        describe('When setTransformedTrack throws an error', () => {
            beforeEach(() => {
                testMediaHandler.middlewares = [];
                testMediaHandler.setTransformedTrack = () => { throw new Error('Dummy Error'); };
            });
            test('Then expect response to have success false', async () => {
                response = await testMediaHandler.addMiddleware(middleware);
                expect(response.success).toBeFalsy();
            });
            test('Then expect middleware to not be added in the middlewares array', async () => {
                await testMediaHandler.addMiddleware(middleware);
                expect(testMediaHandler.middlewares.includes(middleware)).toBeFalsy();
            });
        });
        beforeEach(async () => {
            response = await testMediaHandler.addMiddleware(middleware);
        });
        test('Then the middlewares array should be populated', () => {
            expect(testMediaHandler.middlewares).toHaveLength(1);
        });
        test('Then setTransformedTrack should not be called since trackEnabled is true', () => {
            expect(testMediaHandler.setTransformedTrack).toBeCalled();
        });
        test('Then expect response to have success true', () => {
            expect(response.success).toBeTruthy();
        });
        test('Then adding the same middleware should not affect the middlewares array', async () => {
            const response2 = await testMediaHandler.addMiddleware(middleware);
            expect(testMediaHandler.middlewares).toHaveLength(1);
            expect(response2.success).toBeFalsy();
        });
    });
    describe('When muteTrack is called', () => {
        beforeEach(() => {
            testMediaHandler.muteTrack();
        });
        test('Then the mediaTrack should get muted', () => {
            expect(testMediaHandler.mediaTrack?.enabled).toBeFalsy();
        });
        test('Then expect transformedMediaTrack to be muted', () => {
            expect(testMediaHandler.transformedMediaTrack?.enabled).toBeFalsy();
        });
    });
    test('Then expect mediaTrack.enabled to be true upon calling unmuteTrack', async () => {
        await testMediaHandler.unmuteTrack();
        expect(testMediaHandler.mediaTrack?.enabled).toBeTruthy();
    });
    describe('When setCurrentDevice is called', () => {
        test('Then expect currentDevice to be reassigned if it\'s `id` doesn\'t match the existing `id`', async () => {
            const webMediaInterface = new WebMediaInterface();
            webMediaInterface.getDevice = async () => ({ deviceId: '1' });
            testMediaHandler = new TestMediaHandler(webMediaInterface);
            mediaTrack.getSettings = () => ({ deviceId: '1' });
            await testMediaHandler.setMediaTrack(mediaTrack);
            expect(testMediaHandler.currentDevice?.deviceId).toBe('1');
        });
    });
    describe('When removeMiddleware is called', () => {
        test('Then expect response to be false if no middleware was present', async () => {
            const response = await testMediaHandler.removeMiddleware(middleware);
            expect(response.success).toBeFalsy();
        });
        test('Then the middleware should be removed if it was present', async () => {
            testMediaHandler.setTransformedTrack = vi.fn();
            const response1 = await testMediaHandler.addMiddleware(middleware);
            expect(response1.success).toBeTruthy();
            expect(testMediaHandler.middlewares).toHaveLength(1);
            const response2 = await testMediaHandler.removeMiddleware(middleware);
            expect(response2.success).toBeTruthy();
            expect(testMediaHandler.middlewares).toHaveLength(0);
            expect(testMediaHandler.setTransformedTrack).toBeCalled();
        });
        test('Then expect success to be false in the response if setTransformedTrack errors out', async () => {
            const response1 = await testMediaHandler.addMiddleware(middleware);
            expect(response1.success).toBeTruthy();
            expect(testMediaHandler.middlewares).toHaveLength(1);
            testMediaHandler.setTransformedTrack = () => { throw new Error('Dummy Error'); };
            const response2 = await testMediaHandler.removeMiddleware(middleware);
            expect(response2.success).toBeFalsy();
            expect(testMediaHandler.middlewares).toHaveLength(1);
        });
    });
});
