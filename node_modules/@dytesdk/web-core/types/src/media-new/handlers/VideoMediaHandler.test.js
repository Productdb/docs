import { beforeEach, describe, expect, test, vi, } from 'vitest';
import setupMockedWindow from '../../../__mocks__/window';
import WebMediaInterface from '../interface/web/WebMediaInterface';
import VideoMiddlewareUtils from '../middleware/VideoMiddlewareUtils';
import VideoMediaHandler from './VideoMediaHandler';
setupMockedWindow();
vi.mock('../../utils/opentelemetry');
vi.mock('../interface/web/WebMediaInterface');
vi.mock('../middleware/VideoMiddlewareUtils');
let videoMediaHandler;
let device;
let mediaTrack;
let webMediaInterface;
const middleware = () => async (canvas, ctx) => { if (canvas)
    Function.prototype(); if (ctx)
    Function.prototype(); };
VideoMiddlewareUtils.getTransformedVideoTrack = vi.fn();
VideoMiddlewareUtils.terminateMiddlewareWebWorker = vi.fn();
describe('Given VideoMediaHandler is initialized', () => {
    beforeEach(() => {
        webMediaInterface = new WebMediaInterface();
        mediaTrack = new MediaStreamTrack();
        webMediaInterface.getVideoTrack = vi.fn(async () => mediaTrack);
        videoMediaHandler = new VideoMediaHandler(webMediaInterface);
        videoMediaHandler.emit = vi.fn();
        device = new MediaDeviceInfo();
        device.kind = 'videoinput';
    });
    describe('When setDevice is called', () => {
        test('Then it should throw an error when no device is passed', async () => {
            try {
                await videoMediaHandler.setDevice();
            }
            catch (err) {
                expect(err.message.includes('No device received!')).toBeTruthy();
            }
        });
        test('Then it should throw an error when the received device is not an video device', async () => {
            try {
                device.kind = 'audioinput';
                await videoMediaHandler.setDevice(device);
            }
            catch (err) {
                expect(err.message.includes('Non video device received while setting video device!')).toBeTruthy();
            }
        });
        describe('When mediaTrack was not already set', () => {
            beforeEach(async () => {
                await videoMediaHandler.setDevice(device);
            });
            test('Then it should just set the current device and return', () => {
                expect(videoMediaHandler.currentDevice).toBe(device);
            });
        });
        describe('When mediaTrack was already set', () => {
            beforeEach(async () => {
                await videoMediaHandler.setMediaTrack(mediaTrack);
                await videoMediaHandler.setDevice(device);
            });
            test('Then mediaTrack device should be set', () => {
                expect(videoMediaHandler.mediaTrack).toBeDefined();
            });
            describe('When setMediaTrack throws an error', () => {
                let error;
                beforeEach(async () => {
                    videoMediaHandler.disableTrack = vi.fn();
                    videoMediaHandler.setMediaTrack = vi.fn(() => { throw new Error('Dummy Error'); });
                    try {
                        await videoMediaHandler.setDevice(device);
                    }
                    catch (err) {
                        error = err;
                    }
                });
                test('Then track should be disabled', () => {
                    expect(videoMediaHandler.disableTrack).toBeCalled();
                });
                test('Then expect error to be defined', () => {
                    expect(error).toBeDefined();
                });
            });
        });
    });
    describe('When enableTrack is called', () => {
        beforeEach(async () => {
            videoMediaHandler.setMediaTrack = vi.fn();
            await videoMediaHandler.enableTrack();
        });
        test('Then getVideoTrack must be called', () => {
            expect(webMediaInterface.getVideoTrack).toBeCalled();
        });
        test('Then setMediaTrack should be called with a mediaStreamTrack', () => {
            expect(videoMediaHandler.setMediaTrack).toBeCalledWith(mediaTrack);
        });
    });
    describe('When setTransformedTrack is called', () => {
        test('Then it should set mediaTrack to transformedMediaTrack when middlewares are absent', async () => {
            await videoMediaHandler.setTransformedTrack();
            expect(videoMediaHandler.transformedMediaTrack).toBe(videoMediaHandler.mediaTrack);
        });
        describe('When middlewares are present', () => {
            beforeEach(async () => {
                await videoMediaHandler.addMiddleware(middleware);
                await videoMediaHandler.setTransformedTrack();
            });
            test('Then it should emit trackChanged', () => {
                expect(videoMediaHandler.emit).toBeCalledWith('trackChanged');
            });
            test('Then it should set transformedMediaTrack to mediaTrack when anything errors out', async () => {
                VideoMiddlewareUtils.getTransformedVideoTrack = vi.fn(() => { throw new Error('Dummy Error'); });
                await videoMediaHandler.addMiddleware(middleware);
                await videoMediaHandler.setTransformedTrack();
                expect(videoMediaHandler.transformedMediaTrack).toBe(videoMediaHandler.mediaTrack);
            });
        });
    });
    describe('When mediaTrack emits events', () => {
        const webMediaInterface2 = new WebMediaInterface();
        const mediaTrack2 = new MediaStreamTrack();
        const videoMediaHandler2 = new VideoMediaHandler(webMediaInterface2, mediaTrack2);
        videoMediaHandler2.disableTrack = vi.fn();
        videoMediaHandler2.enableTrack = vi.fn();
        videoMediaHandler2.setTransformedTrack = vi.fn();
        videoMediaHandler2.emit = vi.fn();
        describe('When mediaTrack emits \'mute\' event', () => {
            test('Then trackMuted event should be emitted', () => {
                mediaTrack2.emit('mute');
                expect(videoMediaHandler2.emit).toBeCalledWith('trackMuted');
            });
        });
        describe('When mediaTrack emits \'ended\' event', () => {
            beforeEach(async () => {
                await mediaTrack2.emit('ended');
            });
            test('Then disableTrack, enableTrack, setTransformedTrack should be called', async () => {
                expect(videoMediaHandler2.disableTrack).toBeCalled();
            });
            test('Then trackMuted event should be emitted', async () => {
                expect(videoMediaHandler2.emit).toBeCalledWith('trackEnded');
            });
        });
    });
});
