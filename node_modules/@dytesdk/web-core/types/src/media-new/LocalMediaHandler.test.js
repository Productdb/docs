import { beforeEach, describe, expect, test, vi, } from 'vitest';
import setupMockedWindow from '../../__mocks__/window';
import AudioMediaHandler from './handlers/AudioMediaHandler';
import AudioOutputMediaHandler from './handlers/AudioOutputMediaHandler';
import ScreenShareMediaHandler from './handlers/ScreenShareHandler';
import VideoMediaHandler from './handlers/VideoMediaHandler';
import WebMediaInterface from './interface/web/WebMediaInterface';
import LocalMediaHandler from './LocalMediaHandler';
import { getAudioAndVideoTrack, getAudioTrack, getVideoTrack, webMediaInterfaceAudioTrack, webMediaInterfaceVideoTrack, } from './interface/web/__mocks__/WebMediaInterface';
setupMockedWindow();
vi.mock('../utils/opentelemetry');
vi.mock('./interface/web/WebMediaInterface');
vi.mock('./handlers/AudioMediaHandler');
vi.mock('./handlers/VideoMediaHandler');
vi.mock('./handlers/ScreenShareHandler');
vi.mock('./handlers/AudioOutputMediaHandler');
const audioMiddleware = (ctx) => Promise.resolve(new AudioWorkletNode(ctx, ''));
const videoMiddleware = () => async (canvas, ctx) => { if (canvas)
    Function.prototype(); if (ctx)
    Function.prototype(); };
let localMediaHandler;
const presetConstraints = {
    video: {
        quality: 'hd',
        frameRate: 60,
    },
    screenshare: {
        quality: 'full_hd',
        frameRate: 24,
    },
};
let webMediaInterface;
let audioMediaHandler;
let videoMediaHandler;
let screenShareMediaHandler;
let audioOutputMediaHandler;
describe('Given LocalMediaHandler is initialized', () => {
    beforeEach(() => {
        webMediaInterface = new WebMediaInterface();
        audioMediaHandler = new AudioMediaHandler(webMediaInterface);
        videoMediaHandler = new VideoMediaHandler(webMediaInterface);
        screenShareMediaHandler = new ScreenShareMediaHandler(webMediaInterface);
        audioOutputMediaHandler = new AudioOutputMediaHandler(webMediaInterface);
        localMediaHandler = new LocalMediaHandler(presetConstraints);
    });
    test('Then it should have all it\'s members defined', () => {
        expect(WebMediaInterface).toBeCalled();
        expect(AudioMediaHandler).toBeCalledWith(webMediaInterface);
        expect(VideoMediaHandler).toBeCalledWith(webMediaInterface);
        expect(ScreenShareMediaHandler).toBeCalledWith(webMediaInterface);
        expect(AudioOutputMediaHandler).toBeCalledWith(webMediaInterface);
    });
    test('Then the handlers must attach their listeners', () => {
        expect(audioMediaHandler.on).toBeCalledWith('trackMuted', expect.any(Function));
        expect(audioMediaHandler.on).toBeCalledWith('trackChanged', expect.any(Function));
        expect(videoMediaHandler.on).toBeCalledWith('trackChanged', expect.any(Function));
        expect(videoMediaHandler.on).toBeCalledWith('trackEnded', expect.any(Function));
        expect(screenShareMediaHandler.on).toBeCalledWith('trackEnded', expect.any(Function));
    });
    describe('When setupStreams is called', () => {
        describe('When both audio and video are false', () => {
            beforeEach(async () => {
                await localMediaHandler.setupStreams({ audio: false, video: false });
            });
            test('Then audioTrack and videoTrack should not be defined', () => {
                expect(audioMediaHandler.setMediaTrack).toBeCalledWith(undefined);
                expect(videoMediaHandler.setMediaTrack).toBeCalledWith(undefined);
            });
            test('Then it should call setupSpeaker nonetheless', () => {
                expect(audioOutputMediaHandler.setupSpeaker).toBeCalled();
            });
            test('Then it should not throw an error if setupSpeaker errors out', async () => {
                audioOutputMediaHandler.setupSpeaker = vi.fn(() => { throw new Error('Dummy Error'); });
                let error;
                try {
                    await localMediaHandler.setupStreams({ audio: false, video: false });
                }
                catch (err) {
                    error = err;
                }
                expect(error).toBeUndefined();
            });
        });
        describe('When audio and video are both true', () => {
            beforeEach(async () => {
                await localMediaHandler.setupStreams({ audio: true, video: true });
            });
            test('Then audio and video track should be extracted in one media call', async () => {
                expect(getAudioAndVideoTrack).toBeCalled();
            });
            test('Then setMediaTrack should be called with media stream tracks', () => {
                expect(audioMediaHandler.setMediaTrack).toBeCalledWith(webMediaInterfaceAudioTrack);
                expect(videoMediaHandler.setMediaTrack).toBeCalledWith(webMediaInterfaceVideoTrack);
            });
            test('Then it should call setupSpeaker', () => {
                expect(audioOutputMediaHandler.setupSpeaker).toBeCalled();
            });
        });
        describe('When audio is true and video is false', () => {
            beforeEach(async () => {
                await localMediaHandler.setupStreams({ audio: true, video: false });
            });
            test('Then audio and video track should be extracted in one media call', async () => {
                expect(getAudioTrack).toBeCalled();
            });
            test('Then audio and video track should be extracted in one media call', async () => {
                expect(audioMediaHandler.setMediaTrack).toBeCalledWith(webMediaInterfaceAudioTrack);
                expect(videoMediaHandler.setMediaTrack).toBeCalledWith(undefined);
            });
            test('Then it should call setupSpeaker', () => {
                expect(audioOutputMediaHandler.setupSpeaker).toBeCalled();
            });
        });
        describe('When audio is false and video is true', () => {
            beforeEach(async () => {
                await localMediaHandler.setupStreams({ audio: false, video: true });
            });
            test('Then audio and video track should be extracted in one media call', async () => {
                expect(getVideoTrack).toBeCalled();
            });
            test('Then audio and video track should be extracted in one media call', async () => {
                expect(audioMediaHandler.setMediaTrack).toBeCalledWith(undefined);
                expect(videoMediaHandler.setMediaTrack).toBeCalledWith(webMediaInterfaceVideoTrack);
            });
            test('Then it should call setupSpeaker', () => {
                expect(audioOutputMediaHandler.setupSpeaker).toBeCalled();
            });
        });
    });
    test('Then it should return devices getCurrentDevices is called', () => {
        const devices = localMediaHandler.getCurrentDevices();
        expect('audio' in devices).toBeTruthy();
        expect('video' in devices).toBeTruthy();
        expect('speaker' in devices).toBeTruthy();
        expect(devices.audio).toBe(audioMediaHandler.currentDevice);
        expect(devices.video).toBe(videoMediaHandler.currentDevice);
        expect(devices.speaker).toBe(audioOutputMediaHandler.currentDevice);
    });
    test('Then get permissions should return mediaInterface permissions', () => {
        expect(localMediaHandler.permissions).toBe(webMediaInterface.permissions);
    });
    test('Then getAllDevices should call getAvailableDevices in media interface', () => {
        const devices = localMediaHandler.getAllDevices();
        const devices2 = webMediaInterface.getAvailableDevices();
        expect(webMediaInterface.getAvailableDevices).toBeCalled();
        expect(devices).toBe(devices2);
    });
    test('Then getDeviceById should call getDevice in media interface', () => {
        const deviceId = 'default';
        localMediaHandler.getDeviceById(deviceId);
        expect(webMediaInterface.getDevice).toBeCalledWith(deviceId);
    });
    test('Then the tracks should be defined', () => {
        expect(localMediaHandler.rawAudioTrack).toBe(audioMediaHandler.mediaTrack);
        expect(localMediaHandler.rawVideoTrack).toBe(videoMediaHandler.mediaTrack);
        expect(localMediaHandler.audioTrack).toBe(audioMediaHandler.transformedMediaTrack);
        expect(localMediaHandler.videoTrack).toBe(videoMediaHandler.transformedMediaTrack);
        expect(localMediaHandler.audioEnabled).toBe(audioMediaHandler.trackEnabled);
        expect(localMediaHandler.videoEnabled).toBe(videoMediaHandler.trackEnabled);
    });
    test('Then enable and disable methods should call respective handlers', async () => {
        await localMediaHandler.enableAudio();
        expect(audioMediaHandler.unmuteTrack).toBeCalled();
        localMediaHandler.disableAudio();
        expect(audioMediaHandler.muteTrack).toBeCalled();
        await localMediaHandler.enableVideo();
        expect(videoMediaHandler.unmuteTrack).toBeCalled();
        localMediaHandler.disableVideo();
        expect(videoMediaHandler.disableTrack).toBeCalled();
        await localMediaHandler.enableScreenShare();
        expect(screenShareMediaHandler.enableScreenShare).toBeCalled();
        await localMediaHandler.disableScreenShare();
        expect(screenShareMediaHandler.disableScreenShare).toBeCalled();
    });
    test('Then middleware functions should be called properly', async () => {
        await localMediaHandler.addAudioMiddleware(audioMiddleware);
        expect(audioMediaHandler.addMiddleware).toBeCalledWith(audioMiddleware);
        await localMediaHandler.removeAudioMiddleware(audioMiddleware);
        expect(audioMediaHandler.removeMiddleware).toBeCalledWith(audioMiddleware);
        await localMediaHandler.addVideoMiddleware(videoMiddleware);
        expect(videoMediaHandler.addMiddleware).toBeCalledWith(videoMiddleware);
        await localMediaHandler.removeVideoMiddleware(videoMiddleware);
        expect(videoMediaHandler.removeMiddleware).toBeCalledWith(videoMiddleware);
    });
    test('Then set device methods should call their corresponding handlers', async () => {
        const audioDevice = new MediaDeviceInfo();
        const videoDevice = new MediaDeviceInfo();
        videoDevice.kind = 'videoinput';
        const speakerDevice = new MediaDeviceInfo();
        speakerDevice.kind = 'audiooutput';
        await localMediaHandler.setAudioDevice(audioDevice);
        expect(audioMediaHandler.setDevice).toBeCalledWith(audioDevice);
        await localMediaHandler.setVideoDevice(videoDevice);
        expect(videoMediaHandler.setDevice).toBeCalledWith(videoDevice);
        await localMediaHandler.setSpeakerDevice(speakerDevice);
        expect(audioOutputMediaHandler.setupSpeaker).toBeCalledWith(speakerDevice);
    });
});
