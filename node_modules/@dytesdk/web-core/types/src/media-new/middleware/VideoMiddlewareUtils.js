import * as WorkerTimers from 'worker-timers';
import DyteLogger from '../../client/internals/DyteLogger';
export default class VideoMiddlewareUtils {
    #middlewareWebWorkerInterval = undefined;
    terminateMiddlewareWebWorker() {
        if (this.#middlewareWebWorkerInterval) {
            try {
                WorkerTimers.clearInterval(this.#middlewareWebWorkerInterval);
                this.#middlewareWebWorkerInterval = undefined;
            }
            catch (ex) {
                DyteLogger.debug('WorkerTimers::terminateMiddlewareWebWorker::failed');
            }
        }
    }
    async getTransformedVideoTrack(videoMiddlewares, originalVideoTrack) {
        if (!videoMiddlewares?.length) {
            return originalVideoTrack;
        }
        const middlewares = await Promise.all(videoMiddlewares?.map((videoMiddleware) => videoMiddleware()));
        const originalVideoStream = new MediaStream();
        originalVideoStream.addTrack(originalVideoTrack);
        const transformedVideoCanvasElement = document.createElement('canvas');
        const transformedVideoCanvasCtx = transformedVideoCanvasElement.getContext('2d');
        const rawVideoFeedElement = document.createElement('video');
        rawVideoFeedElement.srcObject = originalVideoStream;
        rawVideoFeedElement.autoplay = true;
        this.terminateMiddlewareWebWorker();
        const intervalCallback = async () => {
            if (originalVideoTrack.enabled === false
                || originalVideoTrack.readyState === 'ended') {
                this.terminateMiddlewareWebWorker();
                rawVideoFeedElement.remove();
                transformedVideoCanvasElement.remove();
                return;
            }
            try {
                transformedVideoCanvasCtx.drawImage(rawVideoFeedElement, 0, 0);
                for (let middlewareIndex = 0; middlewareIndex < middlewares.length; middlewareIndex += 1) {
                    await middlewares[middlewareIndex](transformedVideoCanvasElement, transformedVideoCanvasCtx);
                }
            }
            catch (error) {
                DyteLogger.error('getTransformedVideoTrack::middleware_execution_failed', { error });
            }
        };
        try {
            rawVideoFeedElement.play();
        }
        catch (ex) {
        }
        rawVideoFeedElement.addEventListener('play', () => {
            transformedVideoCanvasElement.width = rawVideoFeedElement.width
                || originalVideoTrack.getSettings().width;
            transformedVideoCanvasElement.height = rawVideoFeedElement.width
                || originalVideoTrack.getSettings().height;
            this.#middlewareWebWorkerInterval = WorkerTimers.setInterval(intervalCallback, 50);
        }, false);
        const canvasMediaStream = transformedVideoCanvasElement.captureStream();
        return canvasMediaStream.getVideoTracks()[0];
    }
}
