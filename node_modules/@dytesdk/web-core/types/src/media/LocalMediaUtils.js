var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
type callStats = any; 
import debounce from 'lodash-es/debounce';
import { globalFlagsmith } from '@dyteinternals/utils';
import DyteTelemetry from '../utils/opentelemetry';
import { browserSpecs } from '../browser/BrowserCapabilities';
import { VIDEO_CONSTRAINTS } from '../roomNode/RoomNodeConfig';
import LocalMediaError from './LocalMediaError';
import LocalMediaException from './LocalMediaException';
import DyteLogger from '../client/internals/DyteLogger';
import { FlagsmithFeatureFlags } from '../utils/flags';
const chromePort = {
    port: undefined,
};
export const virtualDeviceLabelInclusions = [
    'virtual',
    'emulator',
    'krisp',
    'solstice conference',
    'teams',
    'manycam',
    'blackHole',
];
export function isVirtualDevice(mediaDevice) {
    const mediaDeviceLabel = mediaDevice.label.toLowerCase();
    if (browserSpecs._bowser.getOSName() === 'macOS' && mediaDeviceLabel.includes('iphone')) {
        DyteLogger.log('isVirtualDevice::ignore_macos_continuity');
        return true;
    }
    return virtualDeviceLabelInclusions.some((inclusion) => mediaDeviceLabel.includes(inclusion));
}
export default class LocalMediaUtils {
    #availableDevices;
    #deviceChangeAbortController;
    constructor(availableDevices) {
        this.#availableDevices = availableDevices;
        this.#deviceChangeAbortController = new AbortController();
    }
    static async init() {
        let availableDevices = [];
        if (LocalMediaUtils.isDeviceListAvailable()) {
            availableDevices = await LocalMediaUtils.enumerateDevices();
            DyteLogger.info('initial_full_device_list', {
                devices: JSON.stringify(availableDevices),
            });
        }
        else {
            DyteLogger.error('UnsupportedMediaAPI::navigator.mediaDevices.enumerateDevices', {
                debuggingHint: 'Try checking meetingMetadata.visitedUrl. It should be running on localhost/127.0.0.1 or HTTPS, if not, there would be issues.',
            });
        }
        return new LocalMediaUtils(availableDevices);
    }
    async destruct() {
        this.#deviceChangeAbortController?.abort();
    }
    static isDeviceListAvailable() {
        return !!(navigator.mediaDevices
            && navigator.mediaDevices.enumerateDevices);
    }
    static enumerateDevices() {
        try {
            return navigator.mediaDevices.enumerateDevices();
        }
        catch (error) {
            DyteLogger.error('enumerate_devices_failed', {
                error,
            });
            return Promise.resolve([]);
        }
    }
    static getAudioConstraints(options) {
        const constraints = {};
        const { disableAP = false, disableAEC = false, disableNS = false, disableAGC = false, disableHPF = false, } = options.audioOptions || {};
        if (browserSpecs.isFirefox() || browserSpecs.isWebKitBased()) {
            constraints.audio = {
                deviceId: options.audioDeviceId,
                autoGainControl: !disableAGC && !disableAP,
                echoCancellation: !disableAEC && !disableAP,
                noiseSuppression: !disableNS && !disableAP,
            };
        }
        else {
            if (typeof constraints.audio === 'boolean') {
                return constraints;
            }
            constraints.audio = {};
            constraints.audio.optional = [
                options.audioDeviceId
                    ? { sourceId: options.audioDeviceId }
                    : { sourceId: 'default' },
                { echoCancellation: !disableAEC && !disableAP },
                { googEchoCancellation: !disableAEC && !disableAP },
                { googAutoGainControl: !disableAGC && !disableAP },
                { googNoiseSuppression: !disableNS && !disableAP },
                { googHighpassFilter: !disableHPF && !disableAP },
                { googNoiseSuppression2: !disableNS && !disableAP },
                { googEchoCancellation2: !disableAEC && !disableAP },
                { googAutoGainControl2: !disableAGC && !disableAP },
            ];
        }
        return constraints;
    }
    static getVideoConstraints(options) {
        const constraints = {};
        const { videoDeviceId, videoTrackConstraints, facingMode = 'user', frameRate = { ideal: 24, max: 30 }, } = options;
        constraints.video = videoTrackConstraints || VIDEO_CONSTRAINTS.vga;
        if (typeof constraints.video === 'boolean') {
            return constraints;
        }
        if (videoDeviceId) {
            constraints.video.deviceId = { exact: videoDeviceId };
        }
        constraints.video.facingMode = facingMode;
        constraints.video.frameRate = frameRate;
        return constraints;
    }
    static async getUserMediaWithTimeout(constraints = {}, timeout = 0) {
        try {
            DyteLogger.info('getUserMediaWithTimeout::requesting_user_media', {
                timeout,
                constraints: JSON.stringify(constraints),
            });
            if (!timeout) {
                const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                DyteLogger.info('getUserMediaWithTimeout::received_user_media', {
                    timeout,
                    constraints: JSON.stringify(constraints),
                });
                return mediaStream;
            }
            const mediaStreamResp = await Promise.race([
                navigator.mediaDevices.getUserMedia(constraints),
                new Promise((_resolve, reject) => {
                    setTimeout(() => reject(new LocalMediaError('Get user media timed out', 'ERR_GUM_TIMEOUT')), timeout);
                }),
            ]);
            DyteLogger.info('getUserMediaWithTimeout::received_user_media', {
                timeout,
                constraints: JSON.stringify(constraints),
            });
            return mediaStreamResp;
        }
        catch (error) {
            DyteLogger.error('getUserMediaWithTimeout::failed_to_access_local_media', {
                error,
                constraints: JSON.stringify(constraints),
            });
            DyteLogger.error('Failed to get access to local media.', { error, constraints: JSON.stringify(constraints) });
            throw new LocalMediaException(error.name, error.message, constraints);
        }
    }
    static async getAudioTrack(constraints) {
        const mediaStream = await LocalMediaUtils.getUserMediaWithTimeout(constraints);
        return mediaStream.getAudioTracks()[0];
    }
    static async getVideoTrack(constraints) {
        const mediaStream = await LocalMediaUtils.getUserMediaWithTimeout(constraints);
        return mediaStream.getVideoTracks()[0];
    }
    static async getScreenShareTracks(constraints) {
        let useExtensionHack = globalFlagsmith.hasFeature(FlagsmithFeatureFlags.EXTENSION_HACK);
        let extenstionStreamId = null;
        if (useExtensionHack) {
            try {
                chromePort.port = window.chrome.runtime.connect('nkeimhogjdpnpccoofpliimaahmaaome', { name: 'chooseDesktopMedia' });
            }
            catch {
                DyteTelemetry.addLogInCurrentSpan('error', 'Extension connect error');
                useExtensionHack = false;
            }
        }
        if (useExtensionHack) {
            extenstionStreamId = await (new Promise((resolve) => {
                const time = setTimeout(() => resolve(undefined), 12000);
                chromePort.port.onMessage.addListener(async (msg) => {
                    if (msg.value.streamId) {
                        const { streamId } = msg.value;
                        clearTimeout(time);
                        resolve(streamId);
                    }
                });
                chromePort.port.postMessage({ method: 'chooseDesktopMedia', sources: ['screen'] });
            }));
        }
        let stream;
        if (extenstionStreamId) {
            DyteTelemetry.addLogInCurrentSpan('error', 'Acquiring extension screenshare track');
            stream = await navigator.mediaDevices.getUserMedia({
                audio: false,
                video: {
                    mandatory: {
                        maxWidth: 1920,
                        maxHeight: 1080,
                        chromeMediaSource: 'desktop',
                        chromeMediaSourceId: extenstionStreamId,
                    },
                    optional: [
                        {
                            maxFrameRate: parseInt(globalFlagsmith.getValue(FlagsmithFeatureFlags.VAL_MAX_FRAMERATE_EXT) ?? '12', 10),
                        },
                        {
                            minFrameRate: parseInt(globalFlagsmith.getValue(FlagsmithFeatureFlags.VAL_MIN_FRAMERATE_EXT) ?? '8', 10),
                        },
                    ],
                },
            });
            DyteTelemetry.addLogInCurrentSpan('error', 'Acquired extension screenshare track');
        }
        else {
            stream = await navigator.mediaDevices
                .getDisplayMedia(constraints);
        }
        return { video: stream.getVideoTracks()[0], audio: stream.getAudioTracks()[0] };
    }
    static async getAudioAndVideoTrack(constraints) {
        const mediaStream = await LocalMediaUtils.getUserMediaWithTimeout(constraints);
        return {
            audioTrack: mediaStream.getAudioTracks()[0],
            videoTrack: mediaStream.getVideoTracks()[0],
        };
    }
    onDeviceChange(callback) {
        if (browserSpecs.supportsDeviceChangeEvent()) {
            navigator.mediaDevices.addEventListener('devicechange', debounce(async (ev) => {
                const previouslyAvailableDevices = this.availableDevices;
                const previouslyAvailableDeviceIds = new Set(previouslyAvailableDevices
                    .map((device) => device.deviceId));
                await this.repopulateAvailableDevices();
                const currentlyAvailableDevices = this.availableDevices;
                const currentlyAvailableDeviceIds = new Set(currentlyAvailableDevices
                    .map((device) => device.deviceId));
                const changedDevices = {
                    added: currentlyAvailableDevices
                        .filter((device) => !previouslyAvailableDeviceIds.has(device.deviceId)),
                    removed: previouslyAvailableDevices
                        .filter((device) => !currentlyAvailableDeviceIds.has(device.deviceId)),
                };
                this.repopulateAvailableDevices()
                    .then(() => callback(ev, changedDevices));
            }, 100), { signal: this.#deviceChangeAbortController.signal });
        }
    }
    async repopulateAvailableDevices() {
        const devices = await LocalMediaUtils.enumerateDevices();
        this.#availableDevices = devices;
        callStats.devices('AUDIO', this.getAudioDevices());
        callStats.devices('VIDEO', this.getVideoDevices());
        callStats.devices('SPEAKER', this.getSpeakerDevices());
        DyteLogger.info('repopulated_full_device_list', {
            devices: JSON.stringify(devices),
        });
    }
    get availableDevices() {
        return this.#availableDevices;
    }
    getAvailableDevicesByKind(kind) {
        return this.#availableDevices.filter((device) => device.kind === kind);
    }
    getDeviceById(deviceId, kind) {
        return this.#availableDevices.find((device) => device.deviceId === deviceId
            && device.kind === kind);
    }
    getAudioDevices() {
        return this.getAvailableDevicesByKind('audioinput').sort((a, b) => {
            const aScore = isVirtualDevice(a) ? 0 : 1;
            const bScore = isVirtualDevice(b) ? 0 : 1;
            return bScore - aScore;
        });
    }
    getVideoDevices() {
        return this.getAvailableDevicesByKind('videoinput').sort((a, b) => {
            const aScore = isVirtualDevice(a) ? 0 : 1;
            const bScore = isVirtualDevice(b) ? 0 : 1;
            return bScore - aScore;
        });
    }
    getSpeakerDevices() {
        return this.getAvailableDevicesByKind('audiooutput').sort((a, b) => {
            const aScore = isVirtualDevice(a) ? 0 : 1;
            const bScore = isVirtualDevice(b) ? 0 : 1;
            return bScore - aScore;
        });
    }
}
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.onDeviceChange'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", void 0)
], LocalMediaUtils.prototype, "onDeviceChange", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.repopulateAvailableDevices'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaUtils.prototype, "repopulateAvailableDevices", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.isDeviceListAvailable'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaUtils, "isDeviceListAvailable", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.enumerateDevices'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaUtils, "enumerateDevices", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.getUserMediaWithTimeout'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Number]),
    __metadata("design:returntype", Promise)
], LocalMediaUtils, "getUserMediaWithTimeout", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.getAudioTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], LocalMediaUtils, "getAudioTrack", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.getVideoTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], LocalMediaUtils, "getVideoTrack", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.getScreenShareTracks'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], LocalMediaUtils, "getScreenShareTracks", null);
__decorate([
    DyteTelemetry.trace('LocalMediaUtils.getAudioAndVideoTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], LocalMediaUtils, "getAudioAndVideoTrack", null);
