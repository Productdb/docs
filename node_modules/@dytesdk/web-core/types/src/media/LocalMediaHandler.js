var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { EventEmitter } from 'events';
type CallStatsPermissionEnum = any; 
type callStats = any; 
import { globalFlagsmith } from '@dyteinternals/utils';
import LocalMediaUtils, { isVirtualDevice } from './LocalMediaUtils';
import MediaMiddlewareUtils from './MediaMiddlewareUtils';
import { browserSpecs } from '../browser/BrowserCapabilities';
import checkIfAudioTrackIsSilent from '../utils/audio/detectSilentAudio';
import DyteTelemetry from '../utils/opentelemetry';
import localMediaExecutionContext from './LocalMediaExecutionContext';
import { SessionStore } from '../store/SessionStore';
import { SessionEvents } from '../store/SessionEvents';
import { resolveMediaPermissionError } from '../utils/media';
import LocalMediaException from './LocalMediaException';
import DyteError from '../client/DyteError';
import { FlagsmithFeatureFlags } from '../utils/flags';
import DyteLocalStorage from '../utils/DyteLocalStorage';
import DyteLogger from '../client/internals/DyteLogger';
import { ConstraintBuilder, } from '../media-new/interface/web/ConstraintBuilder';
export var MediaEvents;
(function (MediaEvents) {
    MediaEvents[MediaEvents["AUDIO_TRACK_CHANGE"] = 0] = "AUDIO_TRACK_CHANGE";
    MediaEvents[MediaEvents["VIDEO_TRACK_CHANGE"] = 1] = "VIDEO_TRACK_CHANGE";
    MediaEvents[MediaEvents["SCREENSHARE_TRACK_CHANGE"] = 2] = "SCREENSHARE_TRACK_CHANGE";
    MediaEvents[MediaEvents["SCREENSHARE_ENDED"] = 3] = "SCREENSHARE_ENDED";
    MediaEvents[MediaEvents["AUDIO_TRACK_SILENT"] = 4] = "AUDIO_TRACK_SILENT";
    MediaEvents[MediaEvents["FORCE_MUTE_AUDIO"] = 5] = "FORCE_MUTE_AUDIO";
    MediaEvents[MediaEvents["FORCE_MUTE_VIDEO"] = 6] = "FORCE_MUTE_VIDEO";
    MediaEvents[MediaEvents["DEVICE_CHANGE"] = 7] = "DEVICE_CHANGE";
})(MediaEvents || (MediaEvents = {}));
export default class LocalMediaHandlerDeprecated extends EventEmitter {
    #localMediaUtils;
    #constraintsBuilder;
    mediaMiddlewareUtils;
    audioTrack;
    rawAudioTrack;
    videoTrack;
    rawVideoTrack;
    screenShareTracks;
    audioEnabled;
    videoEnabled;
    screenShareEnabled;
    currentDevices;
    permissions;
    audioUpdateInProgress;
    videoUpdateInProgress;
    screenShareUpdateInProgress;
    constructor(localMediaUtils, presetMediaConstraints) {
        super();
        this.#localMediaUtils = localMediaUtils;
        this.#constraintsBuilder = new ConstraintBuilder(presetMediaConstraints);
        this.audioEnabled = true;
        this.videoEnabled = true;
        this.audioUpdateInProgress = false;
        this.videoUpdateInProgress = false;
        this.screenShareUpdateInProgress = false;
        this.screenShareEnabled = false;
        this.permissions = {
            audio: 'NOT_REQUESTED',
            video: 'NOT_REQUESTED',
            screenshare: 'NOT_REQUESTED',
        };
        this.screenShareTracks = {
            audio: undefined,
            video: undefined,
        };
        this.currentDevices = {
            audio: undefined,
            video: undefined,
            speaker: undefined,
        };
        this.#localMediaUtils.onDeviceChange((_, changedDevices) => this.onDeviceChange(changedDevices, false));
        this.updateDevices();
        this.conditionallyRestartAudio = this.conditionallyRestartAudio.bind(this);
        this.conditionallyRestartVideo = this.conditionallyRestartVideo.bind(this);
        this.onVisibilityChange = this.onVisibilityChange.bind(this);
        document.addEventListener('visibilitychange', this.onVisibilityChange);
        this.on('AUDIO_TRACK_CHANGE', () => {
            this.notifyIfTrackSilent();
        });
    }
    handlePermissionErrors(kind, err) {
        const permissionError = resolveMediaPermissionError(err.name, err.message);
        this.permissions[kind] = permissionError;
        SessionStore.emit(SessionEvents.MEDIA_PERMISSION_ERROR, {
            message: permissionError,
            constraints: err.constraints,
            kind,
        });
    }
    onVisibilityChange(evt) {
        if (document.visibilityState === 'visible') {
            if (browserSpecs.isMobile()) {
                this.conditionallyRestartAudio();
            }
            this.conditionallyRestartVideo();
        }
        callStats.tabChanged(document.visibilityState === 'visible');
        if (document.visibilityState !== 'visible') {
            callStats.browserBackgrounded();
        }
        else {
            callStats.browserForegrounded();
        }
    }
    async conditionallyRestartAudio(ev) {
        if (!this.currentDevices?.audio || !this.audioEnabled) {
            return;
        }
        await Promise.race([
            new Promise((resolve) => this.rawAudioTrack?.addEventListener('unmute', (e) => {
                resolve(e);
            })),
            new Promise((resolve) => setTimeout(resolve, 50)),
        ]);
        DyteLogger.info('performingCheck::shouldReacquireAudioTrack', { actions: { trackRobustness: { eventType: ev?.type } } });
        const reacquireTrack = await this.shouldReacquireTrack('audio');
        DyteLogger.info('performedCheck::shouldReacquireAudioTrack', {
            actions: {
                trackRobustness: {
                    reacquireTrack,
                },
            },
        });
        if (reacquireTrack) {
            DyteLogger.info('reacquiring_audio_track');
            this.removeMediaStreamTrackListeners(this.rawAudioTrack);
            if (browserSpecs.isChromiumBased()) {
                await this.#localMediaUtils.repopulateAvailableDevices();
            }
            await this.setupAudioStream(this.currentDevices.audio?.deviceId);
            this.addMediaStreamTrackListeners(this.rawAudioTrack);
            this.emit('AUDIO_TRACK_CHANGE');
        }
    }
    async conditionallyRestartVideo(ev) {
        if (!this.currentDevices?.video || !this.videoEnabled)
            return;
        DyteLogger.info('performingCheck::shouldReacquireVideoTrack', { actions: { trackRobustness: { eventType: ev?.type } } });
        await Promise.race([
            new Promise((resolve) => this.rawVideoTrack?.addEventListener('unmute', resolve)),
            new Promise((resolve) => setTimeout(resolve, 50)),
        ]);
        const reacquireTrack = await this.shouldReacquireTrack('video');
        DyteLogger.info('performedCheck::shouldReacquireVideoTrack', {
            actions: {
                trackRobustness: {
                    reacquireTrack,
                },
            },
        });
        if (reacquireTrack) {
            DyteLogger.info('reacquiring_video_track');
            this.removeMediaStreamTrackListeners(this.rawVideoTrack);
            await this.#localMediaUtils.repopulateAvailableDevices();
            await this.setupVideoStream(this.currentDevices.video.deviceId);
            this.addMediaStreamTrackListeners(this.rawVideoTrack);
            this.emit('VIDEO_TRACK_CHANGE');
        }
    }
    async shouldReacquireTrack(kind) {
        const workaroundWebKitBug1208516 = true || browserSpecs.isWebKitBased();
        let mediaStreamTrack;
        let wasEnabled = false;
        if (kind === 'audio') {
            mediaStreamTrack = this.rawAudioTrack;
            wasEnabled = this.audioEnabled;
        }
        else if (kind === 'video') {
            mediaStreamTrack = this.rawVideoTrack;
            wasEnabled = this.videoEnabled;
        }
        if (!mediaStreamTrack)
            return false;
        const isStopped = mediaStreamTrack.readyState === 'ended';
        const isInadvertentlyStopped = isStopped && wasEnabled && workaroundWebKitBug1208516;
        let isSilentAudio = false;
        if (kind === 'audio') {
            isSilentAudio = await checkIfAudioTrackIsSilent(this.rawAudioTrack);
        }
        return (document.visibilityState === 'visible'
            && (mediaStreamTrack.muted
                || isInadvertentlyStopped
                || isSilentAudio));
    }
    onAudioUnmute(ev) {
        DyteLogger.info('audio_track_unmuted', {
            actions: {
                trackRobustness: {
                    eventType: ev?.type,
                },
            },
        });
    }
    onVideoUnmute(ev) {
        DyteLogger.info('video_track_unmuted', {
            actions: {
                trackRobustness: {
                    eventType: ev?.type,
                },
            },
        });
    }
    removeMediaStreamTrackListeners(mediaStreamTrack) {
        DyteLogger.info(`Removing ${mediaStreamTrack.kind} listerners`);
        if (!mediaStreamTrack) {
            return undefined;
        }
        const conditionallyRestart = mediaStreamTrack.kind === 'audio'
            ? this.conditionallyRestartAudio : this.conditionallyRestartVideo;
        mediaStreamTrack.removeEventListener('ended', conditionallyRestart);
        mediaStreamTrack.removeEventListener('mute', conditionallyRestart);
        mediaStreamTrack.removeEventListener('unmute', mediaStreamTrack.kind === 'audio' ? this.onAudioUnmute : this.onVideoUnmute);
        return mediaStreamTrack;
    }
    addMediaStreamTrackListeners(mediaStreamTrack) {
        if (!mediaStreamTrack) {
            return null;
        }
        DyteLogger.info(`adding_${mediaStreamTrack.kind}_stream_listerners`);
        const isAudioTrack = mediaStreamTrack.kind === 'audio';
        const conditionallyRestart = isAudioTrack
            ? this.conditionallyRestartAudio : this.conditionallyRestartVideo;
        mediaStreamTrack.addEventListener('ended', async () => {
            await conditionallyRestart();
            const wasTrackEnabled = isAudioTrack ? this.audioEnabled : this.videoEnabled;
            const track = isAudioTrack ? this.audioTrack : this.videoTrack;
            const eventToEmit = isAudioTrack ? 'FORCE_MUTE_AUDIO' : 'FORCE_MUTE_VIDEO';
            if (wasTrackEnabled
                && !(track
                    && track.readyState === 'live'
                    && track.enabled)) {
                DyteLogger.info(`LocalMediaHandler::trackEnded::Failed to restart ${mediaStreamTrack.kind} track`);
                this.emit(eventToEmit);
            }
        });
        mediaStreamTrack.addEventListener('mute', conditionallyRestart);
        mediaStreamTrack.addEventListener('unmute', isAudioTrack ? this.onAudioUnmute : this.onVideoUnmute);
        return mediaStreamTrack;
    }
    async notifyIfTrackSilent() {
        if (this.audioEnabled && this.audioTrack && this.audioTrack.readyState !== 'ended' && this.audioTrack.enabled) {
            if ((await checkIfAudioTrackIsSilent(this.audioTrack)) === true) {
                DyteLogger.info('LocalMediaHandler:notifyIfTrackSilent:TrackSilent', {
                    media: {
                        audio: {
                            enabled: this.audioEnabled,
                            deviceId: this.audioTrack?.getSettings()?.deviceId,
                            permission: this.permissions?.audio,
                            deviceName: this.currentDevices?.audio?.label,
                            trackId: this.audioTrack?.id,
                        },
                    },
                });
                this.emit('AUDIO_TRACK_SILENT');
            }
        }
    }
    async setupAudioStream(deviceId, forceStopTrack = true) {
        if (this.audioUpdateInProgress) {
            return;
        }
        try {
            this.audioUpdateInProgress = true;
            const audioDevices = this.#localMediaUtils.getAudioDevices();
            if (!audioDevices.length) {
                return;
            }
            let audioDeviceId = deviceId;
            if (!audioDeviceId || !audioDevices.find((v) => v.deviceId === audioDeviceId)) {
                audioDeviceId = await this.getPreferredDeviceId('AUDIO');
                DyteLogger.debug('setupAudioStream::AUDIO::getPreferredDeviceId', {
                    preferredDevice: {
                        preferredDeviceId: audioDeviceId,
                        kind: 'audio',
                    },
                });
            }
            const audioConstraints = LocalMediaUtils.getAudioConstraints({ audioDeviceId });
            if (forceStopTrack) {
                this.rawAudioTrack?.stop();
                this.audioTrack?.stop();
            }
            this.rawAudioTrack = await LocalMediaUtils.getAudioTrack(audioConstraints);
            audioDeviceId = this.rawAudioTrack.getSettings().deviceId;
            if (this.currentDevices.audio?.deviceId !== audioDeviceId) {
                this.currentDevices.audio = this.#localMediaUtils.getDeviceById(audioDeviceId, 'audioinput');
                this.emit('DEVICE_CHANGE', {
                    device: this.currentDevices.audio,
                });
            }
            this.rawAudioTrack.enabled = this.audioEnabled;
            this.setAudioTrack(await this.mediaMiddlewareUtils.getTransformedAudioTrack(this.rawAudioTrack));
            this.addMediaStreamTrackListeners(this.rawAudioTrack);
            await this.#localMediaUtils.repopulateAvailableDevices();
            this.permissions.audio = 'ACCEPTED';
            callStats.mediaPermission('AUDIO', CallStatsPermissionEnum.ACCEPTED);
            callStats.selectedDevice('AUDIO', this.currentDevices.audio);
            if (audioDeviceId) {
                DyteLocalStorage.setItem('lastUsedAudioDeviceId', audioDeviceId);
            }
        }
        catch (err) {
            this.handlePermissionErrors('audio', err);
        }
        finally {
            this.audioUpdateInProgress = false;
        }
    }
    async getPreferredDeviceId(deviceType) {
        let deviceId;
        if (deviceType === 'AUDIO') {
            const audioDevices = this.#localMediaUtils.getAudioDevices();
            const lastUsedAudioDeviceId = DyteLocalStorage.getItem('lastUsedAudioDeviceId');
            DyteLogger.debug('getPreferredDeviceId::lastUsedAudioDeviceId', {
                preferredDevice: {
                    lastUsedPreferredDeviceId: lastUsedAudioDeviceId,
                    kind: 'audio',
                },
            });
            let lastUsedAudioDevice;
            if (lastUsedAudioDeviceId) {
                lastUsedAudioDevice = audioDevices.find((device) => device.deviceId === lastUsedAudioDeviceId);
            }
            if (lastUsedAudioDevice) {
                deviceId = lastUsedAudioDeviceId;
            }
            else if (!globalFlagsmith.hasFeature(FlagsmithFeatureFlags.REMOVE_OPERATIONAL_MIC)) {
                deviceId = (await this.getOperationalMicDeviceId()).deviceId;
            }
            if (!deviceId) {
                deviceId = audioDevices[0]?.deviceId;
            }
        }
        if (deviceType === 'VIDEO') {
            const lastUsedVideoDeviceId = DyteLocalStorage.getItem('lastUsedVideoDeviceId');
            DyteLogger.debug('getPreferredDeviceId::lastUsedVideoDeviceId', {
                preferredDevice: {
                    kind: 'video',
                    lastUsedPreferredDeviceId: lastUsedVideoDeviceId,
                },
            });
            const videoDevices = this.#localMediaUtils.getVideoDevices();
            let lastUsedVideoDevice;
            if (lastUsedVideoDeviceId) {
                lastUsedVideoDevice = videoDevices.find((device) => device.deviceId === lastUsedVideoDeviceId);
            }
            if (lastUsedVideoDevice) {
                deviceId = lastUsedVideoDeviceId;
            }
            else {
                deviceId = (await this.getOperationalWebcamDeviceId()).deviceId;
            }
            if (!deviceId) {
                deviceId = videoDevices[0]?.deviceId;
            }
        }
        return deviceId;
    }
    async setupVideoStream(deviceId, forceStopTrack = true) {
        if (this.videoUpdateInProgress) {
            return;
        }
        try {
            this.videoUpdateInProgress = true;
            const videoDevices = this.#localMediaUtils.getVideoDevices();
            if (!videoDevices.length) {
                return;
            }
            let videoDeviceId = deviceId;
            if (!videoDeviceId || !videoDevices.find((v) => v.deviceId === videoDeviceId)) {
                videoDeviceId = await this.getPreferredDeviceId('VIDEO');
                DyteLogger.debug('setupVideoStream::VIDEO::getPreferredDeviceId', {
                    preferredDevice: {
                        preferredDeviceId: videoDeviceId,
                        kind: 'video',
                    },
                });
            }
            if (forceStopTrack) {
                this.videoTrack?.stop();
            }
            if (this.videoEnabled) {
                const videoConstraints = this.#constraintsBuilder.getVideoConstraints(videoDeviceId);
                this.rawVideoTrack = await LocalMediaUtils.getVideoTrack(videoConstraints);
                videoDeviceId = this.rawVideoTrack.getSettings().deviceId;
                this.setVideoTrack(await this.mediaMiddlewareUtils.getTransformedVideoTrack(this.rawVideoTrack));
                this.addMediaStreamTrackListeners(this.rawVideoTrack);
            }
            await this.#localMediaUtils.repopulateAvailableDevices();
            if (this.currentDevices.video?.deviceId !== videoDeviceId) {
                this.currentDevices.video = this.#localMediaUtils.getDeviceById(videoDeviceId, 'videoinput');
                this.emit('DEVICE_CHANGE', {
                    device: this.currentDevices.video,
                });
            }
            this.permissions.video = 'ACCEPTED';
            callStats.mediaPermission('VIDEO', CallStatsPermissionEnum.ACCEPTED);
            callStats.selectedDevice('VIDEO', this.currentDevices.video);
            if (videoDeviceId) {
                DyteLocalStorage.setItem('lastUsedVideoDeviceId', videoDeviceId);
            }
        }
        catch (err) {
            this.handlePermissionErrors('video', err);
        }
        finally {
            this.videoUpdateInProgress = false;
        }
    }
    async setupScreenShareStreams() {
        if (this.screenShareUpdateInProgress) {
            return;
        }
        const constraints = this.#constraintsBuilder.getScreenShareConstraints();
        if (globalFlagsmith.hasFeature(FlagsmithFeatureFlags.SCREENSHARE_MAX_DIMENSIONS)) {
            constraints.video.width.max = window.screen.width;
            constraints.video.height.max = window.screen.height;
        }
        try {
            this.screenShareUpdateInProgress = true;
            const screenShareTracks = await LocalMediaUtils.getScreenShareTracks(constraints);
            this.setScreenShareTracks(screenShareTracks);
        }
        catch (err) {
            this.handlePermissionErrors('screenshare', new LocalMediaException(err.name, err.message, constraints));
            throw new DyteError(err.message);
        }
        finally {
            this.screenShareUpdateInProgress = false;
        }
    }
    async setupSpeaker(deviceId) {
        const speakerDevices = this.#localMediaUtils.getSpeakerDevices();
        if (!speakerDevices.length) {
            return;
        }
        const speakerDeviceId = deviceId ?? speakerDevices[0].deviceId;
        if (this.currentDevices.speaker?.deviceId !== speakerDeviceId) {
            this.currentDevices.speaker = this.#localMediaUtils.getDeviceById(speakerDeviceId, 'audiooutput');
            callStats.selectedDevice('SPEAKER', this.currentDevices.speaker);
            this.emit('DEVICE_CHANGE', {
                device: this.currentDevices.speaker,
            });
        }
        document.querySelectorAll('audio').forEach(async (audioElem) => {
            if (typeof audioElem.sinkId !== 'undefined'
                && this.currentDevices.speaker.deviceId
                && audioElem.sinkId !== this.currentDevices.speaker.deviceId) {
                try {
                    await audioElem.setSinkId(this.currentDevices.speaker.deviceId);
                }
                catch {
                }
            }
        });
    }
    async getOperationalWebcamDeviceId() {
        const videoDevices = this.#localMediaUtils.getVideoDevices();
        if (!videoDevices.length) {
            return { isOperational: false, deviceId: null };
        }
        localMediaExecutionContext.setEmitMediaPermissionEvent(false);
        const exceptions = [];
        const operationalDeviceId = await videoDevices.reduce(async (promisedActive, device) => {
            const active = await promisedActive;
            if (active !== null)
                return active;
            const videoConstraints = this.#constraintsBuilder.getVideoConstraints(device.deviceId);
            try {
                const videoTrack = await LocalMediaUtils.getVideoTrack(videoConstraints);
                videoTrack.stop();
                return device.deviceId;
            }
            catch (error) {
                DyteLogger.error('getOperationalWebcamDeviceId::could_not_acquire_video_device', { error, constraints: videoConstraints });
                exceptions.push({ exception: error, constraints: videoConstraints });
            }
            return active;
        }, Promise.resolve(null));
        localMediaExecutionContext.setEmitMediaPermissionEvent(true);
        if (!operationalDeviceId
            && exceptions.length > 0
            && exceptions.length === videoDevices.length) {
            const { exception, constraints } = exceptions[0];
            throw new LocalMediaException(exception.name, exception.message, constraints);
        }
        return operationalDeviceId
            ? { isOperational: true, deviceId: operationalDeviceId }
            : { isOperational: false, deviceId: videoDevices[0].deviceId };
    }
    async getOperationalMicDeviceId() {
        const audioDevices = this.#localMediaUtils.getAudioDevices();
        if (!audioDevices.length) {
            return { isOperational: false, deviceId: null };
        }
        const exceptions = [];
        localMediaExecutionContext.setEmitMediaPermissionEvent(false);
        const operationalDevice = await audioDevices.reduce(async (promisedActive, device) => {
            const active = await promisedActive;
            if (active !== null)
                return active;
            const audioConstraints = LocalMediaUtils.getAudioConstraints({
                audioDeviceId: device.deviceId,
            });
            try {
                const audioTrack = await LocalMediaUtils.getAudioTrack(audioConstraints);
                const isSilent = await checkIfAudioTrackIsSilent(audioTrack);
                audioTrack?.stop();
                if (!isSilent) {
                    return device;
                }
            }
            catch (error) {
                DyteLogger.error('getOperationalMicDeviceId::could_not_acquire_audio_device', { error, constraints: audioConstraints });
                exceptions.push({ exception: error, constraints: audioConstraints });
            }
            return active;
        }, Promise.resolve(null));
        localMediaExecutionContext.setEmitMediaPermissionEvent(true);
        if (!operationalDevice
            && exceptions.length > 0
            && exceptions.length === audioDevices.length) {
            const { exception, constraints } = exceptions[0];
            throw new LocalMediaException(exception.name, exception.message, constraints);
        }
        return operationalDevice
            ? { isOperational: true, deviceId: operationalDevice.deviceId }
            : { isOperational: false, deviceId: audioDevices[0].deviceId };
    }
    async setupStreams({ audio, video }) {
        const constraints = {};
        if (!this.currentDevices) {
            this.currentDevices = {
                audio: undefined,
                video: undefined,
                speaker: undefined,
            };
        }
        try {
            if (audio && !this.audioUpdateInProgress) {
                const audioDevices = this.#localMediaUtils.getAudioDevices();
                if (audioDevices.length !== 0) {
                    const audioDeviceId = await this.getPreferredDeviceId('AUDIO');
                    DyteLogger.info('setupStreams::AUDIO::getPreferredDeviceId', {
                        preferredDevice: {
                            preferredDeviceId: audioDeviceId,
                            kind: 'audio',
                        },
                    });
                    const audioConstraints = LocalMediaUtils.getAudioConstraints({ audioDeviceId });
                    constraints.audio = audioConstraints.audio;
                }
            }
            if (video && !this.videoUpdateInProgress) {
                const videoDevices = this.#localMediaUtils.getVideoDevices();
                if (videoDevices.length !== 0) {
                    const videoDeviceId = await this.getPreferredDeviceId('VIDEO');
                    DyteLogger.info('setupStreams::VIDEO::getPreferredDeviceId', {
                        preferredDevice: {
                            preferredDeviceId: videoDeviceId,
                            kind: 'video',
                        },
                    });
                    const videoConstraints = this.#constraintsBuilder.getVideoConstraints(videoDeviceId);
                    constraints.video = videoConstraints.video;
                }
            }
            if (Object.keys(constraints)?.length === 0) {
                this.audioEnabled = audio ?? this.audioEnabled;
                this.videoEnabled = video ?? this.videoEnabled;
                this.audioUpdateInProgress = false;
                this.videoUpdateInProgress = false;
                return;
            }
            const { audioTrack, videoTrack, } = await LocalMediaUtils.getAudioAndVideoTrack(constraints);
            if (audio && audioTrack) {
                this.audioTrack = audioTrack;
                this.rawAudioTrack = audioTrack;
                this.permissions.audio = 'ACCEPTED';
                this.currentDevices.audio = this.#localMediaUtils.getDeviceById(audioTrack.getSettings().deviceId, 'audioinput');
                DyteLocalStorage.setItem('lastUsedAudioDeviceId', audioTrack.getSettings().deviceId);
            }
            if (video && videoTrack) {
                this.videoTrack = videoTrack;
                this.rawVideoTrack = videoTrack;
                this.permissions.video = 'ACCEPTED';
                this.currentDevices.video = this.#localMediaUtils.getDeviceById(videoTrack.getSettings().deviceId, 'videoinput');
                DyteLocalStorage.setItem('lastUsedVideoDeviceId', videoTrack.getSettings().deviceId);
            }
            await this.#localMediaUtils.repopulateAvailableDevices();
        }
        catch (err) {
            if (err.name === 'NotAllowedError') {
                if (audio)
                    await this.setupAudioStream();
                if (video)
                    await this.setupVideoStream();
            }
        }
        this.audioEnabled = !!this.audioTrack;
        this.videoEnabled = !!this.videoTrack;
        this.screenShareEnabled = false;
        this.audioUpdateInProgress = false;
        this.videoUpdateInProgress = false;
        await this.setupSpeaker();
    }
    stopAudioTrack() {
        if (this.audioUpdateInProgress) {
            return;
        }
        this.audioUpdateInProgress = true;
        this.audioTrack?.stop();
        this.rawAudioTrack?.stop();
        this.audioEnabled = false;
        this.audioUpdateInProgress = false;
    }
    stopVideoTrack() {
        if (this.videoUpdateInProgress) {
            return;
        }
        this.videoUpdateInProgress = true;
        this.videoTrack?.stop();
        this.rawVideoTrack?.stop();
        this.videoEnabled = false;
        this.videoUpdateInProgress = false;
    }
    stopScreenShareTracks(tracks = {}) {
        if (this.screenShareUpdateInProgress) {
            return;
        }
        this.screenShareUpdateInProgress = true;
        const { audio = true, video = true } = tracks;
        if (audio) {
            this.screenShareTracks?.audio?.stop();
        }
        if (video) {
            this.screenShareTracks?.video?.stop();
        }
        this.screenShareEnabled = false;
        this.screenShareUpdateInProgress = false;
    }
    removeAudioTrack() {
        this.stopAudioTrack();
        this.audioTrack = undefined;
        this.rawAudioTrack = undefined;
    }
    removeVideoTrack() {
        this.stopVideoTrack();
        this.videoTrack = undefined;
        this.rawVideoTrack = undefined;
    }
    removeScreenShareTracks(tracks) {
        this.screenShareTracks.video?.removeEventListener('ended', this.onScreenShareEnded);
        this.stopScreenShareTracks(tracks);
        this.screenShareTracks = {
            audio: undefined,
            video: undefined,
        };
    }
    removeAllTracks() {
        this.removeAudioTrack();
        this.removeVideoTrack();
        this.removeScreenShareTracks({
            audio: !!this.screenShareTracks.audio,
            video: !!this.screenShareTracks.video,
        });
    }
    setAudioTrack(audioTrack) {
        if (audioTrack === this.audioTrack) {
            return;
        }
        if (audioTrack === undefined) {
            this.stopAudioTrack();
        }
        this.audioTrack = audioTrack;
        if (this.audioTrack) {
            this.audioTrack.enabled = this.audioEnabled;
        }
    }
    setVideoTrack(videoTrack) {
        if (videoTrack === this.videoTrack) {
            return;
        }
        if (videoTrack === undefined) {
            this.stopVideoTrack();
        }
        this.videoTrack = videoTrack;
    }
    setScreenShareTracks(tracks) {
        const { audio, video } = tracks;
        if (!audio || !video) {
            this.stopScreenShareTracks({ audio: !!audio, video: !!video });
        }
        this.screenShareTracks = tracks;
        this.screenShareTracks.video?.addEventListener('ended', this.onScreenShareEnded.bind(this));
    }
    onScreenShareEnded() {
        this.emit('SCREENSHARE_ENDED');
    }
    disableAudio() {
        this.audioEnabled = false;
        if (this.audioTrack) {
            this.audioTrack.enabled = this.audioEnabled;
        }
        if (this.rawAudioTrack) {
            this.rawAudioTrack.enabled = this.audioEnabled;
        }
    }
    async enableAudio() {
        if (this.permissions.audio === 'DENIED') {
            this.audioEnabled = false;
            return;
        }
        try {
            if (!this.audioTrack || this.audioTrack.readyState === 'ended') {
                await this.setupAudioStream(this.currentDevices.audio?.deviceId);
            }
            if (!this.audioTrack || !this.rawAudioTrack) {
                this.audioEnabled = false;
                DyteLogger.error('LocalMediaHandler::enableAudio:Setting up audio stream failed while enabling audio', {
                    debuggingHint: 'Refer to SelfController::mediaPermissionError log.',
                });
                return;
            }
            this.audioEnabled = true;
        }
        catch (error) {
            this.audioEnabled = false;
            this.audioTrack = undefined;
            this.rawAudioTrack = undefined;
            DyteLogger.error('LocalMediaHandler::enableAudio', { error }, true);
        }
        if (this.audioTrack) {
            this.audioTrack.enabled = true;
        }
        if (this.rawAudioTrack) {
            this.rawAudioTrack.enabled = true;
        }
        if (this.permissions.audio === 'ACCEPTED' || !this.audioEnabled)
            return;
        this.permissions.audio = 'ACCEPTED';
        SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.audio,
            kind: 'audio',
        });
    }
    async toggleAudio() {
        if (this.permissions.audio === 'DENIED') {
            this.audioEnabled = false;
            return;
        }
        try {
            if (!this.audioTrack || this.audioTrack.readyState === 'ended') {
                await this.setupAudioStream(this.currentDevices.audio?.deviceId);
            }
            if (!this.audioTrack || !this.rawAudioTrack) {
                this.audioEnabled = false;
                return;
            }
            this.audioEnabled = !this.audioEnabled;
        }
        catch (error) {
            this.audioEnabled = false;
            DyteLogger.error('LocalMediaHandler::toggleAudio', { error }, true);
        }
        if (this.audioTrack) {
            this.audioTrack.enabled = this.audioEnabled;
        }
        if (this.rawAudioTrack) {
            this.rawAudioTrack.enabled = this.audioEnabled;
        }
    }
    async toggleVideo() {
        if (this.permissions.video === 'DENIED') {
            this.videoEnabled = false;
            return;
        }
        if (this.videoEnabled) {
            this.removeVideoTrack();
            return;
        }
        this.videoEnabled = true;
        try {
            await this.setupVideoStream(this.currentDevices.video?.deviceId);
        }
        catch {
            this.videoEnabled = false;
        }
        if (this.videoTrack) {
            this.videoTrack.enabled = this.videoEnabled;
        }
        if (this.rawVideoTrack) {
            this.rawVideoTrack.enabled = this.videoEnabled;
        }
        if (this.permissions.video === 'ACCEPTED' || !this.videoEnabled)
            return;
        this.permissions.video = 'ACCEPTED';
        SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.video,
            kind: 'video',
        });
    }
    async toggleScreenShare() {
        if (this.screenShareEnabled) {
            this.removeScreenShareTracks({
                audio: !!this.screenShareTracks.audio,
                video: !!this.screenShareTracks.video,
            });
            return;
        }
        try {
            await this.setupScreenShareStreams();
            this.screenShareEnabled = true;
            this.permissions.screenshare = 'ACCEPTED';
            SessionStore.emit(SessionEvents.MEDIA_PERMISSION_UPDATE, {
                message: this.permissions.screenshare,
                kind: 'screenshare',
            });
        }
        catch {
            this.screenShareEnabled = false;
        }
    }
    getAllDevices() {
        return this.#localMediaUtils.availableDevices;
    }
    getDeviceById(deviceId, kind) {
        return this.#localMediaUtils.getDeviceById(deviceId, kind);
    }
    getAudioDevices() {
        return this.#localMediaUtils.getAudioDevices();
    }
    getVideoDevices() {
        return this.#localMediaUtils.getVideoDevices();
    }
    getSpeakerDevices() {
        return this.#localMediaUtils.getSpeakerDevices();
    }
    async onDeviceChange(changedDevices, forceDeviceChange) {
        changedDevices?.added?.forEach(async (addedDevice) => {
            if (addedDevice
                && (forceDeviceChange || !isVirtualDevice(addedDevice))) {
                if (addedDevice.kind === 'audioinput') {
                    await this.setupAudioStream(addedDevice.deviceId);
                    this.emit('AUDIO_TRACK_CHANGE');
                }
                else if (addedDevice.kind === 'videoinput') {
                    await this.setupVideoStream(addedDevice.deviceId);
                    this.emit('VIDEO_TRACK_CHANGE');
                }
                else if (addedDevice.kind === 'audiooutput') {
                    await this.setupSpeaker(addedDevice.deviceId);
                }
            }
        });
        changedDevices?.removed?.forEach(async (removedDevice) => {
            if (removedDevice) {
                if (globalFlagsmith.hasFeature(FlagsmithFeatureFlags.DEVICE_REMOVE_EXP)
                    || !browserSpecs.isChromiumBased()) {
                    if (removedDevice.kind === 'audioinput' && removedDevice.deviceId === this.currentDevices.audio?.deviceId) {
                        await this.setupAudioStream();
                        this.emit('AUDIO_TRACK_CHANGE');
                    }
                    else if (removedDevice.kind === 'videoinput' && removedDevice.deviceId === this.currentDevices.video?.deviceId) {
                        await this.setupVideoStream();
                        this.emit('VIDEO_TRACK_CHANGE');
                    }
                }
                if (removedDevice.kind === 'audiooutput' && removedDevice.deviceId === this.currentDevices.speaker?.deviceId) {
                    await this.setupSpeaker();
                }
            }
        });
    }
    async updateDevices() {
        if (browserSpecs.getName() === 'firefox')
            return;
        const mic = 'microphone';
        const camera = 'camera';
        const micPermissions = await navigator?.permissions?.query({ name: mic });
        const cameraPermissions = await navigator?.permissions?.query({ name: camera });
        const update = () => {
            this.#localMediaUtils.repopulateAvailableDevices();
        };
        if (micPermissions) {
            micPermissions.onchange = update;
        }
        if (cameraPermissions) {
            cameraPermissions.onchange = update;
        }
    }
    static async init(presetMediaConstraints) {
        const localMediaUtils = await LocalMediaUtils.init();
        const localMediaHandler = new LocalMediaHandlerDeprecated(localMediaUtils, presetMediaConstraints);
        const mediaMiddlewareUtils = new MediaMiddlewareUtils(localMediaHandler);
        localMediaHandler.mediaMiddlewareUtils = mediaMiddlewareUtils;
        return localMediaHandler;
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    async removeDocumentEventListeners() {
        document.removeEventListener('visibilitychange', this.onVisibilityChange);
    }
    addAudioMiddleware(audioMiddleware) {
        return this.mediaMiddlewareUtils.addAudioMiddleware(audioMiddleware);
    }
    removeAudioMiddleware(audioMiddleware) {
        return this.mediaMiddlewareUtils.removeAudioMiddleware(audioMiddleware);
    }
    addVideoMiddleware(videoMiddleware) {
        return this.mediaMiddlewareUtils.addVideoMiddleware(videoMiddleware);
    }
    removeVideoMiddleware(videoMiddleware) {
        return this.mediaMiddlewareUtils.removeVideoMiddleware(videoMiddleware);
    }
    async enableVideo() {
        await this.toggleVideo();
    }
    async disableVideo() {
        await this.toggleVideo();
    }
    async enableScreenShare() {
        await this.toggleScreenShare();
    }
    async disableScreenShare() {
        await this.toggleScreenShare();
    }
    getCurrentDevices() {
        return this.currentDevices;
    }
    destruct() {
        this.mediaMiddlewareUtils.terminateMiddlewareWebWorker();
        this.#localMediaUtils.destruct();
        this.removeAllTracks();
        this.removeAllListeners();
    }
}
__decorate([
    DyteTelemetry.trace('OldMediaHandler.shouldReacquireTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "shouldReacquireTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.removeMediaStreamTrackListeners'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "removeMediaStreamTrackListeners", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.addMediaStreamTrackListeners'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "addMediaStreamTrackListeners", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setupAudioStream'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean]),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "setupAudioStream", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.getPreferredDeviceId'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "getPreferredDeviceId", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setupVideoStream'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean]),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "setupVideoStream", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setupScreenShareStreams'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "setupScreenShareStreams", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setupSpeaker'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "setupSpeaker", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.getOperationalWebcamDeviceId'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "getOperationalWebcamDeviceId", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.getOperationalMicDeviceId'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "getOperationalMicDeviceId", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setupStreams'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "setupStreams", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.stopAudioTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "stopAudioTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.stopVideoTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "stopVideoTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.stopScreenShareTracks'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "stopScreenShareTracks", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.removeAudioTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "removeAudioTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.removeVideoTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "removeVideoTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.removeScreenShareTracks'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "removeScreenShareTracks", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.removeAllTracks'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "removeAllTracks", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setAudioTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "setAudioTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setVideoTrack'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MediaStreamTrack]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "setVideoTrack", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.setScreenShareTracks'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "setScreenShareTracks", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler::disableAudio'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LocalMediaHandlerDeprecated.prototype, "disableAudio", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler::enableAudio'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "enableAudio", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.toggleAudio'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "toggleAudio", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.toggleVideo'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "toggleVideo", null);
__decorate([
    DyteTelemetry.trace('OldMediaHandler.toggleScreenShare'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LocalMediaHandlerDeprecated.prototype, "toggleScreenShare", null);
