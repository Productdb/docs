var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
type GetChatMessagesResponse = any; type  = any; 
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import DyteChat, { messageTypes } from '../client/DyteChat';
import DyteLogger from '../client/internals/DyteLogger';
import { ChatMessageType } from '../socketService/ChatSocketHandler';
import { chatEvents } from '../socketService/socketEvents';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import { FlagsmithFeatureFlags } from '../utils/flags';
import DyteTelemetry from '../utils/opentelemetry';
import { getRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
import { getOverride } from '../utils/constants';
export default class ChatController {
    chat;
    chatSocketHandler;
    self;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    get roomJoined() {
        return this.#roomNodeClient?.roomJoined === true;
    }
    #socketServerName;
    constructor(chatSocketHandler, socketServerName, self, participants) {
        this.chatSocketHandler = chatSocketHandler;
        this.#socketServerName = socketServerName;
        this.chat = new DyteChat(chatSocketHandler, socketServerName, self, participants);
        this.self = self;
        this.setupEvents();
    }
    static async init(chatSocketHandler, self, participants, capabilities) {
        const flagsmithChatSocketServer = flagsmith.getValue(FlagsmithFeatureFlags.CHAT_SOCKET_SERVER);
        DyteLogger.debug(`Received flagsmith chat_socket_server: ${flagsmithChatSocketServer}`);
        const socketServerName = (getOverride('chat_socket_server') === 'socket-service'
            || flagsmithChatSocketServer === 'socket-service'
            || capabilities.includes('HIVE'))
            ? 'socket-service' : 'room-node';
        DyteLogger.info(`Using socket server :: ${socketServerName} for chat`);
        return new ChatController(chatSocketHandler, socketServerName, self, participants);
    }
    static formatMessage(message) {
        return {
            ...message,
            time: new Date(message.time),
            type: messageTypes[message.type],
        };
    }
    static formatSocketServiceMessage(sockMessage) {
        const time = sockMessage.createdAt * 1000;
        const chatMessage = {
            displayName: sockMessage.displayName,
            id: sockMessage.chatId,
            time,
            timeMs: sockMessage.createdAtMs,
            type: sockMessage.payloadType,
            isEdited: sockMessage.isEdited,
            userId: sockMessage.userId,
            targetUserIds: sockMessage.targetUserIds,
            message: '',
            link: '',
            name: '',
            size: 0,
        };
        switch (chatMessage.type) {
            case ChatMessageType.TEXT: {
                chatMessage.message = sockMessage.payload;
                break;
            }
            case ChatMessageType.IMAGE: {
                chatMessage.link = sockMessage.payload;
                break;
            }
            case ChatMessageType.FILE: {
                const { link, name, size } = JSON.parse(sockMessage.payload);
                chatMessage.link = link;
                chatMessage.name = name;
                chatMessage.size = size;
                break;
            }
            default: {
                break;
            }
        }
        return ChatController.formatMessage(chatMessage);
    }
    async getChatMessages() {
        if (this.self.config.viewType === 'LIVESTREAM' || flagsmith.hasFeature(FlagsmithFeatureFlags.FEAT_PAGINATED_CHAT))
            return;
        if (this.#socketServerName === 'socket-service') {
            const protoChatMessages = await this.chatSocketHandler.getChatMessages();
            if (!protoChatMessages?.payload)
                return;
            const chatMessages = GetChatMessagesResponse.fromBinary(protoChatMessages.payload).messages;
            this.chat.messages = chatMessages.map((m) => ChatController
                .formatSocketServiceMessage(m));
            return;
        }
        if (!this.roomJoined) {
            DyteLogger.error('ChatController.getChatMessages.RoomNodeClientSocketUsed_WithoutRoomJoin');
            return;
        }
        const { messages } = (await this.#roomNodeClient.getChatMessages())
            .payload;
        this.chat.messages = messages.filter((message) => messageTypes[message.type] !== 'poll').map(ChatController.formatMessage);
    }
    setupEvents() {
        if (this.#socketServerName === 'socket-service') {
            SessionStore.on(SessionEvents.SOCKET_SERVICE_ROOM_JOINED, () => {
                this.getChatMessages();
            });
        }
        else {
            SessionStore.onAsync(SessionEvents.ROOM_JOINED, async () => {
                await this.getChatMessages();
            });
        }
        this.chatSocketHandler.on(chatEvents.sendMessageToRoom, (socketMessage) => {
            const message = ChatController
                .formatSocketServiceMessage(socketMessage.message);
            this.chat.messages = [...this.chat.messages, message];
            this.chat.emit('chatUpdate', {
                action: 'add',
                message,
                messages: this.chat.messages,
            });
        });
        this.chatSocketHandler.on(chatEvents.sendMessageToPeers, (socketMessage) => {
            const message = ChatController
                .formatSocketServiceMessage(socketMessage.message);
            this.chat.messages = [...this.chat.messages, message];
            this.chat.emit('chatUpdate', {
                action: 'add',
                message,
                messages: this.chat.messages,
            });
        });
        this.chatSocketHandler.on(chatEvents.editMessage, (socketMessage) => {
            const message = ChatController
                .formatSocketServiceMessage(socketMessage.message);
            const index = this.chat.messages.findIndex((m) => m.id === message.id);
            if (index === -1)
                return;
            this.chat.messages[index] = message;
            this.chat.emit('chatUpdate', {
                action: 'edit',
                message,
                messages: this.chat.messages,
            });
        });
        this.chatSocketHandler.on(chatEvents.deleteMessage, (socketMessage) => {
            const index = this.chat.messages
                .findIndex((m) => m.id === socketMessage.chatId);
            if (index === -1)
                return;
            const [message] = this.chat.messages.splice(index, 1);
            this.chat.emit('chatUpdate', {
                action: 'delete',
                message,
                messages: this.chat.messages,
            });
        });
        SessionStore.on(SessionEvents.NEW_CHAT_MESSAGE, (payload) => {
            if (messageTypes[payload?.type] === 'poll')
                return;
            const message = ChatController.formatMessage(payload);
            this.chat.messages = [...this.chat.messages, message];
            this.chat.emit('chatUpdate', {
                action: 'add',
                message,
                messages: this.chat.messages,
            });
        });
        SessionStore.on(SessionEvents.PIN_CHAT_MESSAGE, async (payload) => {
            const message = ChatController.formatMessage(payload);
            const index = this.chat.messages.findIndex((msg) => msg.id === message.id);
            this.chat.messages[index] = message;
            this.chat.emit('pinMessage', {
                message,
                messages: this.chat.messages,
            });
        });
        SessionStore.on(SessionEvents.UNPIN_CHAT_MESSAGE, async (payload) => {
            const message = ChatController.formatMessage(payload);
            const index = this.chat.messages.findIndex((msg) => msg.id === message.id);
            this.chat.messages[index] = message;
            this.chat.emit('unpinMessage', {
                message,
                messages: this.chat.messages,
            });
        });
    }
}
__decorate([
    DyteTelemetry.trace('ChatController.setupEvents'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ChatController.prototype, "setupEvents", null);
