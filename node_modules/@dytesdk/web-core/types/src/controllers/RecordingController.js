var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import DyteRecording from '../client/DyteRecording';
import DyteLogger from '../client/internals/DyteLogger';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import DyteTelemetry from '../utils/opentelemetry';
export default class RecordingController {
    recording;
    constructor(self) {
        this.recording = new DyteRecording(self);
        this.setupEvents();
    }
    setupEvents() {
        SessionStore.on(SessionEvents.HIVE_RECORDING_STARTED, (peerId) => {
            this.recording.recordingPeerId = peerId;
            this.recording.setRecordingState('RECORDING');
        });
        SessionStore.on(SessionEvents.HIVE_RECORDING_STOPPED, () => {
            this.recording.recordingPeerId = undefined;
            this.recording.setRecordingState('IDLE');
        });
        SessionStore.on(SessionEvents.PEER_JOINED, async (p) => {
            if (p.flags?.recorder) {
                this.recording.recordingPeerId = p.id;
                this.recording.setRecordingState('RECORDING');
            }
        });
        SessionStore.on(SessionEvents.PEER_CLOSED, (p) => {
            if (p.id === this.recording.recordingPeerId) {
                this.recording.recordingPeerId = undefined;
                this.recording.setRecordingState('IDLE');
            }
        });
        SessionStore.onAsync(SessionEvents.ROOM_JOINED, async (payload) => {
            DyteLogger.debug('[ROOM_JOINED] resolved request to fetch recordings.');
            const recordingPeers = payload.peers?.filter((p) => !!p.flags?.recorder);
            if (!recordingPeers.length) {
                this.recording.recordingPeerId = undefined;
                this.recording.setRecordingState('IDLE');
            }
            else {
                this.recording.recordingPeerId = (recordingPeers && recordingPeers[0]?.id);
                this.recording.setRecordingState('RECORDING');
            }
        });
        SessionStore.on(SessionEvents.RECORDING_STARTED, () => {
            this.recording.setRecordingState('RECORDING');
        });
        SessionStore.on(SessionEvents.RECORDING_STOPPED, () => {
            this.recording.recordingId = undefined;
            this.recording.recordingPeerId = undefined;
            this.recording.setRecordingState('IDLE');
        });
    }
}
__decorate([
    DyteTelemetry.trace('RecordingController.setupEvents'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], RecordingController.prototype, "setupEvents", null);
