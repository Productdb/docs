var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import DytePlugin, { localPluginEvents } from '../client/DytePlugin';
import DytePlugins from '../client/DytePlugins';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import { getAPIClient } from '../api';
import DyteTelemetry from '../utils/opentelemetry';
import { chatEvents, pluginEvents } from '../socketService/socketEvents';
import { FlagsmithFeatureFlags } from '../utils/flags';
import ChatController from './ChatController';
import DyteLogger from '../client/internals/DyteLogger';
import { getRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
export default class PluginController {
    plugins;
    #pluginSocketHandler;
    #socketServerName;
    #chatSocketHandler;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    get roomJoined() {
        return this.#roomNodeClient?.roomJoined === true;
    }
    constructor(pluginSocketHandler, chatSocketHandler, socketServerName, plugins) {
        this.#pluginSocketHandler = pluginSocketHandler;
        this.#chatSocketHandler = chatSocketHandler;
        this.#socketServerName = socketServerName;
        this.plugins = plugins;
        this.setupEvents();
    }
    static async init(pluginSocketHandler, chatSocketHandler, chat, self, participants, capabilities) {
        const APIClient = getAPIClient();
        const flagsmithPluginSocketServer = flagsmith.getValue(FlagsmithFeatureFlags.PLUGIN_SOCKET_SERVER);
        const receivedPlugins = await APIClient.getPlugins(flagsmithPluginSocketServer);
        DyteLogger.debug(`Received flagsmith plugin_socket_server:: ${flagsmithPluginSocketServer}`);
        const socketServerName = (flagsmithPluginSocketServer === 'socket-service'
            || capabilities.includes('HIVE'))
            ? 'socket-service' : 'room-node';
        DyteLogger.info(`Using socket server ${socketServerName} for plugin`);
        const plugins = new DytePlugins();
        receivedPlugins.forEach((p) => {
            const plugin = new DytePlugin(p, pluginSocketHandler, socketServerName, self, participants, chat);
            plugins.all.add(plugin);
        });
        if (self.config.isV2 === false) {
            self.config.setDisabledPlugins(plugins.all.toArray().map((plugin) => plugin.id));
        }
        return new PluginController(pluginSocketHandler, chatSocketHandler, socketServerName, plugins);
    }
    async getRoomPlugins() {
        if (this.#socketServerName === 'socket-service') {
            const { plugins } = await this.#pluginSocketHandler.getActivePlugins();
            await Promise.all(plugins.map((plugin) => this.enablePlugin({
                id: plugin.pluginId,
                enabledBy: plugin.enabledBy,
            })));
            return;
        }
        if (!this.roomJoined) {
            DyteLogger.error('PluginController.getRoomPlugins.RoomNodeClientSocketUsed_WithoutRoomJoin');
            return;
        }
        const { payload } = await this.#roomNodeClient.getRoomState();
        await Promise.all(payload.roomState.plugins.map((plugin) => this.enablePlugin(plugin)));
    }
    async enablePlugin({ id, enabledBy }) {
        const plugin = this.plugins.all.get(id);
        if (!plugin) {
            return;
        }
        await plugin.activateForSelf();
        plugin.enabledBy = enabledBy;
    }
    async disablePlugin({ id }) {
        const plugin = this.plugins.all.get(id);
        if (!plugin) {
            return;
        }
        plugin.deactivateForSelf();
    }
    sendIframeEventOld(event, payload) {
        const { id } = payload;
        const plugin = this.plugins.all.get(id);
        if (!plugin)
            return;
        plugin.sendIframeEvent({ type: event, payload });
    }
    sendIframeEvent(event, pluginId, uuid, payload) {
        const plugin = this.plugins.all.get(pluginId);
        if (!pluginId)
            return;
        plugin.sendIframeEvent({ type: event, uuid, payload });
    }
    broadcastIframeEventOld(event, payload) {
        this.plugins.active.forEach((plugin) => {
            this.sendIframeEventOld(event, { ...payload, id: plugin.id });
        });
    }
    broadcastIframeEvent(event, payload) {
        this.plugins.active.forEach((plugin) => {
            this.sendIframeEvent(event, plugin.id, '', payload);
        });
    }
    setupEvents() {
        this.plugins.all.on('stateUpdate', ({ active, id }) => {
            if (active) {
                this.plugins.active.add(this.plugins.all.get(id));
                return;
            }
            this.plugins.active.delete(id);
        });
        SessionStore.onAsync(SessionEvents.ROOM_JOINED, async () => {
            await this.getRoomPlugins();
            DyteLogger.debug('[ROOM_JOINED] resolved request to fetch plugins.');
        });
        if (this.#socketServerName === 'socket-service') {
            this.#pluginSocketHandler.on(pluginEvents.addPlugin, async (plugin) => {
                const id = plugin.pluginId;
                if (this.plugins.all.get(id)?.active) {
                    return;
                }
                await this.enablePlugin({ id, enabledBy: plugin.enabledBy });
            });
            this.#pluginSocketHandler.on(pluginEvents.removePlugin, async (plugin) => {
                const id = plugin.pluginId;
                if (!this.plugins.all.get(id)?.active) {
                    return;
                }
                await this.disablePlugin({ id });
            });
            [
                pluginEvents.enablePluginForPeers,
                pluginEvents.enablePluginForRoom,
            ].forEach((event) => {
                this.#pluginSocketHandler.on(event, async (plugin, id) => {
                    this.sendIframeEvent(event, plugin.pluginId, id, {
                        enabledBy: plugin.enabledBy,
                    });
                });
            });
            [
                pluginEvents.disablePluginForPeers,
                pluginEvents.disablePluginForRoom,
            ].forEach((event) => {
                this.#pluginSocketHandler.on(event, async (plugin, id) => {
                    this.sendIframeEvent(event, plugin.pluginId, id, {
                        disabledBy: plugin.disabledBy,
                    });
                });
            });
            [
                pluginEvents.customPluginEventToPeers,
                pluginEvents.customPluginEventToRoom,
            ].forEach((event) => {
                this.#pluginSocketHandler.on(event, async (plugin, id) => {
                    this.sendIframeEvent(event, plugin.pluginId, id, {
                        data: JSON.parse(new TextDecoder().decode(plugin.pluginData)),
                    });
                });
            });
            [
                pluginEvents.storeInsertKeys,
                pluginEvents.storeGetKeys,
                pluginEvents.storeDeleteKeys,
            ].forEach((event) => {
                this.#pluginSocketHandler.on(event, async (plugin, id) => {
                    const storeItems = plugin.storeItems
                        ?.map((storeItem) => ({
                        timestamp: storeItem.timestamp,
                        peerId: storeItem.peerId,
                        payload: JSON.parse(storeItem.payload
                            ? new TextDecoder()
                                .decode(storeItem.payload)
                            : '{}'),
                        key: storeItem.storeKey,
                    }));
                    this.sendIframeEvent(event, plugin.pluginId, id, {
                        storeName: plugin.storeName,
                        storeItems,
                    });
                });
            });
            this.#pluginSocketHandler.on(pluginEvents.storeDelete, async (plugin, id) => {
                this.sendIframeEvent(pluginEvents.storeDelete, plugin.pluginId, id, {
                    storeName: plugin.storeName,
                });
            });
            this.#chatSocketHandler.on(chatEvents.sendMessageToPeers, (socketMessage) => {
                const message = ChatController
                    ?.formatSocketServiceMessage(socketMessage.message);
                this.broadcastIframeEvent(localPluginEvents.chatMessage, { message });
            });
            this.#chatSocketHandler.on(chatEvents.sendMessageToRoom, (socketMessage) => {
                const message = ChatController
                    ?.formatSocketServiceMessage(socketMessage.message);
                this.broadcastIframeEvent(localPluginEvents.chatMessage, { message });
            });
            SessionStore.on(SessionEvents.PEER_JOINED, (payload) => {
                this.broadcastIframeEvent(localPluginEvents.peerJoined, payload);
            });
            SessionStore.on(SessionEvents.PEER_CLOSED, (payload) => {
                this.broadcastIframeEvent(localPluginEvents.peerLeft, payload);
            });
            return;
        }
        SessionStore.on(SessionEvents.ENABLE_PLUGIN, async ({ id, enabledBy }) => {
            await this.enablePlugin({ id, enabledBy });
        });
        SessionStore.on(SessionEvents.DISABLE_PLUGIN, async ({ id }) => {
            await this.disablePlugin({ id });
        });
        [
            SessionEvents.PLUGIN_DATA,
            SessionEvents.PLUGIN_EVENT,
        ].forEach((event) => {
            SessionStore.on(event, (payload) => {
                this.sendIframeEventOld(event, payload);
            });
        });
        [
            SessionEvents.PEER_JOINED,
            SessionEvents.PEER_CLOSED,
            SessionEvents.NEW_CHAT_MESSAGE,
        ].forEach((event) => {
            SessionStore.on(event, (payload) => {
                this.broadcastIframeEventOld(event, payload);
            });
        });
    }
}
__decorate([
    DyteTelemetry.trace('PluginController.setupEvents'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PluginController.prototype, "setupEvents", null);
