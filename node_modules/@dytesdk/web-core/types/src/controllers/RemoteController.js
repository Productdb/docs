import DyteError from '../client/DyteError';
import DyteRemote from '../client/DyteRemote';
import DyteRemoteRequest, { RemoteRequestType, RemoteRequestState, RemoteEventType, RemoteMouseEventTypes, RemoteUpdateType, } from '../client/DyteRemoteRequest';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
export default class RemoteController {
    remote;
    hostPeetId;
    remotePeetId;
    remoteRequestTokens;
    activeRemoteToken;
    #self;
    #participants;
    constructor(self, participants) {
        this.#self = self;
        this.#participants = participants;
        this.hostPeetId = self.id;
        this.remote = new DyteRemote(self, participants);
        this.setupEvents();
    }
    setupEvents() {
        SessionStore.on(SessionEvents.MESSAGE, (payload) => {
            if (payload.remoteRequestType === RemoteRequestType.REQUEST) {
                this.remote.incomingRequests.add(new DyteRemoteRequest({
                    requestId: payload.remoteRequestId,
                    hostPeerId: payload.hostPeerId,
                    remotePeerId: payload.remotePeerId,
                    state: RemoteRequestState.PENDING,
                }));
                this.remote.emit('remoteUpdate', {
                    payload: {
                        request: {
                            id: payload.remoteRequestId,
                            hostPeerId: payload.hostPeerId,
                            remotePeerId: payload.remotePeerId,
                        },
                    },
                    type: RemoteUpdateType.REQUEST_RECEIVED,
                });
            }
            if (payload.remoteRequestType === RemoteRequestType.ACCEPT) {
                const outgoingRequest = this.remote.outgoingRequests.get(payload.remoteRequestId);
                if (!outgoingRequest) {
                    throw new DyteError('There is no pending remote control request to accept.');
                }
                this.remote.endControl();
                outgoingRequest.state = RemoteRequestState.ACCEPTED;
                this.remote.active = new DyteRemoteRequest({
                    requestId: payload.remoteRequestId,
                    hostPeerId: payload.hostPeerId,
                    remotePeerId: payload.remotePeerId,
                    state: RemoteRequestState.ACCEPTED,
                });
                this.remote.emit('remoteUpdate', {
                    payload: {
                        request: {
                            id: payload.remoteRequestId,
                            hostPeerId: payload.hostPeerId,
                            remotePeerId: payload.remotePeerId,
                        },
                    },
                    type: RemoteUpdateType.OUTGOING_REQUEST_ACCEPTED,
                });
            }
            if (payload.remoteRequestType === RemoteRequestType.END) {
                if (this.remote.active?.id === payload.remoteRequestId) {
                    this.remote.active = null;
                }
                this.remote.emit('remoteUpdate', {
                    payload: {
                        request: {
                            id: payload.remoteRequestId,
                            hostPeerId: payload.hostPeerId,
                            remotePeerId: payload.remotePeerId,
                        },
                    },
                    type: payload.hostPeerId === this.#self.id
                        ? RemoteUpdateType.INCOMING_REQUEST_ENDED
                        : RemoteUpdateType.OUTGOING_REQUEST_ENDED,
                });
            }
            if (payload.remoteRequestType === RemoteRequestType.EVENT
                && this.remote.active
                && this.remote.active.id === payload.remoteRequestId) {
                if (window.DyteRobot) {
                    if (payload.remoteEvent.eventType === RemoteEventType.MOUSE) {
                        RemoteController.executeMouseEvent(payload.remoteEvent.mouseEvent);
                    }
                    else if (payload.remoteEvent.eventType === RemoteEventType.KEYBOARD) {
                        RemoteController.executeKeyboardEvent(payload.remoteEvent.keyboardEvent);
                    }
                }
            }
        });
        SessionStore.on(SessionEvents.PEER_CLOSED, ({ id: closedPeerId }) => {
            if ([
                this.remote?.active?.hostPeerId,
                this.remote?.active?.remotePeerId,
            ].includes(closedPeerId)) {
                this.remote.endControl();
            }
            this.remote?.incomingRequests?.toArray().forEach((req) => {
                if ([req.hostPeerId, req.remotePeerId].includes(closedPeerId)) {
                    this.remote.incomingRequests.delete(req.id);
                }
            });
            this.remote?.outgoingRequests?.toArray().forEach((req) => {
                if ([req.hostPeerId, req.remotePeerId].includes(closedPeerId)) {
                    this.remote.outgoingRequests.delete(req.id);
                }
            });
        });
    }
    static executeMouseEvent(mouseEvent) {
        const xOnThisScreen = ((window.screen.width * mouseEvent.position.x)
            / mouseEvent.boundingRect.width);
        const yOnThisScreen = ((window.screen.height * mouseEvent.position.y)
            / mouseEvent.boundingRect.height);
        const browserScreen = {
            width: window.screen.width,
            height: window.screen.height,
        };
        switch (mouseEvent.type) {
            case RemoteMouseEventTypes.LEFT_CLICK:
                window.DyteRobot.mouse.leftClick(xOnThisScreen, yOnThisScreen, browserScreen);
                break;
            case RemoteMouseEventTypes.RIGHT_CLICK:
                window.DyteRobot.mouse.rightClick(xOnThisScreen, yOnThisScreen, browserScreen);
                break;
            case RemoteMouseEventTypes.MOVE:
                window.DyteRobot.mouse.moveTo(xOnThisScreen, yOnThisScreen, browserScreen);
                break;
            default:
                break;
        }
    }
    static executeKeyboardEvent(keyboardEvent) {
        switch (keyboardEvent.type) {
            case 'keydown':
                window.DyteRobot.keyboard.press(keyboardEvent.key);
                break;
            default:
                break;
        }
    }
}
