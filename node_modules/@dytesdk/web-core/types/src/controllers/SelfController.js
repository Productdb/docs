var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
type callStats = any; 
import DyteSelf, { WebinarStageStatus } from '../client/DyteSelf';
import { SessionStore } from '../store/SessionStore';
import { SessionEvents } from '../store/SessionEvents';
import { getAPIClient } from '../api';
import { FlagsmithFeatureFlags } from '../utils/flags';
import { browserSpecs } from '../browser/BrowserCapabilities';
import { config } from '../utils/config';
import DyteTelemetry from '../utils/opentelemetry';
import RoomSocketHandler from '../socketService/RoomSocketHandler';
import constants, { getOverride, shouldConnectToSocketService } from '../utils/constants';
import MediasoupRoomNodeClient from '../roomNode/MediasoupRoomNodeClient';
import DyteLogger from '../client/internals/DyteLogger';
import { mediaErrorToCallStatEnum } from '../utils/media';
import HiveNodeClient from '../roomNode/HiveNodeClient';
import { cleanupRoomNodeClient, getRoomNodeClient, setupMediaSoupRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
import { useRoomNodeClient } from '../utils/stageHelpers';
export default class SelfController {
    self;
    authToken;
    peerId;
    #socketService;
    roomNodeSetupInProgress = false;
    get #roomNodeClient() {
        return getRoomNodeClient();
    }
    get roomJoined() {
        return this.#roomNodeClient?.roomJoined === true;
    }
    constructor(socketService, self) {
        this.#socketService = socketService;
        this.authToken = getRoomNodeClient()?.authToken ?? socketService.authToken;
        this.peerId = getRoomNodeClient()?.peerId ?? socketService.peerId;
        this.self = self;
        this.setupEvents();
    }
    static async init(socketService, userResponse, permissions, theme, presetName) {
        const APIClient = getAPIClient();
        const { isV2AuthToken } = constants;
        const self = await DyteSelf.__init__(getRoomNodeClient()?.peerId ?? socketService.peerId, constants.isV2AuthToken ? userResponse.participant
            : userResponse, permissions, theme, presetName);
        const organizationId = isV2AuthToken
            ? userResponse.participant.organizationId
            : userResponse.organizationId;
        DyteTelemetry.meetingMetadata.organizationId = organizationId;
        if (flagsmith.hasFeature(FlagsmithFeatureFlags.INTERNAL_CALL_STATS)
            && navigator.product !== 'ReactNative') {
            let ingestionLayer = flagsmith
                .getValue(FlagsmithFeatureFlags.CALLSTATS_INGESTION_LAYER);
            if (ingestionLayer && !['SQS', 'ALL', 'INGESTION'].includes(ingestionLayer)) {
                ingestionLayer = 'SQS';
            }
            let env = 'dev';
            if (config.apiBase.indexOf('cluster.dyte') > -1) {
                env = 'production';
            }
            else if (config.apiBase.indexOf('staging.dyte') > -1) {
                env = 'staging';
            }
            setTimeout(async () => {
                callStats.initialize({
                    peerId: getRoomNodeClient()?.peerId ?? socketService.peerId,
                    engineName: browserSpecs.getDeviceInfo().engineName,
                    env,
                    iceServers: await APIClient.getICEServers(),
                    apiBase: config.apiBase,
                    flags: {
                        ingestionLayerDetails: ingestionLayer ?? 'SQS',
                    },
                    logger: DyteLogger,
                });
            });
        }
        return new SelfController(socketService, self);
    }
    async shareMediaTracks() {
        await Promise.all([
            this.self.videoTrack && this.#roomNodeClient.shareWebcam(this.self.videoTrack),
            this.self.audioTrack && this.#roomNodeClient.shareMic(this.self.audioTrack),
        ]);
    }
    setupEvents() {
        SessionStore.on(SessionEvents.DISABLE_AUDIO, async () => {
            if (this.self.audioEnabled) {
                await this.self.disableAudio();
                callStats.audioOff();
            }
        });
        SessionStore.on(SessionEvents.DISABLE_VIDEO, async () => {
            if (this.self.videoEnabled) {
                await this.self.disableVideo();
                callStats.videoOff();
            }
        });
        SessionStore.on(SessionEvents.MUTE_ALL, async () => {
            if (this.self.audioEnabled) {
                await this.self.disableAudio();
                callStats.audioOff();
            }
        });
        SessionStore.on(SessionEvents.MUTE_ALL_VIDEO, async () => {
            if (this.self.videoEnabled) {
                await this.self.disableVideo();
                callStats.videoOff();
            }
        });
        SessionStore.on(SessionEvents.WAITLISTED, () => {
            this.self.waitlistStatus = 'waiting';
            this.self.roomState = 'waitlisted';
            this.self.emit('waitlisted');
        });
        SessionStore.on(SessionEvents.WAITLIST_ACCEPTED, async () => {
            if (this.self.waitlistStatus === 'accepted') {
                DyteLogger.warn('SelfController.WAITLIST_ACCEPTED.UserAlreadyAccepted');
                return;
            }
            this.self.waitlistStatus = 'accepted';
            this.joinRoom();
        });
        SessionStore.on(SessionEvents.WAITLIST_REJECTED, async () => {
            if (this.self.waitlistStatus === 'rejected') {
                DyteLogger.warn('SelfController.WAITLIST_REJECTED.UserAlreadyRejected');
                return;
            }
            this.self.waitlistStatus = 'rejected';
            this.leaveRoom('rejected');
        });
        SessionStore.on(SessionEvents.KICKED, async (payload) => {
            let state = 'kicked';
            if (payload?.kickType === 'kickAll')
                state = 'ended';
            this.leaveRoom(state);
        });
        SessionStore.on(SessionEvents.SELF_ROOM_JOINED, () => {
            if (this.self.config.viewType === 'WEBINAR' && this.self.permissions.canPresent) {
                this.self.joinStage();
            }
            this.self.roomState = 'joined';
            this.self.emit('roomJoined');
        });
        SessionStore.on(SessionEvents.SOCKET_SERVICE_ROOM_JOINED, () => {
            this.self.emit('socketServiceRoomJoined');
        });
        SessionStore.on(SessionEvents.MEDIA_PERMISSION_UPDATE, (payload) => {
            this.self.emit('mediaPermissionUpdate', payload);
        });
        SessionStore.on(SessionEvents.MEDIA_PERMISSION_ERROR, async (payload) => {
            const { kind, message } = payload;
            if (kind === 'audio') {
                callStats.mediaPermission('AUDIO', mediaErrorToCallStatEnum(message));
                this.self.disableAudio();
            }
            else if (kind === 'video') {
                callStats.mediaPermission('VIDEO', mediaErrorToCallStatEnum(message));
                this.self.disableVideo();
            }
            else if (kind === 'screenshare') {
                callStats.mediaPermission('VIDEO', mediaErrorToCallStatEnum(message));
                this.self.disableScreenShare();
            }
            DyteLogger.error('SelfController::mediaPermissionError', {
                error: { message: payload.message },
                constraints: payload.constraints,
                mediaPermissionsErrors: {
                    kind,
                    message,
                },
            });
            this.self.emit('mediaPermissionError', payload);
            this.self.emit('mediaPermissionUpdate', { message, kind });
        });
        SessionStore.on(SessionEvents.REQUEST_TO_JOIN_STAGE_ACCEPTED, () => {
            this.self.setWebinarStageStatus(WebinarStageStatus.ACCEPTED_TO_JOIN_STAGE);
            this.self.emit('joinStageRequestAccepted');
        });
        SessionStore.on(SessionEvents.REQUEST_TO_JOIN_STAGE_REJECTED, () => {
            this.self.setWebinarStageStatus(WebinarStageStatus.OFF_STAGE);
            this.self.emit('joinStageRequestRejected');
        });
        SessionStore.on(SessionEvents.REMOVED_FROM_STAGE, async () => {
            this.self.setWebinarStageStatus(WebinarStageStatus.OFF_STAGE);
            await this.self.disableScreenShare();
            await this.self.disableVideo();
            await this.self.disableAudio();
            this.self.destructMediaHandler();
            this.self.emit('removedFromStage');
        });
        SessionStore.on(SessionEvents.STARTED_PRESENTING, () => {
            this.self.setWebinarStageStatus(WebinarStageStatus.ON_STAGE);
            this.self.emit('stageJoined');
        });
        SessionStore.on(SessionEvents.STOPPED_PRESENTING, () => {
            this.self.setWebinarStageStatus(WebinarStageStatus.OFF_STAGE);
            this.self.emit('stageLeft');
        });
        SessionStore.on(SessionEvents.PRODUCER_SCORE_UPDATE, ({ score, kind, appData }) => {
            const isScreenshare = kind === 'video' && (appData?.screenShare ?? false);
            this.self.emit('mediaScoreUpdate', { kind, isScreenshare, score });
        });
        SessionStore.on(SessionEvents.PRODUCER_STATUS_UPDATE, ({ status }) => {
            this.self.emit('mediaChannelUpdate', { status });
        });
        SessionStore.onAsync(SessionEvents.JOIN_MEDIA_ROOM, this.setupRoomNode.bind(this));
        SessionStore.onAsync(SessionEvents.LEAVE_MEDIA_ROOM, this.leaveMediaRoom.bind(this));
    }
    async setupRoomNode() {
        if (this.roomNodeSetupInProgress) {
            DyteLogger.warn('SelfController.roomNodeSetupInProgress');
            return;
        }
        if (this.#roomNodeClient?.roomJoined) {
            DyteLogger.warn('SelfController.roomNodeAlreadySetup');
            return;
        }
        this.roomNodeSetupInProgress = true;
        const options = constants.roomNodeOptions;
        await setupMediaSoupRoomNodeClient({
            ...options,
            roomName: options.roomName,
            peerId: options.peerId,
        });
        let roomUUID = '';
        if (this.#roomNodeClient instanceof MediasoupRoomNodeClient) {
            await this.#roomNodeClient.setupTransports();
            const roomState = await this.#roomNodeClient.getRoomState();
            ({ roomUUID } = roomState?.payload?.roomState ?? {});
            getAPIClient().setRoomUUID(roomUUID);
        }
        await this.joinMediaRoom(roomUUID);
        this.roomNodeSetupInProgress = false;
    }
    async joinRoom() {
        try {
            const APIClient = getAPIClient();
            let roomUUID = '';
            if (this.#roomNodeClient instanceof MediasoupRoomNodeClient) {
                const roomState = await this.#roomNodeClient.getRoomState();
                ({ roomUUID } = roomState?.payload?.roomState ?? {});
                APIClient.setRoomUUID(roomUUID);
            }
            const roomSocketHandler = new RoomSocketHandler(this.#socketService);
            if (shouldConnectToSocketService(this.self.config.viewType, this.#socketService.capabilities)
                || getOverride('chat_socket_server') === 'socket-service') {
                await roomSocketHandler.joinRoom(this.self.name, this.self.id, this.self.userId, roomUUID);
                roomSocketHandler.socket.flush();
                roomSocketHandler.onReconnect = async () => {
                    await roomSocketHandler.joinRoom(this.self.name, this.self.id, this.self.userId, roomUUID);
                    roomSocketHandler.socket.flush();
                };
            }
            if (useRoomNodeClient(this.self.config)) {
                await this.joinMediaRoom(roomUUID);
            }
        }
        catch (error) {
            DyteLogger.error('Error in joinRoom', { error });
            throw error;
        }
    }
    async leaveRoom(state = 'left') {
        const { roomJoined } = this;
        await this.leaveMediaRoom();
        try {
            this.#socketService?.disconnect();
        }
        catch (err) {
            DyteLogger.error('SelfController::leaveRoom::socketDisconnect');
        }
        this.self.roomState = state;
        cleanupRoomNodeClient();
        if (this.self.config.viewType !== 'LIVESTREAM' && !roomJoined)
            return;
        this.self.emit('roomLeft', { state });
    }
    async joinMediaRoom(roomUUID) {
        if (this.#roomNodeClient?.isDisconnected
            && this.#roomNodeClient instanceof MediasoupRoomNodeClient) {
            this.#roomNodeClient?.reconnect();
            return;
        }
        const { roomJoined } = await this.#roomNodeClient?.joinRoom(this.self.name, !this.self.audioEnabled, roomUUID, undefined, {
            audio: this.self.audioEnabled,
            video: this.self.videoEnabled,
            screen: this.self.screenShareEnabled,
        }) ?? {};
        if (this.#roomNodeClient instanceof HiveNodeClient) {
            this.#roomNodeClient.onSocketReconnection = this.joinMediaRoom.bind(this, roomUUID);
        }
        if (roomJoined) {
            await this.shareMediaTracks();
        }
    }
    async leaveMediaRoom() {
        await this.cleanupSelf();
        if (!this.#roomNodeClient)
            return;
        if (this.roomJoined) {
            await this.#roomNodeClient.leaveRoom();
            this.#roomNodeClient.roomJoined = false;
        }
    }
    async cleanupSelf() {
        await this.self.disableAudio();
        await this.self.disableVideo();
        await this.self.disableScreenShare();
        this.self.cleanUpTracks();
        this.self.destructMediaHandler();
        this.self.removeDocumentEventListeners();
    }
}
__decorate([
    DyteTelemetry.trace('SelfController.setupEvents'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SelfController.prototype, "setupEvents", null);
__decorate([
    DyteTelemetry.trace('SelfController.joinRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SelfController.prototype, "joinRoom", null);
__decorate([
    DyteTelemetry.trace('SelfController.leaveRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SelfController.prototype, "leaveRoom", null);
__decorate([
    DyteTelemetry.trace('SelfController.joinMediaRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SelfController.prototype, "joinMediaRoom", null);
__decorate([
    DyteTelemetry.trace('SelfController.leaveMediaRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SelfController.prototype, "leaveMediaRoom", null);
