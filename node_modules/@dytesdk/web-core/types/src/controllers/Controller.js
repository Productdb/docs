var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { globalFlagsmith as flagsmith, ViewType } from '@dyteinternals/utils';
import SelfController from './SelfController';
import ParticipantController from './ParticipantController';
import MetaController from './MetaController';
import PluginController from './PluginController';
import setConfig, { WEB_CORE_VERSION } from '../utils/config';
import setupMediaPolyfill from '../utils/mediaPolyfill';
import { browserSpecs } from '../browser/BrowserCapabilities';
import ChatController from './ChatController';
import PollController from './PollController';
import RemoteController from './RemoteController';
import DyteError from '../client/DyteError';
import DyteTelemetry from '../utils/opentelemetry';
import SocketService from '../socketService/SocketService';
import ChatSocketHandler from '../socketService/ChatSocketHandler';
import PluginSocketHandler from '../socketService/PluginSocketHandler';
import RecordingController from './RecordingController';
import MediasoupRoomNodeClient from '../roomNode/MediasoupRoomNodeClient';
import constants, { setOverrides, setRoomNodeOptions, shouldConnectToSocketService, } from '../utils/constants';
import SpotlightController from './SpotlightController';
import { FlagsmithFeatureFlags, FlagsmithIdentifierPrefix } from '../utils/flags';
import { SessionStore } from '../store/SessionStore';
import hash from '../utils/hash';
import InternalsController from './InternalsController';
import DyteLogger from '../client/internals/DyteLogger';
import { setupAPIClient } from '../api/index';
import LivestreamController from './LivestreamController';
import DytePermissionsPreset from '../client/DytePermissionsPreset';
import DytePermissionsPresetV1 from '../client/DytePermissionsPresetV1';
import DyteThemePreset from '../client/DyteThemePreset';
import DyteThemePresetV1 from '../client/DyteThemePresetV1';
import { isStageHost, useRoomNodeClient } from '../utils/stageHelpers';
import LivestreamSocketHandler from '../socketService/LivestreamSocketHandler';
import StageSocketHandler from '../socketService/StageSocketHandler';
import { getRoomNodeClient, setupHiveRoomNodeClient, setupMediaSoupRoomNodeClient } from '../roomNode/RoomNodeClientProvider';
import StageController from './StageController';
import PollSocketHandler from '../socketService/PollSocketHandler';
import BatteryLogger from '../utils/battery';
import ConnectedMeetingsSocketHandler from '../socketService/ConnectedMeetingsSocketHandler';
export default class Controller {
    apiBase;
    chatController;
    metaController;
    participantController;
    pluginController;
    pollController;
    remoteController;
    selfController;
    recordingController;
    spotlightController;
    livestreamController;
    internalsController;
    stageController;
    constructor(apiBase, metaController, selfController, pluginController, participantController, chatController, pollController, remoteController, recordingController, spotlightController, internalsController, livestreamController, stageController) {
        this.apiBase = apiBase;
        this.metaController = metaController;
        this.selfController = selfController;
        this.pluginController = pluginController;
        this.participantController = participantController;
        this.chatController = chatController;
        this.pollController = pollController;
        this.remoteController = remoteController;
        this.recordingController = recordingController;
        this.spotlightController = spotlightController;
        this.livestreamController = livestreamController;
        this.internalsController = internalsController;
        this.stageController = stageController;
    }
    static async init(options, peerId) {
        const { apiBase = 'https://api.cluster.dyte.in', authToken, } = options;
        const modules = {
            chat: true,
            participant: true,
            plugin: true,
            poll: true,
            self: true,
            meta: true,
            permissions: true,
            theme: true,
            spotlight: true,
            tracing: true,
            devTools: {
                logs: false,
            },
            internals: true,
            stage: true,
            ...options?.modules,
        };
        SessionStore.reset();
        setOverrides(options.overrides ?? {});
        const APIClient = setupAPIClient({ authToken, baseURL: apiBase });
        APIClient.setHeader('dyte-tracing-id', peerId);
        APIClient.setPeerId(peerId);
        APIClient.setRoomName(options.roomName);
        const { roomName } = options;
        const socketRoomName = constants.isV2AuthToken
            ? constants.meetingId
            : roomName;
        const [userResponse, { roomNodeUrl, meetingTitle, useHiveMedia, }] = await Promise.all([
            APIClient.getUserDetails(),
            APIClient.getRoomNodeData({ roomName: socketRoomName, peerId }),
        ]);
        const organizationId = constants.isV2AuthToken
            ? userResponse.participant.organizationId
            : userResponse.organizationId;
        DyteTelemetry.meetingMetadata.userId = constants.isV2AuthToken
            ? userResponse.participant.id
            : userResponse.id;
        setConfig({
            ...options, modules, apiBase, organizationId,
        });
        DyteTelemetry.meetingMetadata.organizationId = organizationId;
        const meetingHash = hash(socketRoomName);
        await flagsmith.identify(`${FlagsmithIdentifierPrefix.PEER}_${peerId}`, JSON.parse(JSON.stringify({
            entity: FlagsmithIdentifierPrefix.PEER,
            clientId: organizationId,
            isAnonUser: !organizationId,
            sdkVersion: WEB_CORE_VERSION,
            meetingHash,
            roomName: socketRoomName,
            ...browserSpecs.getDeviceInfo(),
        })));
        setupMediaPolyfill();
        DyteLogger.info('flagsmith::allFlags', { flags: JSON.stringify(flagsmith.getAllFlags()) }, true);
        BatteryLogger.init();
        let permissions = constants.isV2AuthToken
            ? DytePermissionsPreset.default()
            : DytePermissionsPresetV1.default();
        let theme = constants.isV2AuthToken
            ? DyteThemePreset.default() : DyteThemePresetV1.default();
        let presetName = constants.isV2AuthToken
            ? userResponse.preset.name : undefined;
        if (modules.permissions || modules.theme) {
            const userPreset = constants.isV2AuthToken
                ? undefined
                : await APIClient.getUserPreset(roomName);
            if (userPreset) {
                presetName = userPreset.presetName;
            }
            if (modules.permissions) {
                permissions = constants.isV2AuthToken
                    ? DytePermissionsPreset.fromResponse(userResponse.preset.permissions)
                    : DytePermissionsPresetV1.fromResponse(userPreset.permissions);
            }
            if (modules.theme) {
                theme = constants.isV2AuthToken
                    ? DyteThemePreset.fromResponse(userResponse.preset)
                    : DyteThemePresetV1.fromResponse(userPreset.theme);
                if (!constants.isV2AuthToken) {
                    theme.configFromPermissions(userPreset.permissions);
                }
            }
        }
        const shouldInitializeRoomNode = useRoomNodeClient(theme);
        const customPingPong = flagsmith.hasFeature(FlagsmithFeatureFlags.CUSTOM_PING_PONG);
        const capabilities = [];
        if (useHiveMedia)
            capabilities.push('HIVE');
        if (customPingPong)
            capabilities.push('PING');
        setRoomNodeOptions({
            ...options,
            roomName: socketRoomName,
            peerId,
            meetingTitle,
            roomNodeUrl,
        });
        const socketService = await Controller
            .createSocketServiceAndRoomNodeClient({
            ...options,
            roomName: socketRoomName,
            peerId,
            meetingTitle,
            roomNodeUrl,
            capabilities,
            shouldInitializeRoomNode,
            viewType: theme.viewType,
        });
        const roomNodeClient = getRoomNodeClient();
        let chatController;
        let participantController;
        let pluginController;
        let pollController;
        let selfController;
        let metaController;
        let remoteController;
        let recordingController;
        let spotlightController;
        let livestreamController;
        let internalsController;
        let stageController;
        const chatSocketHandler = new ChatSocketHandler(socketService);
        const pollSocketHandler = new PollSocketHandler(socketService);
        const pluginSocketHandler = new PluginSocketHandler(socketService);
        const livestreamSocketHandler = new LivestreamSocketHandler(socketService);
        const stageSocketHandler = new StageSocketHandler(socketService);
        ConnectedMeetingsSocketHandler.socketService = socketService;
        if (modules.self ?? true) {
            [selfController] = await Promise.all([SelfController.init(socketService, userResponse, permissions, theme, presetName), roomNodeClient instanceof MediasoupRoomNodeClient
                    ? roomNodeClient.setupTransports() : null]);
            APIClient.setOrganizationId(selfController.self.organizationId);
        }
        else if (roomNodeClient instanceof MediasoupRoomNodeClient) {
            await roomNodeClient.setupTransports();
        }
        if (modules.participant ?? true) {
            if (!selfController) {
                throw new DyteError('The participant module cannot be initialized without the `self` module');
            }
            participantController = new ParticipantController(selfController.self);
        }
        if (modules.chat ?? true) {
            if (!selfController) {
                throw new DyteError('The chat module cannot be initialized without the `self` module');
            }
            chatController = await ChatController.init(chatSocketHandler, selfController.self, participantController.participants, capabilities);
        }
        if (modules.plugin ?? true) {
            if (!selfController) {
                throw new DyteError('The plugin module cannot be initialized without the `self` module');
            }
            if (!participantController) {
                throw new DyteError('The plugin module cannot be initialized without the `participant` module');
            }
            pluginController = await PluginController.init(pluginSocketHandler, chatSocketHandler, chatController?.chat, selfController.self, participantController.participants, capabilities);
        }
        if (modules.poll ?? true) {
            if (!selfController) {
                throw new DyteError('The poll cannot be initialized without the `self` module');
            }
            pollController = await PollController.init(selfController.self, pollSocketHandler, capabilities);
        }
        if (modules.meta ?? true) {
            if (!selfController) {
                throw new DyteError('The meta module cannot be initialized without the `self` module');
            }
            metaController = new MetaController(selfController.self, socketService, meetingTitle);
        }
        if (modules.remoteControl ?? true) {
            if (!selfController) {
                throw new DyteError('The remote controller cannot be initialized without the `self` module');
            }
            remoteController = new RemoteController(selfController.self, participantController.participants);
        }
        if (modules.recording ?? true) {
            if (!selfController) {
                throw new DyteError('The recording controller cannot be initialized without the `self` module');
            }
            recordingController = new RecordingController(selfController.self);
        }
        if (modules.spotlight ?? true) {
            if (!selfController) {
                throw new DyteError('The spotlight controller cannot be initialized without the `self` module');
            }
            spotlightController = new SpotlightController(selfController.self);
        }
        if (modules.internals ?? true) {
            internalsController = await InternalsController.init();
        }
        if (theme.viewType === ViewType.Livestream && (modules.livestream ?? true)) {
            if (!selfController) {
                throw new DyteError('The livestream controller cannot be initialized without the `self` module');
            }
            if (flagsmith.hasFeature(FlagsmithFeatureFlags.LIVESTREAM)) {
                livestreamController = new LivestreamController(selfController.self, livestreamSocketHandler);
            }
        }
        if (modules.stage ?? true) {
            if (!selfController) {
                throw new DyteError('The stage client cannot be initialized without the `self` module');
            }
            stageController = new StageController(stageSocketHandler, isStageHost(permissions), selfController.self);
        }
        return new Controller(apiBase, metaController, selfController, pluginController, participantController, chatController, pollController, remoteController, recordingController, spotlightController, internalsController, livestreamController, stageController);
    }
    static async createSocketServiceAndRoomNodeClient(options) {
        const socketServicePromise = Controller.createSocketService(options);
        if (!options.shouldInitializeRoomNode)
            return socketServicePromise;
        if (options.capabilities.includes('HIVE')) {
            const socketService = await socketServicePromise;
            await setupHiveRoomNodeClient({
                ...options,
                roomName: options.roomName,
                peerId: options.peerId,
                socket: socketService,
            });
            return socketService;
        }
        const socketService = (await Promise.all([
            socketServicePromise,
            setupMediaSoupRoomNodeClient({
                ...options,
                roomName: options.roomName,
                peerId: options.peerId,
            }),
        ]))[0];
        return socketService;
    }
    static async createSocketService(options) {
        const { peerId, roomName, authToken, capabilities, } = options;
        const socketService = new SocketService({
            peerId, roomName, authToken, capabilities,
        });
        if (shouldConnectToSocketService(options.viewType, capabilities)
            || options.overrides?.chat_socket_server === 'socket-service') {
            try {
                await socketService.connect();
            }
            catch (error) {
                DyteLogger.error('[Socket Service] Failed to connect to socket server:', { error });
            }
        }
        return socketService;
    }
    async joinRoom() {
        return this.selfController.joinRoom();
    }
    async leaveRoom(state = 'left') {
        BatteryLogger.cleanup();
        return this.selfController.leaveRoom(state);
    }
}
__decorate([
    DyteTelemetry.trace('Controller.joinRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Controller.prototype, "joinRoom", null);
__decorate([
    DyteTelemetry.trace('Controller.leaveRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Controller.prototype, "leaveRoom", null);
__decorate([
    DyteTelemetry.trace('Controller.init'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], Controller, "init", null);
__decorate([
    DyteTelemetry.trace('Controller.createSocketServiceAndRoomNodeClient'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Controller, "createSocketServiceAndRoomNodeClient", null);
__decorate([
    DyteTelemetry.trace('Controller.createSocketService'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Controller, "createSocketService", null);
