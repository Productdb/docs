var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import DyteConnectedMeetings from '../client/DyteConnectedMeetings';
import DyteTelemetry from '../utils/opentelemetry';
import DyteClient from '..';
import { roomEvents } from '../socketService/socketEvents';
import ConnectedMeetingsSocketHandler from '../socketService/ConnectedMeetingsSocketHandler';
export default class ConnectedMeetingsController {
    connectedMeetings;
    #parentMeetingOptions;
    #currentMeeting;
    static instance;
    constructor(meeting, meetingOptions) {
        this.#parentMeetingOptions = meetingOptions;
        this.connectedMeetings = new DyteConnectedMeetings(meeting);
        this.setCurrentMeeting(meeting);
    }
    static init(meeting, meetingOptions) {
        if (!ConnectedMeetingsController.instance) {
            ConnectedMeetingsController.instance = new ConnectedMeetingsController(meeting, meetingOptions);
        }
        ConnectedMeetingsController.instance.setupEvents();
        meeting.self.once('roomJoined', () => ConnectedMeetingsController.instance.getConnectedMeetings());
        return ConnectedMeetingsController.instance;
    }
    setCurrentMeeting(meeting) {
        this.#currentMeeting = meeting;
        ConnectedMeetingsSocketHandler.currentMeetingId = meeting.meta.roomName;
    }
    getConnectedMeetings() {
        this.connectedMeetings.getConnectedMeetings();
    }
    setupEvents() {
        if (!ConnectedMeetingsSocketHandler.socketService)
            return;
        ConnectedMeetingsSocketHandler.socketService.on(roomEvents.getConnectedRoomsDump, this.handleConnectedRoomsDump.bind(this));
        ConnectedMeetingsSocketHandler.socketService.on(roomEvents.transferPeer, this.handleTransferPeer.bind(this));
        ConnectedMeetingsSocketHandler.socketService.on(roomEvents.movedPeer, this.handleMovedPeer.bind(this));
        ConnectedMeetingsSocketHandler.socketService.on(roomEvents.connectedRoomsUpdated, this.handleConnectedRoomsUpdated.bind(this));
        ConnectedMeetingsSocketHandler.socketService.on(roomEvents.connectedRoomsDeleted, this.handleConnectedRoomsDeleted.bind(this));
    }
    handleTransferPeer(payload) {
        const response = ConnectedMeetingsSocketHandler.handleTransferPeerRaw(payload);
        return this.switchMeeting(response);
    }
    async switchMeeting({ authToken }) {
        if (!this.connectedMeetings.supportsConnectedMeetings) {
            throw new Error(`You are not allowed to perform this action.
                Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
        }
        this.connectedMeetings.emit('changingMeeting');
        await this.#currentMeeting.leaveRoom('connected-meeting');
        ConnectedMeetingsSocketHandler.socketService = undefined;
        const newMeeting = await DyteClient.init({
            authToken,
            apiBase: this.#parentMeetingOptions.apiBase,
            defaults: this.#parentMeetingOptions.defaults,
            modules: { ...this.#parentMeetingOptions.modules, connectedMeetings: false },
        });
        this.connectedMeetings.emit('meetingChanged', newMeeting);
        this.setCurrentMeeting(newMeeting);
        return newMeeting;
    }
    handleConnectedRoomsDump(payload) {
        const response = ConnectedMeetingsSocketHandler.handleConnectedRoomsDumpRaw(payload);
        this.connectedMeetings.meetings = response.meetings.map((meeting) => ({
            id: meeting.id,
            title: meeting.title,
            participants: meeting.participants || [],
        }));
        this.connectedMeetings.parentMeeting = {
            id: response.parentMeeting.id,
            title: response.parentMeeting.title,
            participants: response.parentMeeting.participants,
        };
        this.emitStateUpdate();
    }
    handleMovedPeer(payload) {
        const response = ConnectedMeetingsSocketHandler.handleMovedPeerRaw(payload);
        return response;
    }
    handleConnectedRoomsUpdated(payload) {
        const response = ConnectedMeetingsSocketHandler.handleConnectedRoomsUpdatedRaw(payload);
        const map = new Map();
        this.connectedMeetings.meetings.forEach((cMeet) => {
            map.set(cMeet.id, cMeet);
        });
        response.forEach((cMeet) => {
            if (map.has(cMeet.id)) {
                map.get(cMeet.id).title = cMeet.title;
            }
            else {
                map.set(cMeet.id, { ...cMeet, participants: [] });
            }
        });
        this.connectedMeetings.meetings = Array.from(map.values());
        this.emitStateUpdate();
    }
    handleConnectedRoomsDeleted(payload) {
        const meetings = ConnectedMeetingsSocketHandler.handleConnectedRoomsDeletedRaw(payload);
        const meetingIds = meetings.map((meeting) => meeting.id);
        this.connectedMeetings.meetings = this.connectedMeetings.meetings.filter((meeting) => !meetingIds.includes(meeting.id));
    }
    emitStateUpdate() {
        this.connectedMeetings.emit('connectedMeetingState', {
            meetings: this.connectedMeetings.meetings,
            parentMeeting: this.connectedMeetings.parentMeeting,
        });
    }
}
__decorate([
    DyteTelemetry.trace('ConnectedMeetingsController.getConnectedMeetings'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ConnectedMeetingsController.prototype, "getConnectedMeetings", null);
__decorate([
    DyteTelemetry.trace('ConnectedMeetingsController.setupEvents'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ConnectedMeetingsController.prototype, "setupEvents", null);
__decorate([
    DyteTelemetry.trace('ConnectedMeetingsController.switchMeeting'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ConnectedMeetingsController.prototype, "switchMeeting", null);
