type Sockrates = any; 
import { beforeEach, describe, expect, test, vi, } from 'vitest';
import DyteError from '../client/DyteError';
import DyteTelemetry from '../utils/opentelemetry';
import SocketService from './SocketService';
const SocketServiceOptions = {
    peerId: 'd5f8620e-d3ea-47bf-b524-46709cf4eef9',
    roomName: '9c5a20f9-ca5a-4028-a630-680f8da86e57',
    authToken: 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijk4YTE1NGQ1LWVkY2QtNGQ3ZC1iODYwLWUzNTU2NGQwZTY1NyIsImxvZ2dlZEluIjpmYWxzZSwiZW1haWwiOiI2ZTI0NmU2ZC03MmI3LTQ2MTItOGJhYy02ZDljZTE1MjRlNTRAYW5vbi5keXRlLmluIiwiaWF0IjoxNjc1MzM2MDAxLCJleHAiOjE2ODM5NzYwMDF9.LTq7S-1RlAh-HXCmcP_ufo0blYAShkNnt6aWoeCOfwamCsRl9B8SBdhCPaVJXGOV-mEcfTu-qfKEfH8fu24EcbCBw7NBWjqSYBG1t523TxtESpmVeKXH-stvrmIijPCjjlHCrOS_pr4FQIwjmvTqdtjJ_WpxX0UzpqgM2L84s0A',
    capabilities: ['HIVE', 'PING'],
};
vi.mock('@dyte-in/sockrates-client');
vi.mock('../utils/opentelemetry');
vi.mock('../utils/config', () => ({
    config: {
        apiBase: 'https://mock.dyte.io',
    },
}));
describe('Given SocketService is not initialized', () => {
    describe('When initializing SocketService as socketService', () => {
        test('Then throw error if parameters are invalid', () => {
            const SocketServiceInvalidOptions = {
                peerId: '',
                roomName: '',
                authToken: '',
                capabilities: [],
            };
            expect(() => new SocketService(SocketServiceInvalidOptions))
                .toThrowError(new DyteError('peerId, roomName, or authToken can not be empty'));
        });
        const socketService = new SocketService(SocketServiceOptions);
        test('Then socketService.isConnected should be false', () => {
            expect(socketService.isConnected).toBeFalsy();
        });
        test('Then the members of socketService should be defined', () => {
            expect(socketService.roomName).toEqual(SocketServiceOptions.roomName);
            expect(socketService.peerId).toEqual(SocketServiceOptions.peerId);
            expect(socketService.authToken).toEqual(SocketServiceOptions.authToken);
        });
        test('Then the URL should be formed correct', () => {
            const url = new URL(socketService.url);
            expect(url.searchParams.get('roomID')).toEqual(SocketServiceOptions.roomName);
            expect(url.searchParams.get('peerID')).toEqual(SocketServiceOptions.peerId);
            expect(url.searchParams.get('authToken')).toEqual(SocketServiceOptions.authToken);
        });
    });
    describe('When connected to socket service', async () => {
        const socketService = new SocketService(SocketServiceOptions);
        beforeEach(async () => {
            await socketService.connect();
        });
        test('Then socketService.isConnected should be true', () => {
            expect(socketService.isConnected).toBeTruthy();
        });
        test('Then socketService.on should add a listener on sockrates', () => {
            Sockrates.prototype.on = vi.fn();
            socketService.on(1, () => { });
            socketService.onStateEvent('connected', () => { });
            expect(Sockrates.prototype.on).toBeCalledTimes(2);
        });
        test('Then calling disconnect should disconnect the socket', () => {
            socketService.disconnect();
            expect(Sockrates.prototype.disconnect).toBeCalled();
        });
        test('Then socketService.flush should call the flush method in sockrates', () => {
            socketService.flush();
            expect(Sockrates.prototype.flush).toBeCalledTimes(1);
        });
        const sendMessageParams = {
            event: 1,
            protobuf: new Uint8Array(),
            messageId: '5fc1319f-0efd-4c76-b9df-4e877d567e0d',
        };
        test('The send function should call sockrates.send with correct parameters', () => {
            socketService.sendMessage(sendMessageParams.event, sendMessageParams.protobuf, sendMessageParams.messageId);
            expect(Sockrates.prototype.send).toBeCalledWith(sendMessageParams.event, sendMessageParams.messageId, sendMessageParams.protobuf, new TextEncoder().encode(JSON.stringify({})));
        });
        test('The sendMessagePromise function should respect the set timeout', async () => {
            vi.stubEnv('SOCKET_SERVICE_MESSAGE_REQUEST_TIMEOUT', '5');
            const promise = socketService.sendMessagePromise(sendMessageParams.event, sendMessageParams.protobuf, sendMessageParams.messageId);
            expect(DyteTelemetry.injectContext).toBeCalled();
            expect(Sockrates.prototype.send).toBeCalledWith(sendMessageParams.event, sendMessageParams.messageId, sendMessageParams.protobuf, new TextEncoder().encode(JSON.stringify({})));
            try {
                await promise;
            }
            catch (e) {
                expect(e).toEqual('request timeout for callback');
            }
        });
    });
});
