type ConsumePeerRequest = any; type ConsumePeerResponse = any; type ConsumerCloseRequest = any; type CreateTransportRequest = any; type CreateTransportResponse = any; type HostMediaControlForAllPeerRequest = any; type HostMediaControlForAllPeerResponse = any; type HostMediaControlForPeerRequest = any; type HostMediaControlForPeerResponse = any; type KickAllPeersRequest = any; type KickAllPeersResponse = any; type KickPeerRequest = any; type KickPeerResponse = any; type PeerDisplayNameEditRequest = any; type PeerDisplayNameEditResponse = any; type PeerJoinCompleteRequest = any; type PeerJoinCompleteResponse = any; type PeerJoinRequest = any; type ProducerCloseRequest = any; type ProducerClosingResponse = any; type ProducerCreateRequest = any; type ProducerCreateResponse = any; type  = any; 
import { mediaEvents } from './socketEvents';
export default class HiveSFUSocketHandler {
    #socket;
    constructor(socket) {
        this.#socket = socket;
    }
    async joinRoom(roomUuid, displayName) {
        const req = {
            roomUuid,
            displayName,
            prejoined: false,
        };
        return (await this.#socket.sendMessagePromise(mediaEvents.joinRoom, PeerJoinRequest.toBinary(req))).payload;
    }
    async connectTransport(request) {
        const response = (await this.#socket.sendMessagePromise(mediaEvents.createWebRTCTransport, CreateTransportRequest.toBinary(request))).payload;
        const { transportId, description } = CreateTransportResponse.fromBinary(response);
        const answer = {
            sdp: description?.sdp,
            type: description.type,
        };
        return {
            transportId,
            answer,
        };
    }
    async produce(req) {
        const response = (await this.#socket.sendMessagePromise(mediaEvents.produce, ProducerCreateRequest.toBinary(req))).payload;
        const data = ProducerCreateResponse.fromBinary(response);
        const answer = {
            sdp: data?.description?.sdp,
            type: data?.description?.type,
        };
        return {
            answer, producerId: data.producerId,
        };
    }
    async consume(req) {
        const response = (await this.#socket.sendMessagePromise(mediaEvents.consume, ConsumePeerRequest.toBinary(req))).payload;
        const { consumerIdsMap: { map: consumerStateMap }, } = ConsumePeerResponse.fromBinary(response);
        return consumerStateMap;
    }
    async closeProducer(req) {
        const response = (await this.#socket.sendMessagePromise(mediaEvents.closeProducer, ProducerCloseRequest.toBinary(req))).payload;
        const { description } = ProducerClosingResponse.fromBinary(response);
        return description;
    }
    async closeConsumer(req) {
        return (await this.#socket.sendMessagePromise(mediaEvents.closeConsumer, ConsumerCloseRequest.toBinary(req))).payload;
    }
    async hostControlForPeer(peerId, kind) {
        const req = {
            audio: kind === 'audio',
            screeShare: false,
            video: kind === 'video',
            participantId: peerId,
        };
        const res = (await this.#socket.sendMessagePromise(mediaEvents.hostControlPeer, HostMediaControlForPeerRequest.toBinary(req))).payload;
        if (!res) {
            return false;
        }
        const { status } = HostMediaControlForPeerResponse.fromBinary(res);
        return status === 'success';
    }
    async hostControlForAll(kind) {
        const req = {
            audio: kind === 'audio',
            screenShare: false,
            video: kind === 'video',
        };
        const res = (await this.#socket.sendMessagePromise(mediaEvents.hostControlAllPeers, HostMediaControlForAllPeerRequest.toBinary(req))).payload;
        if (!res) {
            return false;
        }
        const { status } = HostMediaControlForAllPeerResponse.fromBinary(res);
        return status === 'success';
    }
    async kickAll() {
        const req = {};
        const res = (await this.#socket.sendMessagePromise(mediaEvents.kickAll, KickAllPeersRequest.toBinary(req))).payload;
        if (!res) {
            return false;
        }
        const { status } = KickAllPeersResponse.fromBinary(res);
        return status === 'success';
    }
    async kickPeer(req) {
        const res = (await this.#socket.sendMessagePromise(mediaEvents.kickPeer, KickPeerRequest.toBinary(req))).payload;
        if (!res) {
            return false;
        }
        const { status } = KickPeerResponse.fromBinary(res);
        return status === 'success';
    }
    async changeDisplayName(req) {
        const res = (await this.#socket.sendMessagePromise(mediaEvents.changeDisplayName, PeerDisplayNameEditRequest.toBinary(req))).payload;
        if (!res) {
            return false;
        }
        const { status } = PeerDisplayNameEditResponse.fromBinary(res);
        return status === 'success';
    }
    async notifySelfJoinComplete() {
        const req = {};
        const response = (await this.#socket.sendMessagePromise(mediaEvents.selfJoinComplete, PeerJoinCompleteRequest.toBinary(req))).payload;
        return PeerJoinCompleteResponse.fromBinary(response);
    }
}
