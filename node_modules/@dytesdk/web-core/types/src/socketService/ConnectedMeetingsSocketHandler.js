type CreateConnectedRoomsRequest = any; type CreateConnectedRoomsResponse = any; type DisableConnectedRoomsRequest = any; type DisableConnectedRoomsResponse = any; type GetConnectedRoomsDumpResponse = any; type MovePeersBetweenRoomsRequest = any; type MovedPeer = any; type TransferPeer = any; type  = any; 
import { roomEvents } from './socketEvents';
export default class ConnectedMeetingsSocketHandler {
    static socketService;
    static currentMeetingId;
    static handleConnectedRoomsDumpRaw({ payload }) {
        const response = GetConnectedRoomsDumpResponse.fromBinary(payload);
        const meetings = response.meetings.map((meeting) => ({
            id: meeting.id,
            title: meeting.title,
            participants: meeting.participants ?? [],
        }));
        const parentMeeting = {
            id: response.parentMeeting.id,
            title: response.parentMeeting.title,
            participants: response.parentMeeting.participants ?? [],
        };
        return {
            parentMeeting,
            meetings,
        };
    }
    static handleTransferPeerRaw({ payload }) {
        const response = TransferPeer.fromBinary(payload);
        return { authToken: response.authToken, meetingId: response.meetingId };
    }
    static handleMovedPeerRaw({ payload }) {
        const response = MovedPeer.fromBinary(payload);
        return {
            meetingId: response.meetingId,
            customParticipantId: response.customParticipantId,
        };
    }
    static handleConnectedRoomsUpdatedRaw({ payload }) {
        const response = CreateConnectedRoomsResponse.fromBinary(payload);
        return response.payloads.map((meeting) => ({
            id: meeting.id,
            title: meeting.title,
        }));
    }
    static handleConnectedRoomsDeletedRaw({ payload }) {
        const response = DisableConnectedRoomsResponse.fromBinary(payload);
        return response.payloads;
    }
    static async getConnectedRoomsDump() {
        const payload = await ConnectedMeetingsSocketHandler
            .socketService
            .sendMessagePromise(roomEvents.getConnectedRoomsDump);
        return ConnectedMeetingsSocketHandler.handleConnectedRoomsDumpRaw(payload);
    }
    static async createConnectedRooms(request) {
        const { payload } = await ConnectedMeetingsSocketHandler.socketService.sendMessagePromise(roomEvents.createConnectedRooms, CreateConnectedRoomsRequest.toBinary({ payloads: request }));
        const response = CreateConnectedRoomsResponse.fromBinary(payload).payloads;
        return response.map((meeting) => ({
            id: meeting.id,
            title: meeting.title,
        }));
    }
    static async updateConnectedRooms(request) {
    }
    static async disableConnectedRooms(meetingIds) {
        const request = meetingIds.map((id) => ({ id }));
        const response = await ConnectedMeetingsSocketHandler.socketService.sendMessagePromise(roomEvents.deleteConnectedRooms, DisableConnectedRoomsRequest.toBinary({ payloads: request }));
        return ConnectedMeetingsSocketHandler.handleConnectedRoomsDeletedRaw(response);
    }
    static async movePeersBetweenRooms(request) {
        try {
            const res = await ConnectedMeetingsSocketHandler.socketService.sendMessagePromise(roomEvents.movePeers, MovePeersBetweenRoomsRequest.toBinary({
                sourceMeetingId: request.sourceMeetingId,
                destinationMeetingId: request.destinationMeetingId,
                participants: request.participants,
            }));
            const ack = new TextDecoder().decode(res.payload);
            if (ack.includes('error')) {
                return { success: false, error: 'failed to move participants' };
            }
            return { success: true };
        }
        catch (error) {
            return { success: false, error };
        }
    }
}
