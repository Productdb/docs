type DenyStageAccessRequest = any; type GetStagePeersResponse = any; type GetStageRequestsResponse = any; type GrantStageAccessRequest = any; type LeaveStageRequest = any; type  = any; 
import { roomEvents } from './socketEvents';
export default class StageSocketHandler {
    #socket;
    constructor(socketService) {
        this.#socket = socketService;
    }
    async getStageRequests() {
        const { payload } = await this.#socket.sendMessagePromise(roomEvents.getStageRequests);
        return payload
            ? GetStageRequestsResponse.fromBinary(payload)
            : { stageRequests: [] };
    }
    requestAccess() {
        this.#socket.sendMessage(roomEvents.requestStageAccess);
    }
    cancelRequestAccess() {
        this.#socket.sendMessage(roomEvents.cancelStageRequest);
    }
    async grantAccess(userIds) {
        const req = {
            userIds,
        };
        await this.#socket.sendMessagePromise(roomEvents.grantStageAccess, GrantStageAccessRequest.toBinary(req));
    }
    async denyAccess(userIds) {
        const req = {
            userIds,
        };
        await this.#socket.sendMessagePromise(roomEvents.denyStageAccess, DenyStageAccessRequest.toBinary(req));
    }
    joinStage() {
        return this.#socket.sendMessage(roomEvents.joinStage);
    }
    leaveStage(userId) {
        const req = {
            userIds: [userId],
        };
        return this.#socket.sendMessage(roomEvents.leaveStage, LeaveStageRequest.toBinary(req));
    }
    kick(userIds) {
        const req = {
            userIds,
        };
        return this.#socket.sendMessagePromise(roomEvents.leaveStage, LeaveStageRequest.toBinary(req));
    }
    on(event, handler) {
        let fromBinary;
        switch (event) {
            case roomEvents.grantStageAccess:
            case roomEvents.denyStageAccess: {
                fromBinary = undefined;
                break;
            }
            case roomEvents.getStagePeers: {
                fromBinary = GetStagePeersResponse.fromBinary.bind(GetStagePeersResponse);
                break;
            }
            case roomEvents.getStageRequests:
            case roomEvents.requestStageAccess:
            case roomEvents.cancelStageRequest: {
                fromBinary = GetStageRequestsResponse.fromBinary
                    .bind(GetStageRequestsResponse);
                break;
            }
            default: break;
        }
        this.#socket.on(event, ({ payload, id }) => {
            if (!payload)
                return handler(undefined, id);
            if (!fromBinary)
                return handler(undefined, id);
            const socketMessage = fromBinary(payload);
            return handler(socketMessage, id);
        });
    }
}
