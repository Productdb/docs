var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
export declare const Capabilities: any; 
type Sockrates = any; 
import DyteError from '../client/DyteError';
import DyteLogger from '../client/internals/DyteLogger';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import { config } from '../utils/config';
import { getOverride } from '../utils/constants';
import DyteTelemetry from '../utils/opentelemetry';
const ERROR_EVENT = 0b1111111111111111;
export default class SocketService {
    #url;
    #sockrates;
    #peerId;
    roomName;
    peerId;
    authToken;
    capabilities;
    constructor({ peerId, roomName, authToken, url, capabilities, }) {
        if (!peerId || !roomName || !authToken) {
            throw new DyteError('peerId, roomName, or authToken can not be empty');
        }
        const { apiBase } = config;
        let socketHost = apiBase.includes('staging.dyte')
            ? 'socket-staging.dyte.io'
            : 'socket-edge.dyte.io';
        if (typeof getOverride('socket_server_base') === 'string') {
            socketHost = getOverride('socket_server_base');
        }
        const wsURL = `wss://${socketHost}`;
        this.roomName = roomName;
        this.peerId = peerId;
        this.authToken = authToken;
        this.capabilities = capabilities;
        const u = new URL(`${url ?? wsURL}/ws`);
        const queryParamsMap = {
            roomID: roomName,
            peerID: peerId,
            authToken,
            useMediaV2: capabilities.includes('HIVE'),
            ping: capabilities.includes('PING'),
            capabilities: capabilities.map((capability) => Capabilities[capability]).join(' '),
        };
        Object.entries(queryParamsMap).forEach(([queryParam, paramValue]) => {
            u.searchParams.append(queryParam, paramValue.toString());
        });
        this.#url = u.href;
        this.#peerId = peerId;
        this.#sockrates = new Sockrates(this.#url, {
            autoReconnect: true,
            disconnectOnPingTimeout: capabilities.includes('PING') ?? false,
            queueOnDisconnect: true,
            flushOnReconnect: false,
            logger: DyteLogger,
        });
    }
    get url() {
        return this.#url;
    }
    async connect() {
        const connectListener = () => {
            DyteLogger.info('SocketService::connect::Connected to socket-edge');
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_CONNECTED);
        };
        this.onStateEvent('connected', connectListener);
        const disconnectListener = ({ reason, code }) => {
            DyteLogger.info('SocketService::connect::Disconnected from socket-edge', { error: { code, reason } });
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_DISCONNECTED);
            if (code < 4000 || code > 4002)
                return;
            if (code === 4000) {
                DyteLogger.error('SocketService::connect::Bad Request', { error: { code, reason } });
            }
            else if (code === 4001) {
                DyteLogger.error('SocketService::connect::Unauthorized', { error: { code, reason } });
            }
            else if (code === 4002) {
                DyteLogger.error('SocketService::connect::Internal Error', { error: { code, reason } });
            }
            else {
                DyteLogger.error('SocketService::connect::Unknown Error', { error: { code, reason } });
            }
        };
        this.onStateEvent('disconnected', disconnectListener);
        const reconnectingListener = () => {
            DyteLogger.info('SocketService::connect::Reconnecting to socket-edge');
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_RECONNECTING);
        };
        this.onStateEvent('reconnecting', reconnectingListener);
        const reconnectAttemptListener = ({ attempt }) => {
            DyteLogger.info('SocketService::connect::Attempting reconnect to socket-edge');
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_RECONNECTION_ATTEMPT, { attempt });
        };
        this.onStateEvent('reconnectAttempt', reconnectAttemptListener);
        const reconnectFailureListener = ({ attempt }) => {
            DyteLogger.info('SocketService::connect::Reconnect attempt failed');
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_RECONNECT_FAILURE, { attempt });
        };
        this.onStateEvent('reconnectFailure', reconnectFailureListener);
        const reconnectedListener = () => {
            DyteLogger.info('SocketService::connect::Reconnected to socket-edge');
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_RECONNECTED);
        };
        this.onStateEvent('reconnected', reconnectedListener);
        const failedListener = () => {
            DyteLogger.info('SocketService::connect::Socket-edge reconnects failed');
            SessionStore.emit(SessionEvents.SOCKET_SERVICE_FAILED);
        };
        this.onStateEvent('failed', failedListener);
        await this.#sockrates.connect();
    }
    disconnect() {
        return this.#sockrates.disconnect();
    }
    get isConnected() {
        try {
            return this.#sockrates.readyState === 1;
        }
        catch {
            return false;
        }
    }
    #generateId() {
        return `${this.#peerId}-${(Math.random() + 1).toString(36).substring(7)}`;
    }
    sendMessage(event, protobuf, messageId) {
        const metadata = {};
        DyteTelemetry.injectContext(metadata);
        return this.#sockrates.send(event, messageId ?? this.#generateId(), protobuf, new TextEncoder().encode(JSON.stringify(metadata)));
    }
    sendMessagePromise(event, protobuf, messageId) {
        const timeout = parseInt(import.meta.env.SOCKET_SERVICE_MESSAGE_REQUEST_TIMEOUT, 10)
            || 20000;
        return this.sendMessagePromiseWithTimeout({
            event, timeout, protobuf, messageId,
        });
    }
    sendMessagePromiseWithTimeout({ event, timeout, protobuf, messageId, }) {
        return new Promise((resolve, reject) => {
            const mId = messageId ?? this.#generateId();
            const metadata = {};
            DyteTelemetry.injectContext(metadata);
            setTimeout(reject, timeout, 'request timeout for callback');
            const listener = ({ id, payload }) => {
                if (mId === id) {
                    resolve({ id, payload });
                    this.#sockrates.removeListener(event, listener);
                    this.#sockrates.removeListener(ERROR_EVENT, listener);
                }
            };
            this.#sockrates.on(event, listener);
            this.#sockrates.on(ERROR_EVENT, listener);
            this.#sockrates.send(event, mId, protobuf, new TextEncoder().encode(JSON.stringify(metadata)));
        });
    }
    on(event, listener) {
        this.#sockrates.on(event, listener);
    }
    onStateEvent(event, listener) {
        this.#sockrates.on(event, listener);
    }
    flush() {
        return this.#sockrates.flush();
    }
}
__decorate([
    DyteTelemetry.trace('SocketService.connect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SocketService.prototype, "connect", null);
__decorate([
    DyteTelemetry.trace('SocketService.disconnect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SocketService.prototype, "disconnect", null);
__decorate([
    DyteTelemetry.trace('SocketService.sendMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Uint8Array, String]),
    __metadata("design:returntype", void 0)
], SocketService.prototype, "sendMessage", null);
__decorate([
    DyteTelemetry.trace('SocketService.sendMessagePromise'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Uint8Array, String]),
    __metadata("design:returntype", void 0)
], SocketService.prototype, "sendMessagePromise", null);
