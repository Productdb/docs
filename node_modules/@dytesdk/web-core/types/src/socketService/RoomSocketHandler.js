type JoinRoomRequest = any; type LeaveRoomRequest = any; type PeerInfoResponse = any; type RoomInfoResponse = any; type  = any; 
import DyteLogger from '../client/internals/DyteLogger';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import { roomEvents } from './socketEvents';
export default class RoomSocketHandler {
    socket;
    constructor(socketService) {
        this.socket = socketService;
    }
    set onReconnect(fn) {
        this.socket.onStateEvent('reconnected', fn);
    }
    async joinRoom(displayName, peerId, userId, roomUUID) {
        const req = {
            capabilities: [],
            peer: {
                displayName, peerId, userId,
            },
            roomUuid: roomUUID,
        };
        const joinRoomResponse = PeerInfoResponse.fromBinary((await this.socket.sendMessagePromise(roomEvents.joinRoom, JoinRoomRequest.toBinary(req))).payload);
        await SessionStore.emitAsync(SessionEvents.SOCKET_SERVICE_ROOM_JOINED, joinRoomResponse);
        try {
            const { room } = await this.getRoomState();
            SessionStore.emit(SessionEvents.ROOM_STATE, room);
        }
        catch (error) {
            DyteLogger.error('RoomSocketHandler.joinRoom.failedToGetRoomState', {
                error,
            });
        }
    }
    async getRoomState() {
        let roomInfoResponse = RoomInfoResponse.create();
        try {
            const res = await this.socket.sendMessagePromise(roomEvents.getRoomInfo);
            roomInfoResponse = RoomInfoResponse.fromBinary(res.payload);
        }
        catch (err) {
            DyteLogger.error('getRoomState::binary_decode_error', { error: err });
        }
        return roomInfoResponse;
    }
    leaveRoom() {
        this.socket.sendMessage(roomEvents.leaveRoom, LeaveRoomRequest.toBinary({}));
    }
}
