var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
type DeleteChatMessageRequest = any; type DeleteChatMessageResponse = any; type EditChatMessageRequest = any; type EditChatMessageResponse = any; type GetPaginatedChatMessageRoomRequest = any; type GetPaginatedChatMessageRoomResponse = any; type SendChatMessageToPeersRequest = any; type SendChatMessageToPeersResponse = any; type SendChatMessageToRoomRequest = any; type SendChatMessageToRoomResponse = any; type  = any; 
import DyteLogger from '../client/internals/DyteLogger';
import DyteTelemetry from '../utils/opentelemetry';
import { chatEvents } from './socketEvents';
export var ChatMessageType;
(function (ChatMessageType) {
    ChatMessageType[ChatMessageType["TEXT"] = 0] = "TEXT";
    ChatMessageType[ChatMessageType["IMAGE"] = 1] = "IMAGE";
    ChatMessageType[ChatMessageType["FILE"] = 2] = "FILE";
})(ChatMessageType || (ChatMessageType = {}));
export default class ChatSocketHandler {
    #socket;
    constructor(socketService) {
        this.#socket = socketService;
    }
    getChatMessages() {
        return this.#socket.sendMessagePromise(chatEvents.getMessages);
    }
    async getChatMessagesPaginated(timeStamp, size, reversed, offset = 0) {
        const req = {
            timeStamp,
            size,
            from: offset,
            reversed,
        };
        const protoChatMessagesResponse = await this.#socket.sendMessagePromise(chatEvents.getPaginatedMessages, GetPaginatedChatMessageRoomRequest.toBinary(req));
        if (!protoChatMessagesResponse.payload) {
            return {
                messages: [],
                next: false,
            };
        }
        return GetPaginatedChatMessageRoomResponse.fromBinary(protoChatMessagesResponse.payload);
    }
    sendMessageToRoom(message, messageType) {
        const req = {
            payloadType: messageType,
            payload: message,
        };
        this.#socket.sendMessage(chatEvents.sendMessageToRoom, SendChatMessageToRoomRequest.toBinary(req));
    }
    sendMessageToPeers(message, messageType, peerIds) {
        const req = {
            payloadType: messageType,
            peerIds,
            payload: message,
        };
        this.#socket.sendMessage(chatEvents.sendMessageToPeers, SendChatMessageToPeersRequest.toBinary(req));
    }
    sendMessage(message, messageType, peerIds) {
        if (peerIds && peerIds.length > 0) {
            this.sendMessageToPeers(message, messageType, peerIds);
            return;
        }
        this.sendMessageToRoom(message, messageType);
    }
    editMessage(chatId, message, messageType, pinned) {
        const req = {
            chatId,
            pinned,
            payloadType: messageType,
            payload: message,
        };
        this.#socket.sendMessage(chatEvents.editMessage, EditChatMessageRequest.toBinary(req));
    }
    deleteMessage(chatId) {
        this.#socket.sendMessage(chatEvents.deleteMessage, DeleteChatMessageRequest.toBinary({ chatId }));
    }
    on(event, handler) {
        let fromBinary;
        let defaultSocketMessage;
        switch (event) {
            case chatEvents.sendMessageToRoom: {
                fromBinary = SendChatMessageToRoomResponse.fromBinary
                    .bind(SendChatMessageToRoomResponse);
                defaultSocketMessage = SendChatMessageToRoomResponse.create();
                break;
            }
            case chatEvents.sendMessageToPeers: {
                fromBinary = SendChatMessageToPeersResponse.fromBinary
                    .bind(SendChatMessageToPeersResponse);
                defaultSocketMessage = SendChatMessageToPeersResponse.create();
                break;
            }
            case chatEvents.editMessage: {
                fromBinary = EditChatMessageResponse.fromBinary
                    .bind(EditChatMessageResponse);
                defaultSocketMessage = EditChatMessageResponse.create();
                break;
            }
            case chatEvents.deleteMessage: {
                fromBinary = DeleteChatMessageResponse.fromBinary
                    .bind(DeleteChatMessageResponse);
                defaultSocketMessage = DeleteChatMessageResponse.create();
                break;
            }
            default: break;
        }
        if (!fromBinary) {
            DyteLogger.warn(`ChatSocketHandler::Event ${event} is not recognized`);
            return;
        }
        this.#socket.on(event, ({ payload }) => {
            let socketMessage = defaultSocketMessage;
            try {
                socketMessage = fromBinary(payload);
            }
            catch (err) {
                DyteLogger.error('chatSocketHandler::on::binary_decode_error', { error: err });
            }
            return handler(socketMessage);
        });
    }
}
__decorate([
    DyteTelemetry.trace('SocketService.getChatMessages'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ChatSocketHandler.prototype, "getChatMessages", null);
__decorate([
    DyteTelemetry.trace('SocketService.getChatMessagesPaginated'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number, Boolean, Number]),
    __metadata("design:returntype", Promise)
], ChatSocketHandler.prototype, "getChatMessagesPaginated", null);
__decorate([
    DyteTelemetry.trace('SocketService.sendMessageToRoom'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", void 0)
], ChatSocketHandler.prototype, "sendMessageToRoom", null);
__decorate([
    DyteTelemetry.trace('SocketService.sendMessageToPeers'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Array]),
    __metadata("design:returntype", void 0)
], ChatSocketHandler.prototype, "sendMessageToPeers", null);
__decorate([
    DyteTelemetry.trace('SocketService.sendMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Array]),
    __metadata("design:returntype", void 0)
], ChatSocketHandler.prototype, "sendMessage", null);
__decorate([
    DyteTelemetry.trace('SocketService.editMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Boolean]),
    __metadata("design:returntype", void 0)
], ChatSocketHandler.prototype, "editMessage", null);
__decorate([
    DyteTelemetry.trace('SocketService.deleteMessage'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], ChatSocketHandler.prototype, "deleteMessage", null);
