import { globalFlagsmith } from '@dyteinternals/utils';
import axios from 'axios';
import DyteLogger from '../client/internals/DyteLogger';
import { FlagsmithFeatureFlags } from '../utils/flags';
import DyteTelemetry from '../utils/opentelemetry';
const DEFAULT_RETRY_COUNT = 3;
const DEFAULT_RETRY_DELAY = 30;
const DEFAULT_TIMEOUT = 8000;
export default class API {
    ipInfo = undefined;
    axios;
    requests;
    roomName;
    roomUUID;
    peerId;
    authToken;
    organizationId;
    constructor(options) {
        const { timeout = DEFAULT_TIMEOUT, retry = DEFAULT_RETRY_COUNT, retryDelay = DEFAULT_RETRY_DELAY, baseURL = 'https://api.cluster.dyte.in', authToken, } = options || {};
        this.requests = axios.create({
            baseURL,
            responseType: 'json',
            timeout,
            retry,
            retryDelay,
        });
        this.axios = axios;
        this.setAuthToken(authToken, { bearer: true });
        this.requests.interceptors.request.use((request) => {
            DyteTelemetry.injectContext(this.requests.defaults.headers.common);
            return request;
        }, async (error) => {
            DyteLogger.error('xhr::axios', { debuggingHint: 'otelRequestInterceptor failed.', error });
        });
        this.requests.interceptors.response.use((response) => {
            if (response.config.url !== DyteTelemetry.logsEndpoint) {
                DyteLogger.debug('xhr::axios', {
                    networkCall: {
                        status: response.status,
                        statusText: response.statusText,
                        baseURL: response.config.baseURL,
                        url: response.config.url,
                        method: response.config.method,
                    },
                });
            }
            return response;
        }, async (error) => {
            if (!error) {
                return Promise.reject(new Error('Unknown error occurred'));
            }
            if (error && error.config && error.config?.url !== DyteTelemetry.logsEndpoint) {
                DyteLogger.error('xhr::axios', {
                    error,
                    networkCall: {
                        status: error.status,
                        statusText: error.statusText,
                        baseURL: error.config.baseURL,
                        url: error.config.url,
                        retries: error.config.retry,
                        method: error.config.method,
                        isOnline: navigator.onLine ? 'online' : 'offline',
                    },
                });
            }
            const { config, message } = error;
            if (config
                && message
                && config.retry !== undefined
                && config.retry > 0
                && (message.includes('timeout') || message.includes('Network Error'))) {
                config.retry -= 1;
                const delay = new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(true);
                        this.fetchRetryExp(config.retry, 'https://network.dyte.io');
                        this.fetchRetryExp(config.retry, 'https://network2.dyte.io');
                    }, config.retryDelay || DEFAULT_RETRY_DELAY);
                });
                return delay.then(() => this.requests(config));
            }
            return Promise.reject(error);
        });
    }
    setAuthToken(token, options) {
        const { bearer } = options || {};
        this.authToken = token;
        this.requests.defaults.headers.common.Authorization = bearer ? `Bearer ${token}` : token;
    }
    setHeader(key, value) {
        this.requests.defaults.headers.common[key] = value;
    }
    setRoomName(name) {
        this.roomName = name;
    }
    setRoomUUID(id) {
        this.roomUUID = id;
    }
    setPeerId(id) {
        this.peerId = id;
    }
    setOrganizationId(id) {
        this.organizationId = id;
    }
    async fetchRetryExp(retry, url) {
        if (!globalFlagsmith.hasFeature(FlagsmithFeatureFlags.FETCH_RETRY))
            return;
        const controller = new AbortController();
        const fetchTimeout = setTimeout(() => {
            DyteLogger.log('fetch_alt_domain', {
                networkCall: {
                    retries: retry,
                    url,
                    ip: this.ipInfo,
                },
            });
            controller.abort();
        }, 5000);
        try {
            const res = await fetch(url, {
                signal: controller.signal,
            });
            DyteLogger.log('fetch_alt_domain_success', {
                networkCall: {
                    retries: retry,
                    url,
                    status: res.status,
                    ip: this.ipInfo && this.ipInfo.ip ? this.ipInfo.ip : undefined,
                },
            });
        }
        catch {
            DyteLogger.log('fetch_alt_domain_failure', {
                networkCall: {
                    retries: retry,
                    url,
                    ip: this.ipInfo && this.ipInfo.ip ? this.ipInfo.ip : undefined,
                },
            });
        }
        finally {
            clearTimeout(fetchTimeout);
        }
    }
}
