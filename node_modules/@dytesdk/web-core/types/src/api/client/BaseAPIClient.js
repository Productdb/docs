type ipDetails = any; 
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import { config as globalConfig, WEB_CORE_VERSION } from '../../utils/config';
import constants, { sampleLocalhostPlugin } from '../../utils/constants';
import API from '../API';
import DyteLogger from '../../client/internals/DyteLogger';
import { FlagsmithFeatureFlags } from '../../utils/flags';
export default class BaseAPIClient extends API {
    constructor(options) {
        super(options);
        this.setHeader('x-dyte-web-core-version', WEB_CORE_VERSION);
    }
    static async getIPDetails({ peerId }) {
        try {
            const ipInfo = await ipDetails.getIPDetails({ peerId });
            DyteLogger.info('gotIPDetails', { networkCall: { ip: ipInfo.ip, timezone: ipInfo.timezone } });
            return ipInfo;
        }
        catch (error) {
            DyteLogger.warn('ApiClient.getRoomNodeLinkAndTitleV1 Failed to get ip details', { error: { name: error.name, message: error.message } });
            return undefined;
        }
    }
    async getICEServers() {
        const { success, iceServers } = (await this.requests.get('/iceservers')).data;
        if (success) {
            return iceServers;
        }
        return undefined;
    }
    async getPlugins(isSocketService) {
        let { plugins } = (await this.requests.get('/v2/plugins/user')).data.data;
        const v1Plugins = flagsmith.getValue(FlagsmithFeatureFlags.V1_PLUGINS)?.toString()?.split(',') || [];
        const result = plugins.reduce((res, plugin) => {
            res[v1Plugins.includes(plugin.id) ? 'v1' : 'v2'].push(plugin);
            return res;
        }, { v1: [], v2: [] });
        if (isSocketService === 'socket-service')
            plugins = result.v2;
        else
            plugins = result.v1;
        if (globalConfig.modules?.devTools?.plugins?.length) {
            globalConfig.modules?.devTools?.plugins.forEach((localPluginConfig) => {
                const formattedLocalPlugin = {
                    ...sampleLocalhostPlugin,
                    tags: [...sampleLocalhostPlugin.tags],
                };
                formattedLocalPlugin.baseURL = `http://localhost:${localPluginConfig.port}`;
                formattedLocalPlugin.name = localPluginConfig.name;
                formattedLocalPlugin.picture = localPluginConfig.picture
                    ?? sampleLocalhostPlugin.picture;
                formattedLocalPlugin.description = localPluginConfig.description
                    ?? sampleLocalhostPlugin.description;
                formattedLocalPlugin.staggered = localPluginConfig.staggered
                    ?? sampleLocalhostPlugin.staggered;
                formattedLocalPlugin.createdAt = new Date().toISOString();
                formattedLocalPlugin.updatedAt = new Date().toISOString();
                formattedLocalPlugin.id = localPluginConfig.id;
                formattedLocalPlugin.organizationId = this.organizationId;
                plugins.push(formattedLocalPlugin);
            });
        }
        return plugins;
    }
    async getPluginDetails(pluginId) {
        const { plugin } = (await this.requests.get(`/v2/plugins/view/${pluginId}`)).data.data;
        return plugin;
    }
    async getPluginConfig(pluginBaseUrl) {
        const config = (await this.axios.get(`${pluginBaseUrl}/dyte-config.json`)).data;
        return config;
    }
    async authorizePlugin(pluginId) {
        const body = {
            peerId: this.peerId,
        };
        if (!constants.isV2AuthToken)
            body.roomName = this.roomName;
        const { token } = (await this.requests.post(`/v2/plugins/authorize/${pluginId}`, body)).data.data;
        return token;
    }
    async getPresignedUrls(filename) {
        const { getLocation, putLocation } = (await this.requests.post('/v1/meetings/genPreSignedUploadUrl', {
            roomUUID: this.roomUUID,
            filename,
        })).data.data;
        return {
            getLocation,
            putLocation,
        };
    }
    async uploadFile(file, url) {
        await this.axios.put(url, file, {
            headers: {
                'Content-Type': file.type,
            },
        });
    }
}
