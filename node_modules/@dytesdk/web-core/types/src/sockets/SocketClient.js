var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { io } from 'socket.io-client';
import EventEmitter from 'events';
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import DyteTelemetry from '../utils/opentelemetry';
import { SocketEvents } from './SocketEvents';
import { SocketState } from './SocketState';
import { SessionEvents } from '../store/SessionEvents';
import { SessionStore } from '../store/SessionStore';
import DyteLogger from '../client/internals/DyteLogger';
import { FlagsmithFeatureFlags } from '../utils/flags';
const SIMPLE_SERVER_MESSAGE_EVENT = 'event://server-simple-message';
const CLIENT_SIDE_EVENT = 'event://send-message';
export default class SocketClient extends EventEmitter {
    socket;
    socketState;
    callbackHandler = null;
    constructor(options) {
        super();
        this.socketState = SocketState.NOT_STARTED;
        if (options.callbackHandler) {
            this.callbackHandler = options.callbackHandler;
        }
    }
    connect(url) {
        if (this.socket) {
            this.socket.removeAllListeners();
            this.socket.disconnect();
        }
        this.socket = io(url, { closeOnBeforeunload: false });
        this.setupSocket();
    }
    disconnect() {
        this.socket.disconnect();
    }
    reconnect() {
        this.socket.connect();
    }
    setupSocket() {
        this.socket.on('disconnect', (reason) => {
            this.socketState = SocketState.DISCONNECTED;
            DyteLogger.warn('SocketClient::socket_disconnected', { error: { reason } });
            this.emit(SocketEvents.SOCKET_DISCONNECTED, { reason });
        });
        this.socket.on('connect_error', (err) => {
            this.socketState = SocketState.ERRORED;
            if (flagsmith.hasFeature(FlagsmithFeatureFlags.SOCKET_POLLING)) {
                this.socket.io.opts.transports = ['polling', 'websocket'];
            }
            DyteLogger.error('SocketClient::socket_connection_errored', { error: err });
            this.emit(SocketEvents.SOCKET_CONNECTION_ERROR, { err });
        });
        this.socket.on('connect', () => {
            this.socketState = SocketState.CONNECTED;
            DyteLogger.info('SocketClient::socket_connected');
            this.emit(SocketEvents.SOCKET_CONNECTED);
        });
        this.socket.on(SIMPLE_SERVER_MESSAGE_EVENT, async (message, callback) => {
            const parsedMessage = JSON.parse(message);
            if (!DyteTelemetry.logExclusionList.includes(parsedMessage?.type)
                || flagsmith.hasFeature(FlagsmithFeatureFlags.BYPASS_LOG_EXCLUSION_LIST)) {
                DyteLogger.info(`SocketClient::SIMPLE_SERVER_MESSAGE_EVENT::${parsedMessage?.type}`);
            }
            if (callback) {
                let response = 'OK';
                if (this.callbackHandler) {
                    response = await this.callbackHandler(parsedMessage);
                }
                callback(response);
            }
            else
                this.emit(SocketEvents.SOCKET_MESSAGE, parsedMessage);
            if (Object.values(SessionEvents).find((e) => e === parsedMessage.type)) {
                SessionStore.emit(parsedMessage.type, parsedMessage.payload);
            }
        });
    }
    async sendMessage(message) {
        if (!DyteTelemetry.logExclusionList.includes(message?.type)
            || flagsmith.hasFeature(FlagsmithFeatureFlags.BYPASS_LOG_EXCLUSION_LIST)) {
            DyteLogger.info(`SocketClient::sendMessage::${message?.type}`);
        }
        Object.assign(message, { metadata: message.metadata || {} });
        DyteTelemetry.injectContext(message.metadata);
        return new Promise((resolve) => {
            this.socket.emit(CLIENT_SIDE_EVENT, JSON.stringify(message), (response) => {
                if (!response) {
                    resolve(undefined);
                    return;
                }
                const parsedMessage = JSON.parse(response);
                resolve(parsedMessage);
            });
        });
    }
}
__decorate([
    DyteTelemetry.trace('SocketClient.connect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], SocketClient.prototype, "connect", null);
__decorate([
    DyteTelemetry.trace('SocketClient.disconnect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SocketClient.prototype, "disconnect", null);
__decorate([
    DyteTelemetry.trace('SocketClient.reconnect'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SocketClient.prototype, "reconnect", null);
__decorate([
    DyteTelemetry.trace('SocketClient.setupSocket'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SocketClient.prototype, "setupSocket", null);
