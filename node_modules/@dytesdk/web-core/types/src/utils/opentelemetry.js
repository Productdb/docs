import { WebTracerProvider, StackContextManager } from '@opentelemetry/sdk-trace-web';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { ZoneContextManager } from '@opentelemetry/context-zone-peer-dep';
import opentelemetry, { ROOT_CONTEXT, propagation, } from '@opentelemetry/api';
import { Resource } from '@opentelemetry/resources';
import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import { v4 as uuid } from 'uuid';
import axios from 'axios';
import { isEmpty } from 'lodash-es';
import { WEB_CORE_VERSION } from './config';
import { isADyteTestingEnvironment, safelyFlattenObjForOpenTelemetry, shouldSendLogToLogAggregator, } from './opentelemetry-helpers/logHelpers';
import { browserSpecs } from '../browser/BrowserCapabilities';
import { FlagsmithFeatureFlags } from './flags';
import createSafeToLogError from './opentelemetry-helpers/safeToLogErrorCreator';
export default class DyteTelemetry {
    static tracer;
    static contextPropagator;
    static rootSpan;
    static logsCache = [];
    static logsProcessorTimer;
    static get logsEndpoint() { return isADyteTestingEnvironment() ? 'https://api-silos-staging.dyte.io/otel/logs' : 'https://api-silos.dyte.io/otel/logs'; }
    static tracingEnabled = true;
    static initialized = false;
    static logsProcessingInterval = 7000;
    static logExclusionList = [
        'message',
        'websocket/message',
        'roomMessage',
        'websocket/room-message',
        'websocket/room-legacy-mode',
        'chatMessage',
        'websocket/new-chat-message',
        'websocket/no-active-speaker',
        'websocket/selected-peers',
        'websocket/active-speaker',
        'ping',
        'websocket/new-consumer',
        'websocket/producer-score',
        'websocket/consumer-score',
        'websocket/plugin-event',
        'websocket/plugin-data',
        'websocket/plugin-internal-data',
    ];
    static meetingMetadata = {};
    static init(peerId, enableTracing) {
        if (navigator.isReactNative)
            return;
        const exporter = new OTLPTraceExporter({
            url: 'https://otel.dyte.io/v1/traces',
            headers: {
                'api-key': '',
            },
        });
        let resourceEnvironment = isADyteTestingEnvironment() ? 'staging' : 'production';
        if (WEB_CORE_VERSION === 'DEV_LOCAL') {
            resourceEnvironment = 'DEV_LOCAL';
        }
        const provider = new WebTracerProvider({
            resource: new Resource({
                'service.name': 'web-core',
                sdk_version: WEB_CORE_VERSION,
                env: resourceEnvironment,
                ...safelyFlattenObjForOpenTelemetry('OTELResource', browserSpecs.getDeviceInfo(), 'device'),
            }),
            idGenerator: {
                generateTraceId: () => `${peerId}`.replace(/-/g, ''),
                generateSpanId: () => uuid().replace(/-/g, '').substring(0, 16),
            },
        });
        DyteTelemetry.tracingEnabled = enableTracing;
        DyteTelemetry.tracer = provider.getTracer(peerId);
        DyteTelemetry.meetingMetadata.peerId = peerId;
        DyteTelemetry.meetingMetadata.sdkVersion = WEB_CORE_VERSION;
        DyteTelemetry.meetingMetadata.deviceInfo = browserSpecs.getDeviceInfo();
        DyteTelemetry.meetingMetadata.visitedUrl = !navigator.isReactNative && typeof window !== 'undefined' && window.location.href;
        provider.addSpanProcessor(new BatchSpanProcessor(exporter));
        if ('zone' in window) {
            provider.register({
                contextManager: new ZoneContextManager(),
            });
        }
        else {
            provider.register({
                contextManager: new StackContextManager(),
            });
        }
        DyteTelemetry.contextPropagator = propagation;
        document.addEventListener('visibilitychange', DyteTelemetry.processCachedLogs);
        DyteTelemetry.logsProcessorTimer = setInterval(DyteTelemetry.processCachedLogs, DyteTelemetry.logsProcessingInterval);
        if (!enableTracing)
            return;
        DyteTelemetry.rootSpan = DyteTelemetry.tracer.startSpan(`peer_${peerId}`, {}, ROOT_CONTEXT);
        DyteTelemetry.rootSpan.end();
        DyteTelemetry.initialized = true;
    }
    static trace(spanName) {
        return (_target, _propertyKey, descriptor) => {
            const originalMethod = descriptor.value;
            descriptor.value = function opentelemetryValueDescriptorFunc(...args) {
                if (!DyteTelemetry.initialized
                    || navigator.isReactNative
                    || !DyteTelemetry.tracingEnabled
                    || flagsmith.hasFeature(FlagsmithFeatureFlags.SKIP_OTEL_TRACES)) {
                    return originalMethod.apply(this, args);
                }
                const immmediateParentSpan = DyteTelemetry.getCurrentSpan();
                const ctx = opentelemetry.trace.setSpan(ROOT_CONTEXT, immmediateParentSpan);
                if (!flagsmith.hasFeature(FlagsmithFeatureFlags.NR_OTEL_WEB)) {
                    DyteTelemetry.addLogInCurrentSpan('info', spanName);
                }
                return DyteTelemetry.tracer.startActiveSpan(spanName, {}, ctx, (span) => {
                    const result = originalMethod.apply(this, args);
                    Promise.resolve(result).then(() => {
                        span.end();
                    }).catch(() => {
                        span.end();
                    });
                    return result;
                });
            };
            return descriptor;
        };
    }
    static getCurrentSpan() {
        if (navigator.isReactNative)
            return null;
        let immmediateParentSpan = opentelemetry
            .trace
            .getSpan(opentelemetry.context.active());
        immmediateParentSpan ??= DyteTelemetry.rootSpan;
        return immmediateParentSpan;
    }
    static getCurrentContext() {
        const ctx = opentelemetry.trace.setSpan(ROOT_CONTEXT, DyteTelemetry.getCurrentSpan());
        return ctx;
    }
    static getCurrentSpanName() {
        return this.getCurrentSpan()?.name;
    }
    static injectContext(injectionReceiver) {
        if (DyteTelemetry.getCurrentSpan()) {
            DyteTelemetry.contextPropagator.inject(DyteTelemetry.getCurrentContext(), injectionReceiver);
        }
    }
    static addLogInCurrentSpan(eventSeverity = 'info', eventName, metadata = {}, noCache) {
        if (isADyteTestingEnvironment()) {
            if (isEmpty(metadata)) {
                console[eventSeverity]('DyteInternalLogs:: ', eventSeverity, eventName);
            }
            else {
                console[eventSeverity]('DyteInternalLogs:: ', eventSeverity, eventName, metadata);
            }
        }
        const shouldSendThisLog = shouldSendLogToLogAggregator(eventSeverity);
        if (!shouldSendThisLog) {
            return;
        }
        try {
            const flattendMetadata = safelyFlattenObjForOpenTelemetry(eventName, metadata, 'metadata');
            const currentSpan = DyteTelemetry.getCurrentSpan();
            const now = new Date();
            const logToProcess = {
                message: eventName,
                level: eventSeverity,
                ...flattendMetadata,
                'trace.id': currentSpan?.spanContext()?.traceId,
                'span.id': currentSpan?.spanContext()?.spanId,
                loggedAt: now.toISOString(),
                loggedAtTzOffset: now.getTimezoneOffset(),
            };
            if (noCache) {
                DyteTelemetry.sendOtelLogsToNewRelic([logToProcess]);
            }
            else {
                DyteTelemetry.logsCache.push(logToProcess);
            }
        }
        catch (ex) {
            DyteTelemetry.addLogInCurrentSpan('error', 'opentelemetry::addLogInCurrentSpan_failed', {
                error: createSafeToLogError(ex),
            });
        }
    }
    static sendOtelLogsToNewRelic(logs) {
        axios.post(DyteTelemetry.logsEndpoint, {
            meetingMetadata: safelyFlattenObjForOpenTelemetry('sendOtelLogsToNewRelic', DyteTelemetry.meetingMetadata, 'meetingMetadata'),
            serviceName: 'web-core',
            logs,
        }).catch((ex) => {
            DyteTelemetry.addLogInCurrentSpan('error', 'opentelemetry::sendOtelLogToNewRelic_failed', {
                error: createSafeToLogError(ex),
            });
            DyteTelemetry.logsCache.push(...logs);
        });
    }
    static processCachedLogs() {
        const logs = DyteTelemetry.logsCache.splice(0, 25);
        if (logs?.length) {
            DyteTelemetry.sendOtelLogsToNewRelic(logs);
        }
    }
    static destruct() {
        clearInterval(DyteTelemetry.logsProcessorTimer);
        DyteTelemetry.processCachedLogs();
        document.removeEventListener('visibilitychange', DyteTelemetry.processCachedLogs);
    }
}
