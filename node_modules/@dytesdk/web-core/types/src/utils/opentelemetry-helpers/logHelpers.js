import { globalFlagsmith as flagsmith } from '@dyteinternals/utils';
import { config as globalConfig } from '../config';
import { FlagsmithFeatureFlags } from '../flags';
import createSafeToLogError from './safeToLogErrorCreator';
export function isADyteTestingEnvironment() {
    const isStaging = typeof navigator !== 'undefined' && !navigator.isReactNative && window.location.host?.includes('staging') && window.location.host?.includes('dyte.io');
    const isDevEnvironment = !!import.meta.env.DEV || !!globalConfig.modules?.devTools?.logs;
    return isStaging || isDevEnvironment;
}
export function shouldSendLogToLogAggregator(currentLogEventSeverity) {
    if (flagsmith.hasFeature(FlagsmithFeatureFlags.LOG_LEVEL)) {
        let logLevel = flagsmith.getValue(FlagsmithFeatureFlags.LOG_LEVEL) || 'all';
        logLevel = logLevel.toLowerCase().trim();
        if (logLevel === 'off') {
            return false;
        }
        if (logLevel !== 'all') {
            const logLevelHierarchy = ['debug', 'log', 'info', 'warn', 'error'];
            const currentLogSeverityIndex = logLevelHierarchy.indexOf(currentLogEventSeverity);
            const logLevelSeverityIndex = logLevelHierarchy.indexOf(logLevel);
            if (currentLogSeverityIndex < logLevelSeverityIndex) {
                return false;
            }
        }
    }
    return true;
}
export function flattenObjForOpenTelemetry(obj, parentKey, res = {}) {
    Object.getOwnPropertyNames(obj).forEach((key) => {
        if ([null, undefined, NaN].includes(obj[key])) {
            return;
        }
        if (parentKey && (parentKey.match(/\./g)?.length || 0) >= 10) {
            return;
        }
        const propName = parentKey ? `${parentKey}.${key}` : key;
        if (typeof obj[key] === 'object') {
            flattenObjForOpenTelemetry(obj[key], propName, res);
        }
        else if (['number', 'string', 'boolean'].includes(typeof obj[key])) {
            res[propName] = obj[key];
        }
    });
    return res;
}
export function safelyFlattenObjForOpenTelemetry(eventName, metadata = {}, parentKey) {
    const res = {};
    try {
        const stringifiedMetadata = JSON.stringify(metadata);
        const cleanedMetadata = JSON.parse(stringifiedMetadata);
        const flattenedMetadata = flattenObjForOpenTelemetry(cleanedMetadata, parentKey);
        const stringifiedFlattenedMetadata = JSON.stringify(flattenedMetadata);
        if (stringifiedFlattenedMetadata.length > 5000) {
            const warningMessage = `Log named: "${eventName}" is trying to log an flattened object of size ${stringifiedFlattenedMetadata.length} chars that is beyond permitted limit of 5000 chars. Please optimize.`;
            const canConsoleLogToInformDev = isADyteTestingEnvironment();
            if (canConsoleLogToInformDev) {
                console.error(warningMessage, { log: metadata, flattened: stringifiedFlattenedMetadata });
            }
            throw new Error(warningMessage);
        }
        return JSON.parse(stringifiedFlattenedMetadata);
    }
    catch (ex) {
        const safeError = createSafeToLogError(ex);
        res[`${parentKey}.error.message`] = safeError.message || '';
        res[`${parentKey}.error.stack`] = safeError.stack || '';
        res[`${parentKey}.error.reason`] = safeError.reason || '';
        res[`${parentKey}.error.source`] = 'safelyFlattenObjForOpenTelemetry';
    }
    return res;
}
