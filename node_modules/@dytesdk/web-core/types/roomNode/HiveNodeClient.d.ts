import { ProducerState } from '../client/DyteParticipant';
import SocketService from '../socketService/SocketService';
import BaseRoomNodeClient from './BaseRoomNodeClient';
import HiveSFUHandler from './HiveSFUHandler';
import { Transport } from './hive-client/Transport';
export default class HiveNodeClient extends BaseRoomNodeClient {
    #private;
    legacyMode: boolean;
    roomNodeUrl: string;
    peerDisplayName: string;
    activatedProducingPeerIds: Set<string>;
    private logger;
    private _totalRejoinCount;
    constructor(options: {
        roomName: string;
        peerId: string;
        authToken: string;
        legacyMode: boolean;
        socketClient: SocketService;
        meetingTitle: string;
    });
    static init(options: {
        legacyMode?: boolean;
        roomName: string;
        roomNodeUrl: string;
        peerId: string;
        authToken: string;
        meetingTitle: string;
        socket: SocketService;
    }): Promise<HiveNodeClient>;
    get sfuHandler(): HiveSFUHandler;
    set onSocketReconnection(fn: (...args: any) => void);
    reconnectTransport(transport?: Transport): Promise<void>;
    setupTransports(): Promise<void>;
    joinRoom(displayName: string, audioMuted: boolean, roomUuid: string, roomTitle?: string, currentUserSharedMediaStates?: {
        audio?: boolean;
        video?: boolean;
        screen?: boolean;
    }): Promise<{
        roomJoined: boolean;
    }>;
    completeJoinRoom(): Promise<boolean>;
    leaveRoom(): Promise<void>;
    getConsumers(): Map<string, import("./hive-client/Consumer").Consumer>;
    activatePeers(producerInfos: {
        peerId: string;
        producers: ProducerState[];
        force?: boolean;
    }[]): Promise<void>;
    deactivatePeers(producerInfo: {
        peerId: string;
        producers: ProducerState[];
    }): Promise<void>;
    createConsumer({ producerId, producingPeerId, screenShare, }: {
        producingPeerId: string;
        producerId: string;
        screenShare?: boolean;
    }): Promise<void>;
    pauseConsumers(consumerIds: string[]): Promise<void>;
    resumeConsumers(consumerIds: string[]): Promise<void>;
    closeConsumers(peers: string[]): Promise<void>;
    private consumePeer;
    shareWebcam(videoTrack?: MediaStreamTrack): Promise<void>;
    shareScreen(tracks: {
        video?: MediaStreamTrack;
        audio?: MediaStreamTrack;
    }): Promise<void>;
    shareMic(audioTrack?: MediaStreamTrack): Promise<void>;
    pauseMic(): void;
    pauseWebcam(): Promise<void>;
    resumeMic(): Promise<void>;
    resumeWebcam(): Promise<void>;
    disableWebcam(): Promise<void>;
    disableMic(): Promise<void>;
    disableScreenShare(): Promise<void>;
    muteSelf(): Promise<void>;
    unmuteSelf(): Promise<void>;
    resetVideoProducers(videoTrack: MediaStreamTrack, screenShareTrack?: MediaStreamTrack): Promise<void>;
    getPolls(): Promise<{
        payload: {
            polls: {};
        };
    }>;
    changeDisplayName(displayName: string, peerId?: string): Promise<void>;
    kick(peerId: string): Promise<void>;
    kickAll(): Promise<void>;
    muteAll(allowUnMute: boolean): Promise<void>;
    muteAllVideo(): Promise<void>;
    mutePeer(peerId: string): Promise<void>;
    mutePeerVideo(peerId: string): Promise<void>;
    pinPeer(peerId: string | null): Promise<void>;
    handleSocketEvents(): Promise<void>;
    handleSFUEvents(): void;
}
