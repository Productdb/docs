import SocketService from '../socketService/SocketService';
import { BaseSFUHandler, TransportOpts } from './BaseSFUHandler';
import { Consumer } from './hive-client/Consumer';
import { Producer } from './hive-client/Producer';
import { Transport } from './hive-client/Transport';
import HiveSFUSocketHandler from '../socketService/HiveSFUSocketHandler';
import { PRODUCERS_TYPE } from './RoomNodeConfig';
export declare enum TransportState {
    CONNECTING = "connecting",
    RECONNECTING = "reconnecting",
    DISCONNECTED = "disconnected",
    CONNECTED = "connected",
    FAILED = "failed"
}
export default class HiveSFUHandler extends BaseSFUHandler {
    private _device;
    private _sendTransport;
    private _recvTransport;
    private _consumers;
    private _producers;
    private _producerIdToConsumerIdMap;
    private _logger;
    private _socket;
    private _socketHandler;
    private _totalTransportReconnectionCount;
    private _transportReconnectFailureCount;
    private _consumerCreationFailureCount;
    private _producerNotReadyFailureCount;
    private _consumerNotBoundFailureCount;
    transportConnectionStatus: Map<'send' | 'recv', Promise<void>>;
    constructor(socket: SocketService);
    get socket(): SocketService;
    get producers(): Map<string, Producer>;
    get consumers(): Map<string, Consumer>;
    get producerIdToConsumerIdMap(): Map<string, string>;
    get hiveSocketHandler(): HiveSFUSocketHandler;
    setupTransports(transportTypes: ('send' | 'recv')[]): Promise<void>;
    stopAllTransports(): Promise<void>;
    createSendTransport(transportOpts: TransportOpts): Promise<void>;
    createRecvTransport(transportOpts: TransportOpts): Promise<void>;
    handleTransport(transport: Transport, consuming: boolean): void;
    createProducer(producerType: PRODUCERS_TYPE, producerOptions: object, onDisconnect: () => void): Promise<void>;
    private _switchWebcamLayers;
    private _initConsumer;
    consumePeer(producingPeerId: string): Promise<void>;
    createConsumer(consumerOpts: any): Promise<void>;
    pauseProducer(type: string): Promise<void>;
    resumeProducer(type: string): Promise<void>;
    replaceTrack(type: string, track: MediaStreamTrack | null): Promise<void>;
    removeProducer(type: string, stopTrack?: boolean): Promise<void>;
    pauseConsumer(consumerId: string): Promise<void>;
    pauseConsumerOverSocket(consumer: Consumer): Promise<void>;
    toggleConsumerOverDC(consumerId: string, mute: boolean): Promise<void>;
    resumeConsumer(consumerId: string): Promise<void>;
    closeConsumer(consumerId: string, force?: boolean): Promise<void>;
    closeConsumers(consumerIds: string[], force?: boolean): Promise<void>;
    cleanupConsumers(peerId?: string): Promise<void>;
    stopAllProducers(): Promise<void>;
    private getProducer;
    private negotiate;
    private negotiateOverDC;
    private handleConsumerToggle;
    private handleErrorOverDC;
    private handleFailure;
}
