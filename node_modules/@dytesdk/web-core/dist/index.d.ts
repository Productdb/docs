import { MediaVideoQualityType, MediaScreenShareQualityType, PluginAccessControls } from '@dyteinternals/utils/dist/types/HybridPreset';
import { ViewType, WaitingRoomTypes, MediaProductionPermissionType, RecorderType } from '@dyteinternals/utils';
import { BorderRadius, BorderWidth, Theme } from '@dyteinternals/utils/dist/types/DesignTokens';
import { EventEmitter } from 'events';

declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
Get keys of the given type as strings.

Number keys are converted to strings.

Use-cases:
- Get string keys from a type which may have number keys.
- Makes it possible to index using strings retrieved from template types.

@example
```
import type {StringKeyOf} from 'type-fest';

type Foo = {
	1: number,
	stringKey: string,
};

type StringKeysOfFoo = StringKeyOf<Foo>;
//=> '1' | 'stringKey'
```

@category Object
*/
type StringKeyOf<BaseType> = `${Extract<keyof BaseType, string | number>}`;

declare class DyteEventEmitter<T extends string | symbol> extends EventEmitter {
    constructor();
    emit(event: T, ...args: any[]): boolean;
    on(event: T, callback: (...args: any[]) => void): this;
    addListener(event: T, callback: (...args: any[]) => any): this;
    off(event: T, callback: (...args: any[]) => any): this;
    once(event: T, callback: (...args: any[]) => any): this;
    prependListener(event: T, callback: (...args: any[]) => any): this;
    prependOnceListener(event: T, callback: (...args: any[]) => any): this;
    removeListener(event: T, callback: (...args: any[]) => any): this;
    removeAllListeners(event?: T): this;
    listeners(event: T): Function[];
    listenerCount(event: T): number;
}
type EventMap = {
    [key: string]: (...args: any[]) => void;
};
type WildCardEvent<T> = {
    ['*']: (event: StringKeyOf<T>, ...args: any) => void;
};
declare class DyteTypedEventEmitter<Events extends EventMap & WildCardEvent<Events>> extends EventEmitter {
    constructor();
    emit<E extends StringKeyOf<Events>>(event: E, ...args: Parameters<Events[E]>): boolean;
    on<E extends StringKeyOf<Events>>(event: E, callback: Events[E]): this;
    addListener<E extends StringKeyOf<Events>>(event: E, callback: Events[E]): this;
    off<T extends StringKeyOf<Events>>(event: T, callback: Events[T]): this;
    once<T extends StringKeyOf<Events>>(event: T, callback: Events[T]): this;
    prependListener<T extends StringKeyOf<Events>>(event: T, callback: Events[T]): this;
    prependOnceListener<T extends StringKeyOf<Events>>(event: T, callback: Events[T]): this;
    removeListener<T extends StringKeyOf<Events>>(event: T, callback: Events[T]): this;
    removeAllListeners<T extends StringKeyOf<Events>>(event?: T): this;
    listeners<T extends StringKeyOf<Events>>(event: T): Function[];
    listenerCount<T extends StringKeyOf<Events>>(event: T): number;
}

type PresetMediaConstraints = PresetV2CamelCased['config']['media'];
type AudioQualityConstraints = {
    echoCancellation?: boolean;
    noiseSupression?: boolean;
    autoGainControl?: boolean;
    enableStereo?: boolean;
    enableHighBitrate?: boolean;
};
type VideoQualityConstraints = {
    width: {
        ideal: number;
    };
    height: {
        ideal: number;
    };
    frameRate?: {
        ideal: number;
    };
};
type ScreenshareQualityConstraints = {
    width?: {
        max: number;
    };
    height?: {
        max: number;
    };
    frameRate?: {
        ideal: number;
        max: number;
    };
};
interface DyteMediaTrackConstraints extends MediaTrackConstraints {
    optional?: Array<object>;
}
interface DyteMediaStreamConstraints extends MediaStreamConstraints {
    audio?: boolean | DyteMediaTrackConstraints;
}
type MediaConstraints = {
    audio?: AudioQualityConstraints;
    video?: MediaVideoQualityType | VideoQualityConstraints;
    screenshare?: ScreenshareQualityConstraints;
};
declare class ConstraintBuilder {
    #private;
    constructor(mediaConstraints?: MediaConstraints);
    getScreenShareConstraints: () => {
        audio: boolean;
        video: {
            width: {
                max: number;
            };
            height: {
                max: number;
            };
            frameRate: {
                ideal: number;
                max: number;
            };
        };
    };
    getAudioConstraints: (audioDeviceId?: string) => DyteMediaStreamConstraints;
    getVideoConstraints: (videoDeviceId?: string) => DyteMediaStreamConstraints;
    getUpdatedVideoConstraints(resolution: VideoQualityConstraints): MediaTrackConstraints;
}

type PresetV2CamelCased = {
    config: {
        viewType: ViewType;
        media: {
            audio: {
                enableStereo: boolean;
                enableHighBitrate: boolean;
            };
            video: {
                quality: MediaVideoQualityType;
                frameRate: number;
            };
            screenshare: {
                quality: MediaScreenShareQualityType;
                frameRate: number;
            };
        };
        maxVideoStreams: {
            mobile: number;
            desktop: number;
        };
        maxScreenshareCount: number;
    };
    permissions: {
        acceptWaitingRequests: boolean;
        canAcceptProductionRequests: boolean;
        canEditDisplayName: boolean;
        canRecord: boolean;
        canLivestream: boolean;
        canSpotlight?: boolean;
        disableParticipantAudio: boolean;
        disableParticipantScreensharing: boolean;
        disableParticipantVideo: boolean;
        kickParticipant: boolean;
        pinParticipant: boolean;
        plugins: {
            canClose: boolean;
            canStart: boolean;
            canEditConfig?: boolean;
            config: {
                [pluginId: string]: Partial<{
                    accessControl: PluginAccessControls.FULL_ACCESS | PluginAccessControls.VIEW_ONLY;
                    disabled: boolean;
                    handlesViewOnly: boolean;
                }>;
            };
        };
        waitingRoomType: WaitingRoomTypes;
        polls: {
            canCreate: boolean;
            canVote: boolean;
            canView: boolean;
        };
        media: {
            video: {
                canProduce: MediaProductionPermissionType;
            };
            audio: {
                canProduce: MediaProductionPermissionType;
            };
            screenshare: {
                canProduce: MediaProductionPermissionType;
            };
        };
        chat: {
            public: {
                canSend: boolean;
                text: boolean;
                files: boolean;
            };
            private?: {
                canSend: boolean;
                canReceive: boolean;
                text: boolean;
                files: boolean;
            };
            channel?: {
                canCreate: 'NONE' | 'PRIVATE' | 'PUBLIC' | 'ALL';
                canDelete: 'NONE' | 'PRIVATE' | 'PUBLIC' | 'ALL';
                canUpdate: 'NONE' | 'PRIVATE' | 'PUBLIC' | 'ALL';
                canReadAll: boolean;
            };
            message?: {
                canDelete: 'NONE' | 'SELF' | 'ALL';
                canEdit: 'NONE' | 'SELF' | 'ALL';
                deleteCutoffTimeSeconds: number;
                editCutoffTimeSeconds: number;
            };
        };
        isRecorder?: boolean;
        recorderType: RecorderType;
        hiddenParticipant: boolean;
        showParticipantList: boolean;
        canChangeParticipantPermissions: boolean;
        connectedMeetings: {
            canAlterConnectedMeetings: boolean;
            canSwitchConnectedMeetings: boolean;
            canSwitchToParentMeeting: boolean;
        };
        acceptStageRequests?: boolean;
        stageEnabled?: boolean;
        stageAccess?: MediaProductionPermissionType;
        transcriptionEnabled: boolean;
    };
    ui: {
        designTokens: {
            borderRadius: BorderRadius;
            borderWidth: BorderWidth;
            colors: {
                brand: {
                    300: string;
                    400: string;
                    500: string;
                    600: string;
                    700: string;
                };
                background: {
                    600: string;
                    700: string;
                    800: string;
                    900: string;
                    1000: string;
                };
                danger: string;
                success: string;
                textOnBrand: string;
                text: string;
                videoBg: string;
                warning: string;
            };
            fontFamily?: string;
            googleFont?: string;
            logo?: string;
            spacingBase: number;
            theme: Theme;
        };
        configDiff: any;
    };
    version?: string;
    id?: string;
    name?: string;
};
type MaxVideoStreams = PresetV2CamelCased['config']['maxVideoStreams'];
declare class DyteThemePreset$1 {
    #private;
    private constructor();
    static fromResponse(preset: PresetV2CamelCased): DyteThemePreset$1;
    static default(): DyteThemePreset$1;
    get setupScreen(): Readonly<{
        isEnabled: boolean;
    }>;
    get waitingRoom(): Readonly<{
        isEnabled: boolean;
    }>;
    get controlBar(): Readonly<{
        isEnabled: boolean;
        elements?: {
            chat?: boolean;
            fullscreen?: boolean;
            invite?: boolean;
            layout?: boolean;
            participants?: boolean;
            plugins?: boolean;
            polls?: boolean;
            reactions?: boolean;
            screenshare?: boolean;
        };
    }>;
    get header(): Readonly<{
        isEnabled: boolean;
        elements: {
            logo: string;
            timer: boolean;
            title: boolean;
            participantCount: boolean;
            changeLayout: boolean;
        };
    }>;
    get pipMode(): Readonly<boolean>;
    get viewType(): Readonly<ViewType>;
    get maxVideoStreams(): Readonly<MaxVideoStreams>;
    get maxScreenShareCount(): Readonly<number>;
    get plugins(): Readonly<string[]>;
    get disabledPlugins(): Readonly<string[]>;
    get designTokens(): Readonly<PresetV2CamelCased['ui']['designTokens']>;
    get configDiff(): Readonly<PresetV2CamelCased['ui']['configDiff']>;
    get mediaConstraints(): Readonly<PresetMediaConstraints>;
    get isV2(): true;
}

type PresetPermissions = PresetV2CamelCased['permissions'];
type MediaRoomType$1 = 'HIVE' | 'ROOM_NODE';
type PermissionEvents = {
    ['chatUpdate']: () => void;
    ['pollsUpdate']: () => void;
    ['pluginsUpdate']: () => void;
    ['*']: () => void;
};
declare class DytePermissionsPreset$1 extends DyteTypedEventEmitter<PermissionEvents> {
    #private;
    private constructor();
    private setupEvents;
    static fromResponse(response: PresetPermissions, viewType: ViewType, useHive: boolean): DytePermissionsPreset$1;
    static default(viewType: ViewType, useHive: boolean): DytePermissionsPreset$1;
    get mediaRoomType(): Readonly<MediaRoomType$1>;
    get stageEnabled(): Readonly<boolean>;
    get acceptStageRequests(): Readonly<boolean>;
    get stageAccess(): Readonly<MediaProductionPermissionType>;
    get acceptWaitingRequests(): Readonly<boolean>;
    get requestProduceVideo(): Readonly<boolean>;
    get requestProduceAudio(): Readonly<boolean>;
    get requestProduceScreenshare(): Readonly<boolean>;
    get canAllowParticipantAudio(): Readonly<boolean>;
    get canAllowParticipantScreensharing(): Readonly<boolean>;
    get canAllowParticipantVideo(): Readonly<boolean>;
    get canDisableParticipantAudio(): Readonly<boolean>;
    get canDisableParticipantVideo(): Readonly<boolean>;
    get kickParticipant(): Readonly<boolean>;
    get pinParticipant(): Readonly<boolean>;
    get canRecord(): Readonly<boolean>;
    get waitingRoomType(): Readonly<WaitingRoomTypes>;
    get waitingRoomBehaviour(): Readonly<WaitingRoomTypes>;
    get plugins(): Readonly<PresetPermissions['plugins']>;
    get polls(): Readonly<PresetPermissions['polls']>;
    get produceVideo(): Readonly<MediaProductionPermissionType>;
    get requestProduce(): Readonly<boolean>;
    get canProduceVideo(): Readonly<MediaProductionPermissionType>;
    get produceScreenshare(): Readonly<MediaProductionPermissionType>;
    get canProduceScreenshare(): Readonly<MediaProductionPermissionType>;
    get produceAudio(): Readonly<MediaProductionPermissionType>;
    get canProduceAudio(): Readonly<MediaProductionPermissionType>;
    get chatPublic(): Readonly<PresetPermissions['chat']['public']>;
    get chatPrivate(): Readonly<PresetPermissions['chat']['private']>;
    get chatChannel(): Readonly<PresetPermissions['chat']['channel']>;
    get chatMessage(): Readonly<PresetPermissions['chat']['message']>;
    get connectedMeetings(): Readonly<PresetPermissions['connectedMeetings']>;
    get hiddenParticipant(): Readonly<boolean>;
    get showParticipantList(): Readonly<boolean>;
    get canChangeParticipantRole(): Readonly<boolean>;
    get canChangeParticipantPermissions(): Readonly<boolean>;
    get canChangeTheme(): Readonly<boolean>;
    get canPresent(): Readonly<boolean>;
    get acceptPresentRequests(): Readonly<boolean>;
    get canEditDisplayName(): Readonly<boolean>;
    get maxScreenShareCount(): Readonly<number>;
    get isRecorder(): Readonly<boolean>;
    get canSpotlight(): Readonly<boolean>;
    get canLivestream(): Readonly<boolean>;
    get transcriptionEnabled(): Readonly<boolean>;
    get isV2(): true;
}

declare enum WaitingRoomType {
    skip = "SKIP",
    onPrivilegedUserEntry = "ON_PRIVILEGED_USER_ENTRY",
    skipOnAccept = "SKIP_ON_ACCEPT"
}
declare enum CanProduceType {
    allowed = "ALLOWED",
    notAllowed = "NOT_ALLOWED",
    canRequest = "CAN_REQUEST"
}
interface PollsPermission {
    canCreate: boolean;
    canVote: boolean;
    canViewResults: boolean;
    canView: boolean;
}
type MediaRoomType = 'HIVE' | 'ROOM_NODE';
interface PresetPermissionsV1 {
    viewType: ViewType;
    acceptWaitingRequests: boolean;
    requestProduce: boolean;
    canAllowParticipantAudio: boolean;
    canAllowParticipantScreensharing: boolean;
    canAllowParticipantVideo: boolean;
    requestKickParticipant: boolean;
    kickParticipant: boolean;
    pinParticipant: boolean;
    canRecord: boolean;
    waitingRoomType: string;
    plugins: {
        canClose: boolean;
        canStart: boolean;
        canEditAcl: boolean;
        config: {
            [key: string]: any;
        };
    };
    polls: {
        canCreate: boolean;
        canVote: boolean;
        canView: boolean;
    };
    produce: {
        video: {
            allow: boolean;
            quality: MediaVideoQualityType;
            frameRate: number;
        };
        audio: boolean;
        screenshare: {
            allow: boolean;
            quality: MediaScreenShareQualityType;
            frameRate: number;
        };
    };
    chat: {
        public: {
            canSend: boolean;
            text: boolean;
            files: boolean;
        };
        private: {
            canSend: boolean;
            canReceive: boolean;
            text: boolean;
            files: boolean;
        };
    };
    reactions: boolean;
    hiddenParticipant: boolean;
    showParticipantList: boolean;
    canChangeParticipantRole: boolean;
    canChangeTheme: boolean;
    canPresent: boolean;
    acceptPresentRequests: boolean;
    canEditDisplayName: boolean;
    maxScreenshareCount: number;
    isRecorder: boolean;
    canSpotlight: boolean;
}
declare class DytePermissionsPresetV1$1 extends DyteTypedEventEmitter<PermissionEvents> {
    #private;
    private constructor();
    private setupEvents;
    static fromResponse(response: PresetPermissionsV1, useHive: boolean): DytePermissionsPresetV1$1;
    static default(useHive: boolean): DytePermissionsPresetV1$1;
    get mediaRoomType(): Readonly<MediaRoomType>;
    get viewType(): Readonly<string>;
    get stageEnabled(): Readonly<boolean>;
    get stageAccess(): Readonly<CanProduceType>;
    get acceptWaitingRequests(): Readonly<boolean>;
    get requestProduce(): Readonly<boolean>;
    get requestProduceAudio(): Readonly<boolean>;
    get requestProduceScreenshare(): Readonly<boolean>;
    get canAllowParticipantAudio(): Readonly<boolean>;
    get canAllowParticipantScreensharing(): Readonly<boolean>;
    get canAllowParticipantVideo(): Readonly<boolean>;
    get canDisableParticipantAudio(): Readonly<boolean>;
    get canDisableParticipantVideo(): Readonly<boolean>;
    get kickParticipant(): Readonly<boolean>;
    get pinParticipant(): Readonly<boolean>;
    get canRecord(): Readonly<boolean>;
    get waitingRoomType(): Readonly<string>;
    get waitingRoomBehaviour(): Readonly<WaitingRoomType>;
    get plugins(): Readonly<{
        canClose: boolean;
        canStart: boolean;
        canEditAcl: boolean;
        config: {
            [key: string]: any;
        };
    }>;
    get polls(): Readonly<PollsPermission>;
    get produceVideo(): Readonly<{
        allow: CanProduceType;
        quality: string;
        frameRate: number;
    }>;
    get canProduceVideo(): Readonly<CanProduceType>;
    get produceScreenshare(): Readonly<{
        allow: CanProduceType;
        quality: string;
        frameRate: number;
    }>;
    get canProduceScreenshare(): Readonly<CanProduceType>;
    get produceAudio(): Readonly<CanProduceType>;
    get canProduceAudio(): Readonly<CanProduceType>;
    get chatPublic(): Readonly<{
        canSend: boolean;
        text: boolean;
        files: boolean;
    }>;
    get transcriptionEnabled(): Readonly<boolean>;
    get chatPrivate(): Readonly<{
        canSend: boolean;
        text: boolean;
        files: boolean;
        canReceive?: boolean;
    }>;
    get chatChannel(): Readonly<{
        canCreate: 'NONE' | 'PRIVATE' | 'PUBLIC' | 'ALL';
        canDelete: 'NONE' | 'PRIVATE' | 'PUBLIC' | 'ALL';
        canUpdate: 'NONE' | 'PRIVATE' | 'PUBLIC' | 'ALL';
        canReadAll: boolean;
    }>;
    get chatMessage(): Readonly<{
        canDelete: 'NONE' | 'SELF' | 'ALL';
        canEdit: 'NONE' | 'SELF' | 'ALL';
        deleteCutoffTimeSeconds: number;
        editCutoffTimeSeconds: number;
    }>;
    get connectedMeetings(): {
        canAlterConnectedMeetings: boolean;
        canSwitchConnectedMeetings: boolean;
        canSwitchToParentMeeting: boolean;
    };
    get reactions(): Readonly<boolean>;
    get hiddenParticipant(): Readonly<boolean>;
    get showParticipantList(): Readonly<boolean>;
    get canChangeParticipantRole(): Readonly<boolean>;
    get canChangeTheme(): Readonly<boolean>;
    get canPresent(): Readonly<boolean>;
    get acceptPresentRequests(): Readonly<boolean>;
    get acceptStageRequests(): Readonly<boolean>;
    get canEditDisplayName(): Readonly<boolean>;
    get maxScreenShareCount(): Readonly<number>;
    get isRecorder(): Readonly<boolean>;
    get canLivestream(): Readonly<boolean>;
    get canSpotlight(): Readonly<boolean>;
    get isV2(): false;
}

interface EnabledInner {
    isEnabled: boolean;
}
interface PresetThemeV1 {
    setupScreen: EnabledInner;
    aloneHere: EnabledInner;
    waitingRoom: {
        isEnabled: boolean;
        enablePreview: boolean;
    };
    controlBar: {
        isEnabled: boolean;
        elements: {
            plugins: boolean;
            screenshare: boolean;
            invite: boolean;
            participants: boolean;
            chat: boolean;
            reactions: boolean;
            polls: boolean;
            fullscreen: boolean;
            layout: boolean;
        };
    };
    header: {
        isEnabled: boolean;
        elements: {
            logo: string;
            timer: boolean;
            title: boolean;
            participantCount: boolean;
            changeLayout: boolean;
        };
    };
    pipMode: boolean;
    autoTune: boolean;
    grid: {
        multi: {
            maxVideoCount: number;
            videoFit: string;
        };
        single: {
            maxVideoCount: number;
            videoFit: string;
        };
        defaultView: string;
    };
    colors: {
        primary: string;
        secondary: string;
        text: string;
        background: string;
        textPrimary: string;
        videoBackground: string;
    };
    controls: {
        pipToggle: boolean;
    };
    plugins: string[];
}
declare class DyteThemePresetV1$1 {
    #private;
    private constructor();
    static fromResponse(theme: PresetThemeV1): DyteThemePresetV1$1;
    static default(): DyteThemePresetV1$1;
    configFromPermissions(permissions: PresetPermissionsV1): void;
    setDisabledPlugins(allPluginIds: string[]): void;
    get setupScreen(): Readonly<EnabledInner>;
    get aloneHere(): Readonly<EnabledInner>;
    get waitingRoom(): Readonly<{
        isEnabled: boolean;
        enablePreview: boolean;
    }>;
    get controlBar(): Readonly<{
        isEnabled: boolean;
        elements: {
            plugins: boolean;
            screenshare: boolean;
            invite: boolean;
            participants: boolean;
            chat: boolean;
            reactions: boolean;
            polls: boolean;
            fullscreen: boolean;
            layout: boolean;
        };
    }>;
    get header(): Readonly<{
        isEnabled: boolean;
        elements: {
            logo: string;
            timer: boolean;
            title: boolean;
            participantCount: boolean;
            changeLayout: boolean;
        };
    }>;
    get pipMode(): Readonly<boolean>;
    get viewType(): Readonly<ViewType>;
    get autoTune(): Readonly<boolean>;
    get grid(): Readonly<{
        multi: {
            maxVideoCount: number;
            videoFit: string;
        };
        single: {
            maxVideoCount: number;
            videoFit: string;
        };
        defaultView: string;
    }>;
    get maxVideoStreams(): Readonly<MaxVideoStreams>;
    get maxScreenShareCount(): Readonly<number>;
    get colors(): Readonly<{
        primary: string;
        secondary: string;
        text: string;
        background: string;
        textPrimary: string;
        videoBackground: string;
    }>;
    get controls(): Readonly<{
        pipToggle: boolean;
    }>;
    get plugins(): Readonly<string[]>;
    get disabledPlugins(): Readonly<string[]>;
    get mediaConstraints(): Readonly<PresetMediaConstraints>;
    get isV2(): false;
}

type DCMessage = {
    type: string;
    payload: Record<string, unknown>;
};

type MediaKind = 'audio' | 'video';

declare const localMediaEvents: readonly ["AUDIO_TRACK_CHANGE", "VIDEO_TRACK_CHANGE", "SCREENSHARE_TRACK_CHANGE", "SCREENSHARE_ENDED", "AUDIO_TRACK_SILENT", "FORCE_MUTE_AUDIO", "FORCE_MUTE_VIDEO", "DEVICE_CHANGE", "DEVICE_LIST_UPDATED"];
declare const troubleshooterEvents: readonly ["audioTrackStats", "audioTrackUpdate", "videoTrackStats", "videoTrackUpdate", "connectionDelayStats", "audioProductionStats", "videoProductionStats", "audioConsumptionStats", "videoConsumptionStats", "connectionUpdate"];
type LocalMediaEvents = (typeof localMediaEvents)[number] | '*';
type TroubleshooterEvents = (typeof troubleshooterEvents)[number] | '*';
type ParticipantEvents = {
    ['videoUpdate']: (payload: {
        videoEnabled: boolean;
        videoTrack: MediaStreamTrack;
    }) => void;
    ['audioUpdate']: (payload: {
        audioEnabled: boolean;
        audioTrack: MediaStreamTrack;
    }) => void;
    ['screenShareUpdate']: (payload: {
        screenShareEnabled: boolean;
        screenShareTracks: {
            audio: MediaStreamTrack;
            video: MediaStreamTrack;
        };
    }) => void;
    ['pinned']: (payload: DyteParticipant) => void;
    ['unpinned']: (payload: DyteParticipant) => void;
    ['poorConnection']: (payload: {
        score: number;
        kind: string;
    }) => void;
    ['peerRequestToJoinStage']: (payload: DyteParticipant) => void;
    ['peerRejectedToJoinStage']: (payload: DyteParticipant) => void;
    ['peerAcceptedToJoinStage']: (payload: DyteParticipant) => void;
    ['peerStoppedPresenting']: (payload: DyteParticipant) => void;
    ['peerStartedPresenting']: (payload: DyteParticipant) => void;
    ['stageStatusUpdate']: (payload: DyteParticipant) => void;
    ['mediaScoreUpdate']: (payload: {
        kind: MediaKind;
        isScreenshare: boolean;
        score: number;
        participantId: string;
    }) => void;
    ['kicked']: () => void;
    ['*']: (event: string, ...args: any[]) => void;
};
type SelfEvents = {
    ['videoUpdate']: (payload: {
        videoEnabled: boolean;
        videoTrack: MediaStreamTrack;
    }) => void;
    ['audioUpdate']: (payload: {
        audioEnabled: boolean;
        audioTrack: MediaStreamTrack;
    }) => void;
    ['screenShareUpdate']: (payload: {
        screenShareEnabled: boolean;
        screenShareTracks: {
            audio?: MediaStreamTrack;
            video?: MediaStreamTrack;
        };
    }) => void;
    ['joinStageRequestAccepted']: () => void;
    ['joinStageRequestRejected']: () => void;
    ['peerRequestToJoinStage']: () => void;
    ['stageLeft']: () => void;
    ['deviceUpdate']: ({ device }: {
        device: MediaDeviceInfo;
    }) => void;
    ['deviceListUpdate']: (changedDevices: {
        added: MediaDeviceInfo[];
        removed: MediaDeviceInfo[];
    }) => void;
    ['pinned']: (payload: DyteSelf) => void;
    ['unpinned']: (payload: DyteSelf) => void;
    ['mediaPermissionUpdate']: (payload: {
        message: keyof typeof MediaPermission;
        kind: 'audio' | 'video' | 'screenshare';
    }) => void;
    ['mediaPermissionError']: (payload: {
        message: keyof typeof MediaPermission;
        constraints: any;
        kind: 'audio' | 'video' | 'screenshare';
    }) => void;
    ['mediaScoreUpdate']: (payload: {
        kind: MediaKind;
        isScreenshare: boolean;
        score: number;
        participantId: string;
    }) => void;
    ['waitlisted']: () => void;
    ['stageJoined']: () => void;
    ['socketServiceRoomJoined']: () => void;
    ['removedFromStage']: () => void;
    ['roomLeft']: (payload: {
        state: leaveRoomState;
    }) => void;
    ['roomJoined']: () => void;
    ['*']: (event: string, ...args: any[]) => void;
};

interface DeviceConfig {
    browserName: string;
    browserVersion: string;
    isMobile: boolean;
    engineName: string;
    osName: string;
}
interface ProducerState$1 {
    producerId: string;
    kind: 'audio' | 'video';
    pause: boolean;
    screenShare: boolean;
}
interface Participant {
    id: string;
    userId: string;
    displayName: string;
    device?: DeviceConfig;
    picture?: string;
    isHost: boolean;
    flags: {
        [key: string]: string | boolean;
    };
    clientSpecificId?: string;
    customParticipantId?: string;
    stageStatus?: WebinarStageStatus;
    audioMuted: boolean;
    audioTrack: MediaStreamTrack;
    videoTrack: MediaStreamTrack;
    videoEnabled: boolean;
    producers?: ProducerState$1[];
    metadata?: {
        preset_name?: string;
    };
    recorderType?: string;
}
declare class DyteParticipant$1 extends DyteTypedEventEmitter<ParticipantEvents> {
    #private;
    id: string;
    userId: string;
    name: string;
    picture: string;
    isHost: boolean;
    customParticipantId?: string;
    get clientSpecificId(): string;
    flags: {
        [key: string]: string | boolean;
    };
    device: DeviceConfig;
    videoTrack: MediaStreamTrack;
    audioTrack: MediaStreamTrack;
    screenShareTracks: {
        audio: MediaStreamTrack;
        video: MediaStreamTrack;
    };
    videoEnabled: boolean;
    audioEnabled: boolean;
    screenShareEnabled: boolean;
    producers: ProducerState$1[];
    supportsRemoteControl: boolean;
    presetName?: string;
    get webinarStageStatus(): WebinarStageStatus | StageStatus;
    get stageStatus(): WebinarStageStatus | StageStatus;
    private get roomJoined();
    constructor(participant: Participant, self: DyteSelf);
    setVideoEnabled(videoEnabled: boolean, emitEvent?: boolean): void;
    setAudioEnabled(audioEnabled: boolean, emitEvent?: boolean): void;
    setScreenShareEnabled(screenShareEnabled: boolean, emitEvent?: boolean): void;
    private setupEvents;
    pin(): Promise<void>;
    unpin(): Promise<void>;
    setIsPinned(isPinned: boolean, emitEvent?: boolean): void;
    disableAudio(): Promise<void>;
    kick(): Promise<void>;
    disableVideo(): Promise<void>;
    acceptJoinStageRequest(): Promise<void>;
    rejectRequestToJoinStage(): Promise<void>;
    getPermissions(): Promise<any>;
    removeFromStage(): Promise<void>;
    setStageStatus(webinarStageStatus: StageStatus | WebinarStageStatus): void;
    setWebinarStageStatus(webinarStageStatus: WebinarStageStatus): void;
    get isPinned(): boolean;
}

type MediaPermission$1 = 'NOT_REQUESTED' | 'ACCEPTED' | 'DENIED' | 'SYSTEM_DENIED' | 'COULD_NOT_START' | 'CANCELED';
declare abstract class BaseMediaInterface {
    permissions: {
        audio?: MediaPermission$1;
        video?: MediaPermission$1;
        screenshare?: MediaPermission$1;
    };
    constructor();
    abstract getAvailableDevices(): Promise<InputDeviceInfo[]>;
    abstract getDevice(deviceId: string): Promise<MediaDeviceInfo>;
    getAudioInputDevices(): Promise<InputDeviceInfo[]>;
    getVideoInputDevices(): Promise<InputDeviceInfo[]>;
    getAudioOutputDevices(): Promise<InputDeviceInfo[]>;
    abstract getAudioAndVideoTrack(): Promise<{
        audioTrack: MediaStreamTrack;
        videoTrack: MediaStreamTrack;
    }>;
    abstract getAudioTrack(isMutedOnInit: boolean, deviceId?: string): Promise<MediaStreamTrack | undefined>;
    abstract getVideoTrack(deviceId?: string): Promise<MediaStreamTrack | undefined>;
    abstract getScreenShareTracks(): Promise<{
        audioTrack?: MediaStreamTrack;
        videoTrack?: MediaStreamTrack;
    }>;
}

interface ResponseStatus {
    success: boolean;
    message: string;
}

type AudioMiddleware$1 = (audioContext: AudioContext) => Promise<ScriptProcessorNode | AudioWorkletNode>;

type VideoMiddleware$1 = () => (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => Promise<void>;

declare class LocalMediaHandler extends DyteEventEmitter<LocalMediaEvents> {
    #private;
    audioUpdateInProgress: boolean;
    videoUpdateInProgress: boolean;
    constructor(mediaConstraints: MediaConstraints, isNonPreferredDevice?: (media: MediaDeviceInfo) => boolean, autoSwitchDevice?: boolean);
    private onVisibilityChange;
    repopulateAvailableDevices(): Promise<boolean>;
    setupStreams({ audio, video, }: {
        audio: boolean;
        video: boolean;
    }): Promise<void>;
    getCurrentDevices(): {
        audio: MediaDeviceInfo;
        video: MediaDeviceInfo;
        speaker: MediaDeviceInfo;
    };
    get permissions(): {
        audio?: MediaPermission$1;
        video?: MediaPermission$1;
        screenshare?: MediaPermission$1;
    };
    getAllDevices(): Promise<InputDeviceInfo[]>;
    getDeviceById(deviceId: string, kind?: 'audioinput' | 'audiooutput' | 'videoinput'): Promise<MediaDeviceInfo>;
    private onAudioTrackMuted;
    private onAudioTrackChanged;
    get rawAudioTrack(): MediaStreamTrack;
    get audioTrack(): MediaStreamTrack;
    get audioEnabled(): boolean;
    enableAudio(): Promise<void>;
    disableAudio(): void;
    getAudioDevices(): Promise<MediaDeviceInfo[]>;
    setAudioDevice(device: MediaDeviceInfo): Promise<void>;
    setupSpeaker(): Promise<void>;
    setSpeakerDevice(device: MediaDeviceInfo): Promise<void>;
    private onVideoTrackChanged;
    private onVideoTrackEnded;
    get rawVideoTrack(): MediaStreamTrack;
    get videoTrack(): MediaStreamTrack;
    get videoEnabled(): boolean;
    enableVideo(): Promise<void>;
    disableVideo(): void;
    getVideoDevices(): Promise<InputDeviceInfo[]>;
    setVideoDevice(device: MediaDeviceInfo): Promise<void>;
    updateVideoConstraints(resolution: VideoQualityConstraints): Promise<void>;
    private onScreenShareEnded;
    get screenShareTracks(): {
        audio: MediaStreamTrack;
        video: MediaStreamTrack;
    };
    get screenShareEnabled(): boolean;
    enableScreenShare(): Promise<void>;
    disableScreenShare(): Promise<void>;
    updateScreenshareConstraints(resolution: VideoQualityConstraints): Promise<void>;
    getSpeakerDevices(): Promise<InputDeviceInfo[]>;
    addAudioMiddleware(audioMiddleware: AudioMiddleware$1): Promise<ResponseStatus>;
    removeAudioMiddleware(audioMiddleware: AudioMiddleware$1): Promise<ResponseStatus>;
    addVideoMiddleware(videoMiddleware: VideoMiddleware$1): Promise<ResponseStatus>;
    removeVideoMiddleware(videoMiddleware: VideoMiddleware$1): Promise<ResponseStatus>;
    destruct(): void;
    onDeviceChange(changedDevices: {
        added: MediaDeviceInfo[];
        removed: MediaDeviceInfo[];
    }, skipDeviceChange: boolean): Promise<void>;
    removeAllTracks(): void;
    removeDocumentEventListeners(): Promise<void>;
}

type AudioMiddleware = (audioContext: AudioContext) => Promise<ScriptProcessorNode | AudioWorkletNode>;
type VideoMiddleware = () => (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => Promise<void>;
declare class MediaMiddlewareUtils {
    #private;
    audioMiddlewares: AudioMiddleware[];
    videoMiddlewares: VideoMiddleware[];
    constructor(localMediaHandler: LocalMediaHandlerDeprecated);
    terminateMiddlewareWebWorker(): void;
    getTransformedVideoTrack(originalVideoTrack: MediaStreamTrack): Promise<MediaStreamTrack>;
    addVideoMiddleware(videoMiddleware: VideoMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    removeVideoMiddleware(videoMiddleware: VideoMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    getTransformedAudioTrack(originalAudioTrack: MediaStreamTrack): Promise<MediaStreamTrack>;
    addAudioMiddleware(audioMiddleware: AudioMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    removeAudioMiddleware(audioMiddleware: AudioMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
}

declare enum MediaPermission {
    NOT_REQUESTED = 0,
    ACCEPTED = 1,
    DENIED = 2,
    CANCELED = 3,
    SYSTEM_DENIED = 4,
    COULD_NOT_START = 5
}

declare enum MediaEvents {
    AUDIO_TRACK_CHANGE = 0,
    VIDEO_TRACK_CHANGE = 1,
    SCREENSHARE_TRACK_CHANGE = 2,
    SCREENSHARE_ENDED = 3,
    AUDIO_TRACK_SILENT = 4,
    FORCE_MUTE_AUDIO = 5,
    FORCE_MUTE_VIDEO = 6,
    DEVICE_CHANGE = 7,
    DEVICE_LIST_UPDATED = 8
}
declare class LocalMediaHandlerDeprecated extends EventEmitter {
    #private;
    mediaMiddlewareUtils: MediaMiddlewareUtils;
    audioTrack: MediaStreamTrack;
    rawAudioTrack: MediaStreamTrack;
    videoTrack: MediaStreamTrack;
    rawVideoTrack: MediaStreamTrack;
    screenShareTracks: {
        audio?: MediaStreamTrack;
        video?: MediaStreamTrack;
    };
    audioEnabled: boolean;
    videoEnabled: boolean;
    screenShareEnabled: boolean;
    currentDevices: {
        audio: MediaDeviceInfo;
        video: MediaDeviceInfo;
        speaker: MediaDeviceInfo;
    };
    permissions: {
        audio?: keyof typeof MediaPermission;
        video?: keyof typeof MediaPermission;
        screenshare?: keyof typeof MediaPermission;
    };
    audioUpdateInProgress: boolean;
    videoUpdateInProgress: boolean;
    screenShareUpdateInProgress: boolean;
    private initialSetupComplete;
    private constructor();
    private handlePermissionErrors;
    repopulateAvailableDevices(): Promise<void>;
    private onVisibilityChange;
    private conditionallyRestartAudio;
    private conditionallyRestartVideo;
    private shouldReacquireTrack;
    private onAudioUnmute;
    private onVideoUnmute;
    private removeMediaStreamTrackListeners;
    private addMediaStreamTrackListeners;
    private notifyIfTrackSilent;
    setupAudioStream(deviceId?: string, forceStopTrack?: boolean): Promise<void>;
    private getPreferredDeviceId;
    setupVideoStream(deviceId?: string, forceStopTrack?: boolean): Promise<void>;
    setupScreenShareStreams(): Promise<void>;
    setupSpeaker(deviceId?: string): Promise<void>;
    getOperationalWebcamDeviceId(): Promise<{
        isOperational: boolean;
        deviceId: string;
    }>;
    getOperationalMicDeviceId(): Promise<{
        isOperational: boolean;
        deviceId: string;
    }>;
    setupStreams({ audio, video, }: {
        audio: boolean;
        video: boolean;
    }): Promise<void>;
    private stopAudioTrack;
    private stopVideoTrack;
    private stopScreenShareTracks;
    removeAudioTrack(): void;
    removeVideoTrack(): void;
    removeScreenShareTracks(tracks?: {
        audio?: boolean;
        video?: boolean;
    }): void;
    removeAllTracks(): void;
    setAudioTrack(audioTrack: MediaStreamTrack): void;
    setVideoTrack(videoTrack: MediaStreamTrack): void;
    private setScreenShareTracks;
    private onScreenShareEnded;
    disableAudio(): void;
    enableAudio(): Promise<void>;
    toggleAudio(): Promise<void>;
    toggleVideo(): Promise<void>;
    toggleScreenShare(): Promise<void>;
    getAllDevices(): MediaDeviceInfo[];
    getDeviceById(deviceId: string, kind: 'audioinput' | 'audiooutput' | 'videoinput'): MediaDeviceInfo;
    getAudioDevices(): MediaDeviceInfo[];
    getVideoDevices(): MediaDeviceInfo[];
    getSpeakerDevices(): MediaDeviceInfo[];
    onDeviceChange(changedDevices: {
        added: MediaDeviceInfo[];
        removed: MediaDeviceInfo[];
    }, forceDeviceChange: boolean): Promise<void>;
    static init(mediaConstraints: MediaConstraints): Promise<LocalMediaHandlerDeprecated>;
    emit(event: keyof typeof MediaEvents, ...args: any[]): boolean;
    on(event: keyof typeof MediaEvents, listener: (...args: any[]) => void): this;
    removeDocumentEventListeners(): Promise<void>;
    addAudioMiddleware(audioMiddleware: AudioMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    removeAudioMiddleware(audioMiddleware: AudioMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    addVideoMiddleware(videoMiddleware: VideoMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    removeVideoMiddleware(videoMiddleware: VideoMiddleware): Promise<{
        success: boolean;
        message: string;
    }>;
    enableVideo(): Promise<void>;
    disableVideo(): Promise<void>;
    enableScreenShare(): Promise<void>;
    disableScreenShare(): Promise<void>;
    getCurrentDevices(): {
        audio: MediaDeviceInfo;
        video: MediaDeviceInfo;
        speaker: MediaDeviceInfo;
    };
    destruct(): void;
    isDeprecated: () => boolean;
}

declare class DyteSelfMedia extends DyteTypedEventEmitter<SelfEvents> {
    protected localMediaHandler: LocalMediaHandler | LocalMediaHandlerDeprecated;
    protected updatePermission(): Promise<void>;
    init(options?: {
        video?: boolean;
        audio?: boolean;
        constraints?: MediaConstraints;
    }, skipAwaits?: boolean): Promise<void>;
    get audioTrack(): MediaStreamTrack;
    get rawAudioTrack(): MediaStreamTrack;
    get mediaPermissions(): {
        audio?: MediaPermission$1;
        video?: MediaPermission$1;
        screenshare?: MediaPermission$1;
    } | {
        audio?: "NOT_REQUESTED" | "ACCEPTED" | "DENIED" | "CANCELED" | "SYSTEM_DENIED" | "COULD_NOT_START";
        video?: "NOT_REQUESTED" | "ACCEPTED" | "DENIED" | "CANCELED" | "SYSTEM_DENIED" | "COULD_NOT_START";
        screenshare?: "NOT_REQUESTED" | "ACCEPTED" | "DENIED" | "CANCELED" | "SYSTEM_DENIED" | "COULD_NOT_START";
    };
    addAudioMiddleware(audioMiddleware: AudioMiddleware$1): Promise<{
        success: boolean;
        message: string;
    }>;
    removeAudioMiddleware(audioMiddleware: AudioMiddleware$1): Promise<{
        success: boolean;
        message: string;
    }>;
    get videoTrack(): MediaStreamTrack;
    get rawVideoTrack(): MediaStreamTrack;
    addVideoMiddleware(videoMiddleware: VideoMiddleware$1): Promise<{
        success: boolean;
        message: string;
    }>;
    removeVideoMiddleware(videoMiddleware: VideoMiddleware$1): Promise<{
        success: boolean;
        message: string;
    }>;
    get screenShareTracks(): {
        audio: MediaStreamTrack;
        video: MediaStreamTrack;
    } | {
        audio?: MediaStreamTrack;
        video?: MediaStreamTrack;
    };
    get audioEnabled(): boolean;
    get videoEnabled(): boolean;
    get screenShareEnabled(): boolean;
    enableAudio(): Promise<void>;
    enableVideo(): Promise<void>;
    disableAudio(): Promise<void>;
    disableVideo(): Promise<void>;
    disableScreenShare(): Promise<void>;
    getCurrentDevices(): {
        audio: MediaDeviceInfo;
        video: MediaDeviceInfo;
        speaker: MediaDeviceInfo;
    };
    getAudioDevices(): Promise<MediaDeviceInfo[]>;
    getVideoDevices(): Promise<MediaDeviceInfo[] | InputDeviceInfo[]>;
    getSpeakerDevices(): Promise<MediaDeviceInfo[] | InputDeviceInfo[]>;
    getDeviceById(deviceId: string, kind: 'audio' | 'video' | 'speaker'): MediaDeviceInfo | Promise<MediaDeviceInfo>;
    setDevice(device: MediaDeviceInfo): Promise<void>;
}

type StageStatus = 'OFF_STAGE' | 'REQUESTED_TO_JOIN_STAGE' | 'ACCEPTED_TO_JOIN_STAGE' | 'ON_STAGE';
interface StageRequestPayload {
    displayName: string;
    userId: string;
    peerId: string;
}
type StageEvents = {
    ['stageAccessRequestUpdate']: (requests?: StageRequestPayload[]) => void;
    ['stageStatusUpdate']: (status: StageStatus) => void;
    ['newStageRequest']: (payload: {
        count: number;
    }) => void;
    ['stageRequestApproved']: () => void;
    ['stageRequestRejected']: () => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DyteStage extends DyteTypedEventEmitter<StageEvents> {
    #private;
    status: StageStatus;
    constructor(self: DyteSelf$1, participants: DyteParticipants, viewType: ViewType);
    private setupEvents;
    private getSocketStageRequests;
    getAccessRequests(): {
        stageRequests: StageRequestPayload[];
    };
    requestAccess(): Promise<void>;
    cancelRequestAccess(): Promise<void>;
    grantAccess(userIds: string[]): void;
    denyAccess(userIds: string[]): void;
    join(): Promise<void>;
    leave(): Promise<void>;
    kick(userIds: string[]): Promise<void>;
}

interface UserDetailsResponse {
    id: string;
    name: string;
    email: string;
    picture?: string;
    loggedIn?: boolean;
    scope?: string[];
    clientSpecificId?: string;
    customParticipantId?: string;
    organizationId?: string;
}
declare enum WebinarStageStatus {
    OFF_STAGE = "OFF_STAGE",
    REQUESTED_TO_JOIN_STAGE = "REQUESTED_TO_JOIN_STAGE",
    ACCEPTED_TO_JOIN_STAGE = "ACCEPTED_TO_JOIN_STAGE",
    ON_STAGE = "ON_STAGE"
}
declare class DyteSelf$1 extends DyteSelfMedia {
    #private;
    id: string;
    name: string;
    picture: string;
    customParticipantId: string;
    get clientSpecificId(): string;
    waitlistStatus: 'accepted' | 'waiting' | 'rejected' | 'none';
    role: any;
    userId: string;
    organizationId: string;
    supportsRemoteControl: boolean;
    device: DeviceConfig;
    get stageStatus(): StageStatus;
    presetName: string;
    roomState: 'init' | 'joined' | 'waitlisted' | leaveRoomState;
    private constructor();
    static __init__(): Promise<DyteSelf$1>;
    private setupEvents;
    get permissions(): DytePermissionsPresetV1$1 | DytePermissionsPreset$1;
    get suggestedTheme(): DyteThemePresetV1$1 | DyteThemePreset$1;
    get config(): DyteThemePresetV1$1 | DyteThemePreset$1;
    roomJoined: boolean;
    setName(name: string): void;
    setupTracks(options?: {
        video?: boolean;
        audio?: boolean;
        forceReset?: boolean;
    }): Promise<void>;
    private resetSelf;
    destructMediaHandler(): Promise<void>;
    removeDocumentEventListeners(): Promise<void>;
    enableAudio(): Promise<void>;
    enableVideo(): Promise<void>;
    updateVideoConstraints(resolution: VideoQualityConstraints): Promise<void>;
    enableScreenShare(): Promise<void>;
    updateScreenshareConstraints(resolution: VideoQualityConstraints): Promise<void>;
    disableAudio(): Promise<void>;
    disableVideo(): Promise<void>;
    disableScreenShare(): Promise<void>;
    getAllDevices(): MediaDeviceInfo[] | Promise<InputDeviceInfo[]>;
    setIsPinned(isPinned: boolean, emitEvent?: boolean): void;
    get isPinned(): boolean;
    get webinarStageStatus(): WebinarStageStatus;
    pin(): Promise<void>;
    unpin(): Promise<void>;
    setDevice(device: MediaDeviceInfo): Promise<void>;
    cleanUpTracks(): void;
    requestToJoinStage(): Promise<void>;
    withdrawRequestToJoinStage(): Promise<void>;
    leaveStage(): Promise<void>;
    joinStage(): Promise<void>;
    setWebinarStageStatus(webinarStageStatus: WebinarStageStatus): void;
    disablePreview(): Promise<this>;
}

/**
 * Represents any possible JSON value:
 * - number
 * - string
 * - boolean
 * - null
 * - object (with any JSON value as property)
 * - array (with any JSON value as element)
 */
declare type JsonValue = number | string | boolean | null | JsonObject | JsonArray;
/**
 * Represents a JSON object.
 */
declare type JsonObject = {
    [k: string]: JsonValue;
};
interface JsonArray extends Array<JsonValue> {
}

declare abstract class SharedPbLong {
    /**
     * Low 32 bits.
     */
    readonly lo: number;
    /**
     * High 32 bits.
     */
    readonly hi: number;
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo: number, hi: number);
    /**
     * Is this instance equal to 0?
     */
    isZero(): boolean;
    /**
     * Convert to a native number.
     */
    toNumber(): number;
    /**
     * Convert to decimal string.
     */
    abstract toString(): string;
    /**
     * Convert to native bigint.
     */
    abstract toBigInt(): bigint;
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
declare class PbULong extends SharedPbLong {
    /**
     * ulong 0 singleton.
     */
    static ZERO: PbULong;
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value: string | number | bigint): PbULong;
    /**
     * Convert to decimal string.
     */
    toString(): string;
    /**
     * Convert to native bigint.
     */
    toBigInt(): bigint;
}
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
declare class PbLong extends SharedPbLong {
    /**
     * long 0 singleton.
     */
    static ZERO: PbLong;
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value: string | number | bigint): PbLong;
    /**
     * Do we have a minus sign?
     */
    isNegative(): boolean;
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate(): PbLong;
    /**
     * Convert to decimal string.
     */
    toString(): string;
    /**
     * Convert to native bigint.
     */
    toBigInt(): bigint;
}

/**
 * Options for writing binary data.
 */
interface BinaryWriteOptions {
    /**
     * Shall unknown fields be written back on wire?
     *
     * `true`: unknown fields stored in a symbol property of the message
     * are written back. This is the default behaviour.
     *
     * `false`: unknown fields are not written.
     *
     * `UnknownFieldWriter`: Your own behaviour for unknown fields.
     */
    writeUnknownFields: boolean | UnknownFieldWriter;
    /**
     * Allows to use a custom implementation to encode binary data.
     */
    writerFactory: () => IBinaryWriter;
}
/**
 * Options for reading binary data.
 */
interface BinaryReadOptions {
    /**
     * Shall unknown fields be read, ignored or raise an error?
     *
     * `true`: stores the unknown field on a symbol property of the
     * message. This is the default behaviour.
     *
     * `false`: ignores the unknown field.
     *
     * `"throw"`: throws an error.
     *
     * `UnknownFieldReader`: Your own behaviour for unknown fields.
     */
    readUnknownField: boolean | 'throw' | UnknownFieldReader;
    /**
     * Allows to use a custom implementation to parse binary data.
     */
    readerFactory: (bytes: Uint8Array) => IBinaryReader;
}
/**
 * Store an unknown field for a message somewhere.
 */
declare type UnknownFieldReader = (typeName: string, message: any, fieldNo: number, wireType: WireType, data: Uint8Array) => void;
/**
 * Write unknown fields stored for the message to the writer.
 */
declare type UnknownFieldWriter = (typeName: string, message: any, writer: IBinaryWriter) => void;
/**
 * This interface is used throughout @protobuf-ts to read
 * protobuf binary format.
 *
 * While not completely compatible, this interface is closely aligned
 * with the `Reader` class of `protobufjs` to make it easier to swap
 * the implementation.
 */
interface IBinaryReader {
    /**
     * Current position.
     */
    readonly pos: number;
    /**
     * Number of bytes available in this reader.
     */
    readonly len: number;
    /**
     * Reads a tag - field number and wire type.
     */
    tag(): [number, WireType];
    /**
     * Skip one element on the wire and return the skipped data.
     */
    skip(wireType: WireType): Uint8Array;
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    uint32(): number;
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    int32(): number;
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(): number;
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64(): PbLong;
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(): PbLong;
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64(): PbLong;
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64(): PbULong;
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(): PbULong;
    /**
     * Read a `bool` field, a variant.
     */
    bool(): boolean;
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(): number;
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32(): number;
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float(): number;
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double(): number;
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes(): Uint8Array;
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string(): string;
}
/**
 * This interface is used throughout @protobuf-ts to write
 * protobuf binary format.
 *
 * While not completely compatible, this interface is closely aligned
 * with the `Writer` class of `protobufjs` to make it easier to swap
 * the implementation.
 */
interface IBinaryWriter {
    /**
     * Return all bytes written and reset this writer.
     */
    finish(): Uint8Array;
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork(): IBinaryWriter;
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join(): IBinaryWriter;
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo: number, type: WireType): IBinaryWriter;
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk: Uint8Array): IBinaryWriter;
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value: number): IBinaryWriter;
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value: number): IBinaryWriter;
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value: number): IBinaryWriter;
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value: string | number | bigint): IBinaryWriter;
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value: string | number | bigint): IBinaryWriter;
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value: string | number | bigint): IBinaryWriter;
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value: string | number | bigint): IBinaryWriter;
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value: string | number | bigint): IBinaryWriter;
    /**
     * Write a `bool` value, a variant.
     */
    bool(value: boolean): IBinaryWriter;
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value: number): IBinaryWriter;
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value: number): IBinaryWriter;
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value: number): IBinaryWriter;
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value: number): IBinaryWriter;
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value: Uint8Array): IBinaryWriter;
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value: string): IBinaryWriter;
}
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
declare enum WireType {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    Varint = 0,
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    Bit64 = 1,
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    LengthDelimited = 2,
    /**
     * Used for groups
     * @deprecated
     */
    StartGroup = 3,
    /**
     * Used for groups
     * @deprecated
     */
    EndGroup = 4,
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    Bit32 = 5
}

/**
 * Describes a protobuf enum for runtime reflection.
 *
 * The tuple consists of:
 *
 *
 * [0] the protobuf type name
 *
 * The type name follows the same rules as message type names.
 * See `MessageInfo` for details.
 *
 *
 * [1] the enum object generated by Typescript
 *
 * We generate standard Typescript enums for protobuf enums. They are compiled
 * to lookup objects that map from numerical value to name strings and vice
 * versa and can also contain alias names.
 *
 * See https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
 *
 * We use this lookup feature to when encoding / decoding JSON format. The
 * enum is guaranteed to have a value for 0. We generate an entry for 0 if
 * none was declared in .proto because we would need to support custom default
 * values if we didn't.
 *
 *
 * [2] the prefix shared by all original enum values (optional)
 *
 * If all values of a protobuf enum share a prefix, it is dropped in the
 * generated enum. For example, the protobuf enum `enum My { MY_FOO, MY_BAR }`
 * becomes the typescript enum `enum My { FOO, BAR }`.
 *
 * Because the JSON format requires the original value name, we store the
 * dropped prefix here, so that the JSON format implementation can restore
 * the original value names.
 */
declare type EnumInfo = readonly [
/**
 * The protobuf type name of the enum
 */
string, 
/**
 * The enum object generated by Typescript
 */
{
    [key: number]: string;
    [k: string]: number | string;
}, 
/**
 * The prefix shared by all original enum values
 */
string?];
/**
 * Describes a protobuf message for runtime reflection.
 */
interface MessageInfo {
    /**
     * The protobuf type name of the message, including package and
     * parent types if present.
     *
     * If the .proto file included a `package` statement, the type name
     * starts with '.'.
     *
     * Examples:
     * 'MyNamespaceLessMessage'
     * '.my_package.MyMessage'
     * '.my_package.ParentMessage.ChildMessage'
     */
    readonly typeName: string;
    /**
     * Simple information for each message field, in the order
     * of declaration in the source .proto.
     */
    readonly fields: readonly FieldInfo[];
    /**
     * Contains custom message options from the .proto source in JSON format.
     */
    readonly options: {
        [extensionName: string]: JsonValue;
    };
}
/**
 * Version of `MessageInfo` that allows the following properties
 * to be omitted:
 * - "fields": omitting means the message has no fields
 * - "options": omitting means the message has no options
 */
declare type PartialMessageInfo = PartialPartial<MessageInfo, "fields" | "options">;
declare type PartialPartial<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
/**
 * Describes a field of a protobuf message for runtime
 * reflection. We distinguish between the following
 * kinds of fields:
 *
 * "scalar": string, bool, float, int32, etc.
 * See https://developers.google.com/protocol-buffers/docs/proto3#scalar
 *
 * "enum": field was declared with an enum type.
 *
 * "message": field was declared with a message type.
 *
 * "map": field was declared with map<K,V>.
 *
 *
 * Every field, regardless of it's kind, always has the following properties:
 *
 * "no": The field number of the .proto field.
 * "name": The original name of the .proto field.
 * "localName": The name of the field as used in generated code.
 * "jsonName": The name for JSON serialization / deserialization.
 * "options": Custom field options from the .proto source in JSON format.
 *
 *
 * Other properties:
 *
 * - Fields of kind "scalar", "enum" and "message" can have a "repeat" type.
 * - Fields of kind "scalar" and "enum" can have a "repeat" type.
 * - Fields of kind "scalar", "enum" and "message" can be member of a "oneof".
 *
 * A field can be only have one of the above properties set.
 *
 * Options for "scalar" fields:
 *
 * - 64 bit integral types can provide "L" - the JavaScript representation
 *   type.
 *
 */
declare type FieldInfo = fiRules<fiScalar> | fiRules<fiEnum> | fiRules<fiMessage> | fiRules<fiMap>;
/**
 * Version of `FieldInfo` that allows the following properties
 * to be omitted:
 * - "localName", "jsonName": can be omitted if equal to lowerCamelCase(name)
 * - "opt": can be omitted if false
 * - "repeat", can be omitted if RepeatType.NO
 *
 * Use `normalizeFieldInfo()` to fill the omitted fields with
 * their standard values.
 */
declare type PartialFieldInfo = fiPartialRules<fiScalar> | fiPartialRules<fiEnum> | fiPartialRules<fiMessage> | fiPartialRules<fiMap>;
interface fiShared {
    /**
     * The field number of the .proto field.
     */
    no: number;
    /**
     * The original name of the .proto field.
     */
    name: string;
    /**
     * The name of the field as used in generated code.
     */
    localName: string;
    /**
     * The name for JSON serialization / deserialization.
     */
    jsonName: string;
    /**
     * The name of the `oneof` group, if this field belongs to one.
     */
    oneof: string | undefined;
    /**
     * Contains custom field options from the .proto source in JSON format.
     */
    options?: {
        [extensionName: string]: JsonValue;
    };
}
interface fiScalar extends fiShared {
    kind: 'scalar';
    /**
     * Scalar type of the field.
     */
    T: ScalarType;
    /**
     * Representation of 64 bit integral types (int64, uint64, sint64,
     * fixed64, sfixed64).
     *
     * If this option is set for other scalar types, it is ignored.
     * Omitting this option is equivalent to `STRING`.
     */
    L?: LongType;
    /**
     * Is the field repeated?
     */
    repeat: RepeatType;
    /**
     * Is the field optional?
     */
    opt: boolean;
}
interface fiMessage extends fiShared {
    kind: 'message';
    /**
     * Message handler for the field.
     */
    T: () => IMessageType<any>;
    /**
     * Is the field repeated?
     */
    repeat: RepeatType;
}
interface fiEnum extends fiShared {
    kind: 'enum';
    /**
     * Enum type information for the field.
     */
    T: () => EnumInfo;
    /**
     * Is the field repeated?
     */
    repeat: RepeatType;
    /**
     * Is the field optional?
     */
    opt: boolean;
}
interface fiMap extends fiShared {
    kind: 'map';
    /**
     * Map key type.
     *
     * The key_type can be any integral or string type
     * (so, any scalar type except for floating point
     * types and bytes)
     */
    K: Exclude<ScalarType, ScalarType.FLOAT | ScalarType.DOUBLE | ScalarType.BYTES>;
    /**
     * Map value type. Can be a `ScalarType`, enum type information,
     * or type handler for a message.
     */
    V: {
        kind: 'scalar';
        T: ScalarType;
        L?: LongType;
    } | {
        kind: 'enum';
        T: () => EnumInfo;
    } | {
        kind: 'message';
        T: () => IMessageType<any>;
    };
}
declare type fiRules<T> = Omit<T, 'oneof' | 'repeat' | 'opt'> & ({
    repeat: RepeatType.NO;
    opt: false;
    oneof: undefined;
} | {
    repeat: RepeatType.NO;
    opt: true;
    oneof: undefined;
} | {
    repeat: RepeatType.PACKED | RepeatType.UNPACKED;
    opt: false;
    oneof: undefined;
} | {
    repeat: RepeatType.NO;
    opt: false;
    oneof: string;
});
declare type fiPartialRules<T> = Omit<T, 'jsonName' | 'localName' | 'oneof' | 'repeat' | 'opt'> & ({
    localName?: string;
    jsonName?: string;
    repeat?: RepeatType.NO;
    opt?: false;
    oneof?: undefined;
} | {
    localName?: string;
    jsonName?: string;
    repeat?: RepeatType.NO;
    opt: true;
    oneof?: undefined;
} | {
    localName?: string;
    jsonName?: string;
    repeat: RepeatType.PACKED | RepeatType.UNPACKED;
    opt?: false;
    oneof?: undefined;
} | {
    localName?: string;
    jsonName?: string;
    repeat?: RepeatType.NO;
    opt?: false;
    oneof: string;
});
/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
declare enum ScalarType {
    DOUBLE = 1,
    FLOAT = 2,
    INT64 = 3,
    UINT64 = 4,
    INT32 = 5,
    FIXED64 = 6,
    FIXED32 = 7,
    BOOL = 8,
    STRING = 9,
    BYTES = 12,
    UINT32 = 13,
    SFIXED32 = 15,
    SFIXED64 = 16,
    SINT32 = 17,
    SINT64 = 18
}
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
declare enum LongType {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    BIGINT = 0,
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    STRING = 1,
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    NUMBER = 2
}
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
declare enum RepeatType {
    /**
     * The field is not repeated.
     */
    NO = 0,
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    PACKED = 1,
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    UNPACKED = 2
}

/**
 * Similar to `Partial<T>`, but recursive, and keeps `oneof` groups
 * intact.
 */
declare type PartialMessage<T extends object> = {
    [K in keyof T]?: PartialField<T[K]>;
};
declare type PartialField<T> = T extends (Date | Uint8Array | bigint | boolean | string | number) ? T : T extends Array<infer U> ? Array<PartialField<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<PartialField<U>> : T extends {
    oneofKind: string;
} ? T : T extends {
    oneofKind: undefined;
} ? T : T extends object ? PartialMessage<T> : T;
/**
 * A message type provides an API to work with messages of a specific type.
 * It also exposes reflection information that can be used to work with a
 * message of unknown type.
 */
interface IMessageType<T extends object> extends MessageInfo {
    /**
     * The protobuf type name of the message, including package and
     * parent types if present.
     *
     * Examples:
     * 'MyNamespaceLessMessage'
     * 'my_package.MyMessage'
     * 'my_package.ParentMessage.ChildMessage'
     */
    readonly typeName: string;
    /**
     * Simple information for each message field, in the order
     * of declaration in the .proto.
     */
    readonly fields: readonly FieldInfo[];
    /**
     * Contains custom message options from the .proto source in JSON format.
     */
    readonly options: {
        [extensionName: string]: JsonValue;
    };
    /**
     * Contains the prototype for messages returned by create() which
     * includes the `MESSAGE_TYPE` symbol pointing back to `this`.
     */
    readonly messagePrototype?: Readonly<{}> | undefined;
    /**
     * Create a new message with default values.
     *
     * For example, a protobuf `string name = 1;` has the default value `""`.
     */
    create(): T;
    /**
     * Create a new message from partial data.
     *
     * Unknown fields are discarded.
     *
     * `PartialMessage<T>` is similar to `Partial<T>`,
     * but it is recursive, and it keeps `oneof` groups
     * intact.
     */
    create(value: PartialMessage<T>): T;
    /**
     * Create a new message from binary format.
     */
    fromBinary(data: Uint8Array, options?: Partial<BinaryReadOptions>): T;
    /**
     * Write the message to binary format.
     */
    toBinary(message: T, options?: Partial<BinaryWriteOptions>): Uint8Array;
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json: JsonValue, options?: Partial<JsonReadOptions>): T;
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json: string, options?: Partial<JsonReadOptions>): T;
    /**
     * Convert the message to canonical JSON value.
     */
    toJson(message: T, options?: Partial<JsonWriteOptions>): JsonValue;
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message: T, options?: Partial<JsonWriteStringOptions>): string;
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message: T): T;
    /**
     * Copy partial data into the target message.
     *
     * If a singular scalar or enum field is present in the source, it
     * replaces the field in the target.
     *
     * If a singular message field is present in the source, it is merged
     * with the target field by calling mergePartial() of the responsible
     * message type.
     *
     * If a repeated field is present in the source, its values replace
     * all values in the target array, removing extraneous values.
     * Repeated message fields are copied, not merged.
     *
     * If a map field is present in the source, entries are added to the
     * target map, replacing entries with the same key. Entries that only
     * exist in the target remain. Entries with message values are copied,
     * not merged.
     *
     * Note that this function differs from protobuf merge semantics,
     * which appends repeated fields.
     */
    mergePartial(target: T, source: PartialMessage<T>): void;
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a: T | undefined, b: T | undefined): boolean;
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg: any, depth?: number): arg is T;
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg: any, depth?: number): arg is T;
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: T): T;
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message: T, options: JsonWriteOptions): JsonValue;
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message: T, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: T): T;
}

/**
 * Options for parsing JSON data.
 * All boolean options default to `false`.
 */
interface JsonReadOptions {
    /**
     * Ignore unknown fields: Proto3 JSON parser should reject unknown fields
     * by default. This option ignores unknown fields in parsing, as well as
     * unrecognized enum string representations.
     */
    ignoreUnknownFields: boolean;
    /**
     * This option is required to read `google.protobuf.Any`
     * from JSON format.
     */
    typeRegistry?: readonly IMessageType<any>[];
}
/**
 * Options for serializing to JSON object.
 * All boolean options default to `false`.
 */
interface JsonWriteOptions {
    /**
     * Emit fields with default values: Fields with default values are omitted
     * by default in proto3 JSON output. This option overrides this behavior
     * and outputs fields with their default values.
     */
    emitDefaultValues: boolean;
    /**
     * Emit enum values as integers instead of strings: The name of an enum
     * value is used by default in JSON output. An option may be provided to
     * use the numeric value of the enum value instead.
     */
    enumAsInteger: boolean;
    /**
     * Use proto field name instead of lowerCamelCase name: By default proto3
     * JSON printer should convert the field name to lowerCamelCase and use
     * that as the JSON name. An implementation may provide an option to use
     * proto field name as the JSON name instead. Proto3 JSON parsers are
     * required to accept both the converted lowerCamelCase name and the proto
     * field name.
     */
    useProtoFieldName: boolean;
    /**
     * This option is required to write `google.protobuf.Any`
     * to JSON format.
     */
    typeRegistry?: readonly IMessageType<any>[];
}
/**
 * Options for serializing to JSON string.
 * All options default to `false` or `0`.
 */
interface JsonWriteStringOptions extends JsonWriteOptions {
    prettySpaces: number;
}

declare class ReflectionTypeCheck {
    private readonly fields;
    private data;
    constructor(info: PartialMessageInfo);
    private prepare;
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message: any, depth: number, allowExcessProperties?: boolean): boolean;
    private field;
    private message;
    private messages;
    private scalar;
    private scalars;
    private mapKeys;
}

/**
 * A message of unknown type.
 */
interface UnknownMessage {
    [k: string]: UnknownScalar | UnknownEnum | UnknownMessage | UnknownOneofGroup | UnknownMap | UnknownScalar[] | UnknownMessage[] | UnknownEnum[] | undefined;
}
/**
 * A map field of unknown type.
 */
declare type UnknownMap<T = UnknownMessage | UnknownScalar | UnknownEnum> = {
    [key: string]: T;
};
/**
 * A scalar field of unknown type.
 */
declare type UnknownScalar = string | number | bigint | boolean | Uint8Array;
/**
 * A enum field of unknown type.
 */
declare type UnknownEnum = number;
/**
 * A unknown oneof group. See `isOneofGroup()` for details.
 */
declare type UnknownOneofGroup = {
    oneofKind: undefined | string;
    [k: string]: UnknownScalar | UnknownEnum | UnknownMessage | undefined;
};

/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
declare class ReflectionJsonReader {
    private readonly info;
    /**
     * JSON key to field.
     * Accepts the original proto field name in the .proto, the
     * lowerCamelCase name, or the name specified by the json_name option.
     */
    private fMap?;
    constructor(info: PartialMessageInfo);
    protected prepare(): void;
    assert(condition: any, fieldName: string, jsonValue: JsonValue): asserts condition;
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read<T extends object>(input: JsonObject, message: T, options: JsonReadOptions): void;
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type: EnumInfo, json: unknown, fieldName: string, ignoreUnknownFields: boolean): UnknownEnum | false;
    scalar(json: JsonValue, type: ScalarType, longType: LongType | undefined, fieldName: string): UnknownScalar;
}

/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
declare class ReflectionJsonWriter {
    private readonly fields;
    constructor(info: PartialMessageInfo);
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write<T extends object>(message: T, options: JsonWriteOptions): JsonValue;
    field(field: FieldInfo, value: unknown, options: JsonWriteOptions): JsonValue | undefined;
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type: EnumInfo, value: unknown, fieldName: string, optional: boolean, emitDefaultValues: boolean, enumAsInteger: boolean): JsonValue | undefined;
    message(type: IMessageType<any>, value: unknown, fieldName: string, options: JsonWriteOptions): JsonValue | undefined;
    scalar(type: ScalarType, value: unknown, fieldName: string, optional: false, emitDefaultValues: boolean): JsonValue;
    scalar(type: ScalarType, value: unknown, fieldName: string, optional: boolean, emitDefaultValues: boolean): JsonValue | undefined;
}

/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
declare class ReflectionBinaryReader {
    private readonly info;
    protected fieldNoToField?: ReadonlyMap<number, FieldInfo>;
    constructor(info: PartialMessageInfo);
    protected prepare(): void;
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read<T extends object>(reader: IBinaryReader, message: T, options: BinaryReadOptions, length?: number): void;
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    protected mapEntry(field: FieldInfo & {
        kind: "map";
    }, reader: IBinaryReader, options: BinaryReadOptions): [string | number, UnknownMap[string]];
    protected scalar(reader: IBinaryReader, type: ScalarType, longType: LongType | undefined): UnknownScalar;
}

/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
declare class ReflectionBinaryWriter {
    private readonly info;
    protected fields?: readonly FieldInfo[];
    constructor(info: PartialMessageInfo);
    protected prepare(): void;
    /**
     * Writes the message to binary format.
     */
    write<T extends object>(message: T, writer: IBinaryWriter, options: BinaryWriteOptions): void;
    protected mapEntry(writer: IBinaryWriter, options: BinaryWriteOptions, field: FieldInfo & {
        kind: 'map';
    }, key: any, value: any): void;
    protected message(writer: IBinaryWriter, options: BinaryWriteOptions, handler: IMessageType<any>, fieldNo: number, value: any): void;
    /**
     * Write a single scalar value.
     */
    protected scalar(writer: IBinaryWriter, type: ScalarType, fieldNo: number, value: any, emitDefault: boolean): void;
    /**
     * Write an array of scalar values in packed format.
     */
    protected packed(writer: IBinaryWriter, type: ScalarType, fieldNo: number, value: any[]): void;
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    protected scalarInfo(type: ScalarType, value?: any): [WireType, "int32" | "string" | "bool" | "uint32" | "double" | "float" | "int64" | "uint64" | "fixed64" | "bytes" | "fixed32" | "sfixed32" | "sfixed64" | "sint32" | "sint64", boolean];
}

/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
declare class MessageType$1<T extends object> implements IMessageType<T> {
    /**
     * The protobuf type name of the message, including package and
     * parent types if present.
     *
     * If the .proto file included a `package` statement,
     * the type name will always start with a '.'.
     *
     * Examples:
     * 'MyNamespaceLessMessage'
     * '.my_package.MyMessage'
     * '.my_package.ParentMessage.ChildMessage'
     */
    readonly typeName: string;
    /**
     * Simple information for each message field, in the order
     * of declaration in the .proto.
     */
    readonly fields: readonly FieldInfo[];
    /**
     * Contains custom service options from the .proto source in JSON format.
     */
    readonly options: JsonOptionsMap;
    /**
     * Contains the prototype for messages returned by create() which
     * includes the `MESSAGE_TYPE` symbol pointing back to `this`.
     */
    readonly messagePrototype?: Readonly<{}> | undefined;
    protected readonly defaultCheckDepth = 16;
    protected readonly refTypeCheck: ReflectionTypeCheck;
    protected readonly refJsonReader: ReflectionJsonReader;
    protected readonly refJsonWriter: ReflectionJsonWriter;
    protected readonly refBinReader: ReflectionBinaryReader;
    protected readonly refBinWriter: ReflectionBinaryWriter;
    constructor(name: string, fields: readonly PartialFieldInfo[], options?: JsonOptionsMap);
    /**
     * Create a new message with default values.
     *
     * For example, a protobuf `string name = 1;` has the default value `""`.
     */
    create(): T;
    /**
     * Create a new message from partial data.
     * Where a field is omitted, the default value is used.
     *
     * Unknown fields are discarded.
     *
     * `PartialMessage<T>` is similar to `Partial<T>`,
     * but it is recursive, and it keeps `oneof` groups
     * intact.
     */
    create(value: PartialMessage<T>): T;
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message: T): T;
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a: T | undefined, b: T | undefined): boolean;
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg: any, depth?: number): arg is T;
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg: any, depth?: number): arg is T;
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target: T, source: PartialMessage<T>): void;
    /**
     * Create a new message from binary format.
     */
    fromBinary(data: Uint8Array, options?: Partial<BinaryReadOptions>): T;
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json: JsonValue, options?: Partial<JsonReadOptions>): T;
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json: string, options?: Partial<JsonReadOptions>): T;
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message: T, options?: Partial<JsonWriteOptions>): JsonValue;
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message: T, options?: Partial<JsonWriteStringOptions>): string;
    /**
     * Write the message to binary format.
     */
    toBinary(message: T, options?: Partial<BinaryWriteOptions>): Uint8Array;
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: T): T;
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message: T, options: JsonWriteOptions): JsonValue;
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message: T, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: T): T;
}
declare type JsonOptionsMap = {
    [extensionName: string]: JsonValue;
};

/**
 * protolint:disable ENUM_FIELD_NAMES_PREFIX
 *
 * @generated from protobuf enum media.Target
 */
declare enum Target {
    /**
     * @generated from protobuf enum value: PUBLISHER = 0;
     */
    PUBLISHER = 0,
    /**
     * @generated from protobuf enum value: SUBSCRIBER = 1;
     */
    SUBSCRIBER = 1
}
/**
 * protolint:disable ENUM_FIELD_NAMES_PREFIX
 *
 * @generated from protobuf enum media.ProducerKind
 */
declare enum ProducerKind {
    /**
     * @generated from protobuf enum value: AUDIO = 0;
     */
    AUDIO = 0,
    /**
     * @generated from protobuf enum value: VIDEO = 1;
     */
    VIDEO = 1
}
declare class SessionDescription$Type extends MessageType$1<SessionDescription> {
    constructor();
}
/**
 * @generated from protobuf message media.SessionDescription
 */
interface SessionDescription {
    /**
     * @generated from protobuf field: media.Target target = 1;
     */
    target: Target;
    /**
     * 'offer' | 'answer'
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * sdp contents
     *
     * @generated from protobuf field: string sdp = 3;
     */
    sdp: string;
}
/**
 * @generated MessageType for protobuf message media.SessionDescription
 */
declare const SessionDescription: SessionDescription$Type;
declare class ProducerTrack$Type extends MessageType$1<ProducerTrack> {
    constructor();
}
/**
 * @generated from protobuf message media.ProducerTrack
 */
interface ProducerTrack {
    /**
     * @generated from protobuf field: string track_id = 1;
     */
    trackId: string;
    /**
     * @generated from protobuf field: string producer_id = 2;
     */
    producerId: string;
    /**
     * @generated from protobuf field: string stream_id = 3;
     */
    streamId: string;
}
/**
 * @generated MessageType for protobuf message media.ProducerTrack
 */
declare const ProducerTrack: ProducerTrack$Type;
declare class ProducerState$Type extends MessageType$1<ProducerState> {
    constructor();
}
/**
 * @generated from protobuf message media.ProducerState
 */
interface ProducerState {
    /**
     * @generated from protobuf field: string producer_id = 1;
     */
    producerId: string;
    /**
     * @generated from protobuf field: media.ProducerKind kind = 2;
     */
    kind: ProducerKind;
    /**
     * @generated from protobuf field: bool pause = 3;
     */
    pause: boolean;
    /**
     * @generated from protobuf field: bool screen_share = 4;
     */
    screenShare: boolean;
    /**
     * @generated from protobuf field: optional string app_data = 5;
     */
    appData?: string;
}
/**
 * @generated MessageType for protobuf message media.ProducerState
 */
declare const ProducerState: ProducerState$Type;
declare class ConsumerState$Type extends MessageType$1<ConsumerState> {
    constructor();
}
/**
 * @generated from protobuf message media.ConsumerState
 */
interface ConsumerState {
    /**
     * @generated from protobuf field: string consumer_id = 1;
     */
    consumerId: string;
    /**
     * @generated from protobuf field: media.ProducerState producer_state = 2;
     */
    producerState?: ProducerState;
    /**
     * @generated from protobuf field: media.ProducerTrack producer_track = 3;
     */
    producerTrack?: ProducerTrack;
}
/**
 * @generated MessageType for protobuf message media.ConsumerState
 */
declare const ConsumerState: ConsumerState$Type;

declare class PollsPermissionUpdate$Type extends MessageType$1<PollsPermissionUpdate> {
    constructor();
}
/**
 * @generated from protobuf message socket.preset.PollsPermissionUpdate
 */
interface PollsPermissionUpdate {
    /**
     * @generated from protobuf field: optional bool can_create = 1;
     */
    canCreate?: boolean;
    /**
     * @generated from protobuf field: optional bool can_vote = 2;
     */
    canVote?: boolean;
    /**
     * @generated from protobuf field: optional bool can_view = 3;
     */
    canView?: boolean;
}
/**
 * @generated MessageType for protobuf message socket.preset.PollsPermissionUpdate
 */
declare const PollsPermissionUpdate: PollsPermissionUpdate$Type;
declare class PluginsPermissionsUpdate$Type extends MessageType$1<PluginsPermissionsUpdate> {
    constructor();
}
/**
 * @generated from protobuf message socket.preset.PluginsPermissionsUpdate
 */
interface PluginsPermissionsUpdate {
    /**
     * @generated from protobuf field: optional bool can_close = 1;
     */
    canClose?: boolean;
    /**
     * @generated from protobuf field: optional bool can_start = 2;
     */
    canStart?: boolean;
}
/**
 * @generated MessageType for protobuf message socket.preset.PluginsPermissionsUpdate
 */
declare const PluginsPermissionsUpdate: PluginsPermissionsUpdate$Type;
declare class PublicChatPermission$Type extends MessageType$1<PublicChatPermission> {
    constructor();
}
/**
 * @generated from protobuf message socket.preset.PublicChatPermission
 */
interface PublicChatPermission {
    /**
     * @generated from protobuf field: optional bool can_send = 1;
     */
    canSend?: boolean;
    /**
     * @generated from protobuf field: optional bool text = 2;
     */
    text?: boolean;
    /**
     * @generated from protobuf field: optional bool files = 3;
     */
    files?: boolean;
}
/**
 * @generated MessageType for protobuf message socket.preset.PublicChatPermission
 */
declare const PublicChatPermission: PublicChatPermission$Type;
declare class PrivateChatPermission$Type extends MessageType$1<PrivateChatPermission> {
    constructor();
}
/**
 * @generated from protobuf message socket.preset.PrivateChatPermission
 */
interface PrivateChatPermission {
    /**
     * @generated from protobuf field: optional bool can_send = 1;
     */
    canSend?: boolean;
    /**
     * @generated from protobuf field: optional bool can_receive = 2;
     */
    canReceive?: boolean;
    /**
     * @generated from protobuf field: optional bool text = 3;
     */
    text?: boolean;
    /**
     * @generated from protobuf field: optional bool files = 4;
     */
    files?: boolean;
}
/**
 * @generated MessageType for protobuf message socket.preset.PrivateChatPermission
 */
declare const PrivateChatPermission: PrivateChatPermission$Type;
declare class ChatPermissionUpdate$Type extends MessageType$1<ChatPermissionUpdate> {
    constructor();
}
/**
 * @generated from protobuf message socket.preset.ChatPermissionUpdate
 */
interface ChatPermissionUpdate {
    /**
     * @generated from protobuf field: optional socket.preset.PublicChatPermission public = 1;
     */
    public?: PublicChatPermission;
    /**
     * @generated from protobuf field: optional socket.preset.PrivateChatPermission private = 2;
     */
    private?: PrivateChatPermission;
}
/**
 * @generated MessageType for protobuf message socket.preset.ChatPermissionUpdate
 */
declare const ChatPermissionUpdate: ChatPermissionUpdate$Type;
declare class PresetUpdates$Type extends MessageType$1<PresetUpdates> {
    constructor();
}
/**
 * @generated from protobuf message socket.preset.PresetUpdates
 */
interface PresetUpdates {
    /**
     * @generated from protobuf field: optional socket.preset.PollsPermissionUpdate polls = 1;
     */
    polls?: PollsPermissionUpdate;
    /**
     * @generated from protobuf field: optional socket.preset.PluginsPermissionsUpdate plugins = 2;
     */
    plugins?: PluginsPermissionsUpdate;
    /**
     * @generated from protobuf field: optional socket.preset.ChatPermissionUpdate chat = 3;
     */
    chat?: ChatPermissionUpdate;
}
/**
 * @generated MessageType for protobuf message socket.preset.PresetUpdates
 */
declare const PresetUpdates: PresetUpdates$Type;

declare class ChatMessage$Type extends MessageType$1<ChatMessage> {
    constructor();
}
/**
 * @generated from protobuf message socket.chat.ChatMessage
 */
interface ChatMessage {
    /**
     * @generated from protobuf field: string chat_id = 1;
     */
    chatId: string;
    /**
     * @generated from protobuf field: string peer_id = 2;
     */
    peerId: string;
    /**
     * @generated from protobuf field: string user_id = 3;
     */
    userId: string;
    /**
     * @generated from protobuf field: string display_name = 4;
     */
    displayName: string;
    /**
     * @generated from protobuf field: bool pinned = 5;
     */
    pinned: boolean;
    /**
     * @generated from protobuf field: bool is_edited = 6;
     */
    isEdited: boolean;
    /**
     * @generated from protobuf field: int32 payload_type = 7;
     */
    payloadType: number;
    /**
     * @generated from protobuf field: string payload = 8;
     */
    payload: string;
    /**
     * @generated from protobuf field: repeated string target_user_ids = 10;
     */
    targetUserIds: string[];
    /**
     * @generated from protobuf field: uint64 created_at = 11 [jstype = JS_NUMBER];
     */
    createdAt: number;
    /**
     * @generated from protobuf field: optional uint64 created_at_ms = 12 [jstype = JS_NUMBER];
     */
    createdAtMs?: number;
    /**
     * @generated from protobuf field: optional string channel_id = 13;
     */
    channelId?: string;
    /**
     * The index of this message within it's channel
     *
     * @generated from protobuf field: optional string channel_index = 14;
     */
    channelIndex?: string;
}
/**
 * @generated MessageType for protobuf message socket.chat.ChatMessage
 */
declare const ChatMessage: ChatMessage$Type;
declare class SendChatMessageToRoomResponse$Type extends MessageType$1<SendChatMessageToRoomResponse> {
    constructor();
}
/**
 * @generated from protobuf message socket.chat.SendChatMessageToRoomResponse
 */
interface SendChatMessageToRoomResponse {
    /**
     * @generated from protobuf field: socket.chat.ChatMessage message = 1;
     */
    message?: ChatMessage;
}
/**
 * @generated MessageType for protobuf message socket.chat.SendChatMessageToRoomResponse
 */
declare const SendChatMessageToRoomResponse: SendChatMessageToRoomResponse$Type;
declare class SendChatMessageToPeersResponse$Type extends MessageType$1<SendChatMessageToPeersResponse> {
    constructor();
}
/**
 * @generated from protobuf message socket.chat.SendChatMessageToPeersResponse
 */
interface SendChatMessageToPeersResponse {
    /**
     * @generated from protobuf field: socket.chat.ChatMessage message = 1;
     */
    message?: ChatMessage;
}
/**
 * @generated MessageType for protobuf message socket.chat.SendChatMessageToPeersResponse
 */
declare const SendChatMessageToPeersResponse: SendChatMessageToPeersResponse$Type;

/**
 * @generated from protobuf enum socket.room.Capabilities
 */
declare enum Capabilities {
    /**
     * @generated from protobuf enum value: CAPABILITIES_HIVE = 0;
     */
    HIVE = 0,
    /**
     * @generated from protobuf enum value: CAPABILITIES_CHAT = 1;
     */
    CHAT = 1,
    /**
     * @generated from protobuf enum value: CAPABILITIES_PING = 2;
     */
    PING = 2
}

declare class EnablePluginResponse$Type extends MessageType$1<EnablePluginResponse> {
    constructor();
}
/**
 * Response sent whenever a plugin is enabled.
 * Applicable for all requests that enable a plugin.
 *
 * @generated from protobuf message socket.plugin.EnablePluginResponse
 */
interface EnablePluginResponse {
    /**
     * @generated from protobuf field: string plugin_id = 1;
     */
    pluginId: string;
    /**
     * @generated from protobuf field: string enabled_by = 2;
     */
    enabledBy: string;
}
/**
 * @generated MessageType for protobuf message socket.plugin.EnablePluginResponse
 */
declare const EnablePluginResponse: EnablePluginResponse$Type;
declare class EnablePluginsResponse$Type extends MessageType$1<EnablePluginsResponse> {
    constructor();
}
/**
 * Response sent when all enabled plugins are requested.
 *
 * @generated from protobuf message socket.plugin.EnablePluginsResponse
 */
interface EnablePluginsResponse {
    /**
     * @generated from protobuf field: repeated socket.plugin.EnablePluginResponse plugins = 1;
     */
    plugins: EnablePluginResponse[];
}
/**
 * @generated MessageType for protobuf message socket.plugin.EnablePluginsResponse
 */
declare const EnablePluginsResponse: EnablePluginsResponse$Type;
declare class DisablePluginResponse$Type extends MessageType$1<DisablePluginResponse> {
    constructor();
}
/**
 * Response sent whenever a plugin is disabled.
 * Applicable for all requests that disable a plugin.
 *
 * @generated from protobuf message socket.plugin.DisablePluginResponse
 */
interface DisablePluginResponse {
    /**
     * @generated from protobuf field: string plugin_id = 1;
     */
    pluginId: string;
    /**
     * @generated from protobuf field: string disabled_by = 2;
     */
    disabledBy: string;
}
/**
 * @generated MessageType for protobuf message socket.plugin.DisablePluginResponse
 */
declare const DisablePluginResponse: DisablePluginResponse$Type;
declare class PluginStoreItem$Type extends MessageType$1<PluginStoreItem> {
    constructor();
}
/**
 * Response sent whenever a plugin store is updated.
 * Applicable for all requests that access a store.
 *
 * @generated from protobuf message socket.plugin.PluginStoreItem
 */
interface PluginStoreItem {
    /**
     * @generated from protobuf field: string timestamp = 1;
     */
    timestamp: string;
    /**
     * @generated from protobuf field: string peer_id = 2;
     */
    peerId: string;
    /**
     * @generated from protobuf field: string store_key = 3;
     */
    storeKey: string;
    /**
     * @generated from protobuf field: bytes payload = 4;
     */
    payload: Uint8Array;
}
/**
 * @generated MessageType for protobuf message socket.plugin.PluginStoreItem
 */
declare const PluginStoreItem: PluginStoreItem$Type;
declare class PluginStoreResponse$Type extends MessageType$1<PluginStoreResponse> {
    constructor();
}
/**
 * @generated from protobuf message socket.plugin.PluginStoreResponse
 */
interface PluginStoreResponse {
    /**
     * @generated from protobuf field: string plugin_id = 1;
     */
    pluginId: string;
    /**
     * @generated from protobuf field: string store_name = 2;
     */
    storeName: string;
    /**
     * @generated from protobuf field: repeated socket.plugin.PluginStoreItem store_items = 3;
     */
    storeItems: PluginStoreItem[];
}
/**
 * @generated MessageType for protobuf message socket.plugin.PluginStoreResponse
 */
declare const PluginStoreResponse: PluginStoreResponse$Type;
declare class PluginEventResponse$Type extends MessageType$1<PluginEventResponse> {
    constructor();
}
/**
 * Response sent for custom plugin event.
 *
 * @generated from protobuf message socket.plugin.PluginEventResponse
 */
interface PluginEventResponse {
    /**
     * @generated from protobuf field: string plugin_id = 1;
     */
    pluginId: string;
    /**
     * @generated from protobuf field: bytes plugin_data = 2;
     */
    pluginData: Uint8Array;
}
/**
 * @generated MessageType for protobuf message socket.plugin.PluginEventResponse
 */
declare const PluginEventResponse: PluginEventResponse$Type;

type SocketServiceCapability = keyof typeof Capabilities;
type SocketServiceCapabilities = SocketServiceCapability[];
declare class SocketService {
    #private;
    readonly roomName: string;
    readonly peerId: string;
    readonly authToken: string;
    readonly capabilities: SocketServiceCapabilities;
    constructor({ peerId, roomName, authToken, capabilities, }: {
        peerId: string;
        roomName: string;
        authToken: string;
        capabilities: SocketServiceCapabilities;
    });
    private static getSocketEdgeDomain;
    get url(): string;
    connect(): Promise<void>;
    disconnect(): void;
    get isConnected(): boolean;
    sendMessage(event: number, protobuf?: Uint8Array, messageId?: string): boolean;
    sendMessagePromise(event: number, protobuf?: Uint8Array, messageId?: string): Promise<{
        id: string;
        payload: Uint8Array;
    }>;
    sendMessagePromiseWithTimeout({ event, timeout, protobuf, messageId, }: {
        timeout: number;
        event: number;
        protobuf?: Uint8Array;
        messageId?: string;
    }): Promise<{
        id: string;
        payload: Uint8Array;
    }>;
    on(event: number, listener: (message: {
        id?: string;
        payload?: Uint8Array;
    }) => void): void;
    onStateEvent(event: 'connected' | 'disconnected' | 'reconnected' | 'errored' | 'reconnecting' | 'reconnectAttempt' | 'reconnectFailure' | 'failed', listener: (...args: any) => void): void;
    flush(): any;
}

type TranscriptionData = {
    id: string;
    name: string;
    peerId: string;
    userId: string;
    customParticipantId: string;
    transcript: string;
    isPartialTranscript: boolean;
    date: Date;
};
type AiEvents = {
    ['transcript']: (t: TranscriptionData) => void;
    ['*']: (event: string, ...args: any[]) => void;
};
declare class DyteAi extends DyteTypedEventEmitter<AiEvents> {
    transcripts: TranscriptionData[];
    constructor();
    static init(transcriptionEnabled: boolean): Promise<DyteAi>;
    static parseTranscript(transcriptData: string): TranscriptionData | undefined;
    static parseTranscripts(transcriptData: string): TranscriptionData[];
    getActiveTranscript(): Promise<void>;
    onTranscript(transcript: TranscriptionData): Promise<void>;
}

type ActiveTabType = 'screenshare' | 'plugin';
interface ActiveTab {
    type: ActiveTabType;
    id: string;
}
declare enum TabChangeSource {
    User = 0,
    Meeting = 1
}
type MetaEvents = {
    ['connected']: () => void;
    ['disconnected']: () => void;
    ['poorConnection']: (payload: {
        score: number;
    }) => void;
    ['connectionError']: (payload: {
        reason: string;
    }) => void;
    ['iceConnected']: (p: {
        transport: string;
    }) => void;
    ['iceDisconnected']: (p: {
        transport: string;
    }) => void;
    ['iceFailed']: (p: {
        transport: string;
    }) => void;
    ['iceReconnecting']: (p: {
        transport: string;
    }) => void;
    ['socketConnected']: () => void;
    ['socketDisconnected']: () => void;
    ['socketReconnecting']: () => void;
    ['socketReconnectAttempt']: (payload: {
        attempt: number;
    }) => void;
    ['socketReconnectFailure']: (payload: {
        attempt: number;
    }) => void;
    ['socketReconnected']: () => void;
    ['socketFailure']: () => void;
    ['meetingStartTimeUpdate']: (payload: {
        meetingStartedTimestamp: Date;
    }) => void;
    ['transcript']: (t: TranscriptionData) => void;
    ['activeTabUpdate']: (tab: ActiveTab) => void;
    ['selfTabUpdate']: (tab: ActiveTab) => void;
    ['broadcastTabChangesUpdate']: (broadcastTabChanges: boolean) => void;
    ['*']: (event: string, ...args: any[]) => void;
};
declare class DyteMeta$1 extends DyteTypedEventEmitter<MetaEvents> {
    #private;
    selfActiveTab: ActiveTab | undefined;
    broadcastTabChanges: boolean;
    viewType: string;
    meetingStartedTimestamp: Date;
    meetingTitle: string;
    sessionId: string;
    constructor(self: DyteSelf, viewType: string, meetingTitle: string);
    get joined(): boolean;
    get roomName(): string;
    get meetingId(): string;
    get mediaConnected(): boolean;
    get socketConnected(): boolean;
    setBroadcastTabChanges(broadcastTabChanges: boolean): void;
    setSelfActiveTab(spotlightTab: ActiveTab, tabChangeSource: TabChangeSource): void;
}

interface DyteMapEvents<T extends EventMap> {
    onAddEvent?: keyof T;
    onDeleteEvent?: keyof T;
    onClearEvent?: keyof T;
}
type ModifyPrependObject<T extends EventMap, U> = {
    [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>;
} & {
    ['*']: (event: String, ...args: any[]) => void;
};
declare class DyteMap<T extends (EventMap & WildCardEvent<T>), U extends {
    id: string;
} & DyteTypedEventEmitter<T>, V extends EventMap> extends Map<string, U> {
    #private;
    readonly onAddEvent: keyof V;
    readonly onDeleteEvent: keyof V;
    readonly onClearEvent: keyof V;
    constructor(options: DyteMapEvents<V>);
    emit<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, ...args: Parameters<(V | ModifyPrependObject<T, U>)[E]>): boolean;
    on<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    addListener<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    off<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    once<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    prependListener<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    prependOnceListener<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    removeListener<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E, callback: (ModifyPrependObject<T, U> & V)[E]): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    removeAllListeners<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event?: E): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    listeners<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E): Function[];
    listenerCount<E extends StringKeyOf<ModifyPrependObject<T, U> & V>>(event: E): number;
    getMaxListeners(): number;
    setMaxListeners(n: number): DyteTypedEventEmitter<{ [K in keyof T]: (obj: U, ...args: Parameters<T[K]>) => ReturnType<T[K]>; } & {
        "*": (event: String, ...args: any[]) => void;
    } & V>;
    eventNames(): (string | symbol)[];
    add(obj: U, emitEvent?: boolean): this;
    set(objId: string, obj: U, emitEvent?: boolean): this;
    delete(objId: string, emitEvent?: boolean, removeListeners?: boolean): boolean;
    clear(emitEvent?: boolean, removeListeners?: boolean): void;
    toArray(): U[];
}

type ParticipantMapEvents = {
    ['participantJoined']: (payload: DyteParticipant$1) => void;
    ['participantLeft']: (payload: DyteParticipant$1) => void;
    ['participantsCleared']: () => void;
    ['participantsUpdate']: () => void;
    ['kicked']: (payload: {
        id: string;
    }) => void;
};
declare class DyteParticipantMap$1<T extends Pick<DyteParticipant$1, 'id' | keyof DyteTypedEventEmitter<ParticipantEvents>> = DyteParticipant$1> extends DyteMap<ParticipantEvents, T, ParticipantMapEvents> {
    constructor(options?: DyteMapEvents<ParticipantMapEvents>);
    add(participant: T, emitEvent?: boolean): this;
    clear(emitEvent?: boolean, removeListeners?: boolean): void;
    delete(participantId: string, emitEvent?: boolean, removeListeners?: boolean): boolean;
}

declare class DyteSelectedPeers {
    private readonly _activeSpeakerPeers;
    private readonly _compulsoryPeers;
    constructor();
    add(peerId: string, priority: number): number;
    delete(peerId: string): void;
    index(peerId: string): number;
    get peers(): string[];
    get compulsoryPeers(): string[];
    get peerPriorities(): number[];
    get activeSpeakerPeers(): string[];
    private _removeFromCompulsoryPeer;
}

declare enum RequestToJoinType {
    PRESENT = "REQUEST_TO_PRESENT"
}
interface AcceptJoinStageRequest {
    id: string;
    requestToJoinType: RequestToJoinType;
}

interface DyteBasicParticipant {
    userId: string;
    name?: string;
    picture?: string;
    customParticipantId: string;
}
declare class DyteBasicParticipantsMap extends DyteEventEmitter<'participantsUpdate'> {
    #private;
    constructor();
    __set(objId: string, obj: DyteBasicParticipant): Map<string, DyteBasicParticipant>;
    __clear(): void;
    get(objId: string): DyteBasicParticipant;
    toArray(): DyteBasicParticipant[];
}

type PipEvents = {
    ['cameraToggled']: () => void;
    ['micToggled']: () => void;
    ['hangup']: () => void;
    ['pipStarted']: () => void;
    ['pipEnded']: () => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DytePip extends DyteTypedEventEmitter<PipEvents> {
    #private;
    constructor(self: DyteSelf$1);
    private createVideoContainer;
    private setupEventListeners;
    private cleanupEventListeners;
    private enablePipMediaControls;
    private onSelfVideoUpdateListener;
    private onSelfAudioUpdateListener;
    private createCanvas;
    private eventCallback;
    private setupMediaSessionEvents;
    private mountAudioEvents;
    private mountVideoEvents;
    private unmountEvents;
    private getSources;
    private drawEmptyTile;
    private drawGrid;
    private calcGridElemSize;
    private paintCanvas;
    private animate;
    isSupported(): boolean;
    get isActive(): boolean;
    private cleanup;
    init({ height, width }?: {
        height?: number;
        width?: number;
    }): void;
    private updateMediaSession;
    enableSource(source: string): void;
    disableSource(source: string): void;
    addSource(id: string, element: HTMLVideoElement, enabled: boolean, pinned?: boolean, displayText?: string): void;
    removeSource(id: string): void;
    removePinnedSource(): void;
    removeAllSources(): void;
    enable(): void;
    disable: () => void;
}

type ViewMode = 'ACTIVE_GRID' | 'PAGINATED';
interface BroadcastMessagePayload {
    [key: string]: boolean | number | string | Date | ActiveTab;
}
type BroadcastMessageTarget = {
    participantIds: string[];
} | {
    presetNames: string[];
};
type JoinedPeer = {
    id: string;
    userId: string;
    name: string;
    stageType?: StageStatus;
    customParticipantId?: string;
    presetId?: string;
    picture?: string;
    waitlisted: boolean;
    recorderType?: string;
    stageStatus?: WebinarStageStatus;
    metadata?: {
        preset_name?: string;
    };
    flags?: {
        hiddenParticipant?: boolean;
        recorder?: boolean;
    };
};
type ParticipantsEvents = {
    ['viewModeChanged']: (payload: {
        viewMode: string;
        currentPage: number;
        pageCount: number;
    }) => void;
    ['activeSpeaker']: (payload: {
        peerId: string;
        volume: number;
    }) => void;
    ['broadcastedMessage']: (payload: {
        type: string;
        payload: BroadcastMessagePayload;
        timestamp: number;
    }) => void;
    ['poorConnection']: (payload: {
        participantId: string;
        score: number;
        kind: string;
    }) => void;
    ['pageChanged']: (payload: {
        viewMode: string;
        currentPage: number;
        pageCount: number;
    }) => void;
    ['mediaScoreUpdate']: (payload: {
        kind: string;
        isScreenshare: boolean;
        score: number;
        participantId: string;
    }) => void;
    ['*']: (event: string, ...args: any[]) => void;
};
declare class DyteParticipants$1 extends DyteTypedEventEmitter<ParticipantsEvents> {
    #private;
    readonly waitlisted: Readonly<DyteParticipantMap$1<Omit<DyteParticipant$1, 'audioTrack' | 'videoTrack' | 'screenShareTracks'>>>;
    readonly joined: Readonly<DyteParticipantMap$1>;
    readonly active: Readonly<DyteParticipantMap$1>;
    readonly pinned: Readonly<DyteParticipantMap$1>;
    readonly all: Readonly<DyteBasicParticipantsMap>;
    readonly pip: Readonly<DytePip>;
    private get roomJoined();
    viewMode: ViewMode;
    currentPage: number;
    lastActiveSpeaker: string;
    selectedPeers: DyteSelectedPeers;
    constructor(self: DyteSelf$1, modules?: Modules);
    get count(): number;
    get maxActiveParticipantsCount(): number;
    get pageCount(): number;
    acceptWaitingRoomRequest(id: string): void;
    acceptAllWaitingRoomRequest(userIds: string[]): Promise<void>;
    rejectWaitingRoomRequest(id: string): Promise<void>;
    setViewMode(viewMode: ViewMode): Promise<void>;
    getPeerIdsForCurrentPage(): string[];
    setPage(page: number): Promise<void>;
    disableAllAudio(allowUnmute: boolean): Promise<void>;
    disableAllVideo(): Promise<void>;
    disableAudio(participantId: string): Promise<void>;
    disableVideo(participantId: string): Promise<void>;
    kick(participantId: string): Promise<void>;
    kickAll(): Promise<void>;
    broadcastMessage(type: Exclude<string, 'spotlight'>, payload: BroadcastMessagePayload, target?: BroadcastMessageTarget): Promise<void>;
    acceptAllRequestToJoinStageRequests(acceptJoinStageRequests: AcceptJoinStageRequest[]): Promise<void>;
    getAllJoinedPeers(searchQuery: string, limit: number, offset: number): Promise<any[]>;
    updatePermissions(participantIds: string[], permissions: PresetUpdates): Promise<void>;
    getAllPeersInRoom(): Promise<any[]>;
    setMockParticipantCount(total: number, active: number): Promise<void>;
}

interface UserDetailsResponseV2 {
    participant: UserDetailsResponse;
    preset: PresetV2CamelCased;
}
type leaveRoomState = 'kicked' | 'ended' | 'left' | 'rejected' | 'connected-meeting' | 'disconnected';

type WebsocketMessage = {
    type: string;
    payload?: any;
    metadata?: {
        [key: string]: any;
    };
};

type PluginSocketMessage = DisablePluginResponse | EnablePluginResponse | PluginEventResponse | PluginStoreResponse | SendChatMessageToPeersResponse | SendChatMessageToRoomResponse;
declare class PluginSocketHandler {
    #private;
    constructor(socketService: SocketService);
    addPlugin(pluginId: string, staggered: boolean): void;
    removePlugin(pluginId: string): void;
    getActivePlugins(): Promise<EnablePluginsResponse>;
    customPluginEventToRoom(pluginId: string, data: any, messageId?: string): void;
    customPluginEventToPeers(pluginId: string, peerIds: string[], data: any, messageId?: string): void;
    enablePluginForRoom(pluginId: string, messageId?: string): void;
    enablePluginForPeers(pluginId: string, peerIds: string[], messageId?: string): void;
    disablePluginForRoom(pluginId: string, messageId?: string): void;
    disablePluginForPeers(pluginId: string, peerIds: string[], messageId?: string): void;
    storeInsertKeys(pluginId: string, store: string, insertKeys: {
        key: string;
        payload?: any;
    }[], messageId?: string): void;
    storeGetKeys(pluginId: string, store: string, getKeys: {
        key: string;
    }[], messageId?: string): void;
    storeDeleteKeys(pluginId: string, store: string, deleteKeys: {
        key: string;
    }[], messageId?: string): void;
    storeDelete(pluginId: string, store: string, messageId?: string): void;
    getPluginDataOld(pluginId: string, store: string): void;
    storePluginDataOld(pluginId: string, store: string, data: any): void;
    on(event: number, handler: (socketMessage: PluginSocketMessage, messageId?: string) => void): void;
}

interface ChatChannel {
    id: string;
    displayName: string;
    memberIds: string[];
    displayPictureUrl?: string;
    visibility?: string;
    isDirectMessage?: boolean;
    latestMessage?: Message;
    unreadCount: number;
}
interface UpdateChannelRequestPayload {
    memberIds?: string[];
    displayName?: string;
    displayPictureUrl?: string;
    visibility?: string;
}

interface SearchFilters {
    channelId?: string;
    timestamp?: number;
    size?: number;
    reversed?: boolean;
}

interface IceServerInformation {
    url: string;
    username?: string;
    urls: string;
    credential?: string;
}
interface CachedUserDetails {
    pluginInformation: DytePluginResponse[];
    userDetails: UserDetailsResponseV2;
    roomDetails: RoomDetails;
    iceServers: IceServerInformation[];
}

interface RecordingConfig {
    fileNamePrefix?: string;
    videoConfig?: {
        height?: number;
        width?: number;
        codec?: string;
    };
}
interface ReactNativeFile {
    uri: string;
    name: string;
    type: string;
}

declare enum MessageType {
    text = "text",
    image = "image",
    file = "file",
    custom = "custom",
    poll = "poll"
}
interface BaseMessage<T extends MessageType> {
    type: T;
    userId: string;
    displayName: string;
    time: Date;
    timeMs?: number;
    id: string;
    isEdited?: boolean;
    read?: boolean;
    pluginId?: string;
    pinned?: boolean;
    targetUserIds?: string[];
    channelId?: string;
    channelIndex?: string;
}
interface TextMessage extends BaseMessage<MessageType.text> {
    message: string;
}
interface CustomMessage extends BaseMessage<MessageType.custom> {
    message?: string;
    html?: string;
    files?: string[];
    images?: string[];
    videos?: string[];
}
interface ImageMessage extends BaseMessage<MessageType.image> {
    link: string;
}
interface FileMessage extends BaseMessage<MessageType.file> {
    name: string;
    size: number;
    link: string;
}
type Message = TextMessage | ImageMessage | FileMessage | CustomMessage;
interface TextMessagePayload {
    type: 'text';
    message: string;
    replyTo?: TextMessage;
}
interface CustomMessagePayload {
    type: 'custom';
    message: string;
    replyTo?: TextMessage;
}
interface ImageMessagePayload {
    type: 'image';
    image: File;
}
interface FileMessagePayload {
    type: 'file';
    file: File;
}
type MessagePayload = TextMessagePayload | ImageMessagePayload | FileMessagePayload | CustomMessagePayload;
interface ChatUpdateParams {
    action: 'add' | 'edit' | 'delete';
    message: Message | {
        id: string;
        channelId: string;
    };
    messages: Message[];
}
type ChatEvents = {
    ['chatUpdate']: (payload: ChatUpdateParams) => void;
    ['pinMessage']: (payload: Omit<ChatUpdateParams, 'action'>) => void;
    ['unpinMessage']: (payload: Omit<ChatUpdateParams, 'action'>) => void;
    ['channelCreate']: (channel: ChatChannel) => void;
    ['channelMessageUpdate']: (channel: ChatChannel) => void;
    ['channelUpdate']: (channel?: ChatChannel) => void;
    ['*']: (event: string, ...args: any[]) => void;
};
declare class DyteChat$1 extends DyteTypedEventEmitter<ChatEvents> {
    #private;
    messages: Message[];
    channels: ChatChannel[];
    private get roomJoined();
    constructor(self: DyteSelf$1, participants: DyteParticipants$1);
    private sendMessageInternal;
    private sendTextMessageInternal;
    private sendImageMessageInternal;
    private sendFileMessageInternal;
    sendTextMessage(message: string, peerIds?: string[]): Promise<void>;
    sendCustomMessage(message: Pick<CustomMessage, 'message' | 'html' | 'videos' | 'images' | 'files'>, peerIds?: string[]): Promise<void>;
    sendImageMessage(image: File, peerIds?: string[]): Promise<void>;
    sendFileMessage(file: File, peerIds?: string[]): Promise<void>;
    sendMessage(message: MessagePayload, participantIds?: string[]): Promise<void>;
    editTextMessage(messageId: string, message: string, channelId?: string): Promise<void>;
    editImageMessage(messageId: string, image: File, channelId?: string): Promise<void>;
    editFileMessage(messageId: string, file: File | ReactNativeFile, channelId?: string): Promise<void>;
    editMessage(messageId: string, message: MessagePayload, channelId?: string): Promise<void>;
    deleteMessage(messageId: string, channelId?: string): Promise<void>;
    getMessagesByUser(userId: string): Message[];
    getMessagesByType(type: keyof typeof MessageType): Message[];
    pin(id: string): Promise<void>;
    unpin(id: string): Promise<void>;
    getMessages(timeStamp: number, size: number, reversed: boolean, offset?: number, channelId?: string): Promise<any>;
    createChannel(channelName: string, memberIds: string[], options?: {
        displayPictureUrl?: string;
        visibility?: string;
        isDirectMessage?: boolean;
    }): Promise<{}>;
    updateChannel(channelId: string, payload: UpdateChannelRequestPayload): {};
    sendMessageToChannel(message: MessagePayload, channelId: string, options?: {
        replyTo?: Message;
    }): Promise<void>;
    getChannelMembers(channelId: string): Promise<any>;
    searchMessages(query: string, filters?: SearchFilters): Promise<any>;
    markLastReadMessage(channelId: string, message: Message): Promise<void>;
    get pinned(): Message[];
}

interface DytePluginResponse {
    baseURL: string;
    createdAt: string;
    description: string;
    id: string;
    name: string;
    organizationId: string;
    picture: string;
    private: boolean;
    published: boolean;
    staggered: boolean;
    tags: string[];
    type: string;
    updatedAt: string;
}
interface PluginViews {
    [viewId: string]: {
        url: string;
        suggestedPosition: string;
    };
}
interface PluginConfig {
    name: string;
    pluginId: string;
    version: string;
    description: string;
    author?: string;
    repository?: string;
    tags?: string[];
    picture?: string;
    url?: string;
    files: {
        include: string[];
        exclude?: string[];
    };
    views?: PluginViews;
    contentScript?: string;
    permissions?: {
        [key: string]: {
            default: boolean;
            description: string;
        };
    };
    config?: {
        [key: string]: string;
    };
}
interface PluginIframeMessage {
    type: number;
    uuid: string;
    payload?: any;
}
interface SendDataOptions {
    eventName: string;
    data: any;
}
interface ReactNativeWebViewEvent {
    nativeEvent: {
        data: string;
    };
}
interface ReactNativeWebView {
    src: string;
    allow: string;
    title: string;
    props: {
        onMessage: (event: ReactNativeWebViewEvent) => void;
    };
    postMessage: (message: string) => void;
}
type PluginEvents = {
    ['stateUpdate']: (payload: {
        active: boolean;
        pluginId: string;
        bind?: (...args: any[]) => void;
        views: PluginViews;
    }) => void;
    ['ready']: () => void;
    ['closed']: () => void;
    ['toggleViewMode']: (...args: any[]) => void;
    ['enabled']: () => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DytePlugin$1 extends DyteTypedEventEmitter<PluginEvents> {
    #private;
    readonly baseURL: string;
    readonly createdAt: Date;
    readonly description: string;
    readonly id: string;
    readonly name: string;
    readonly organizationId: string;
    readonly picture: string;
    readonly private: boolean;
    readonly published: boolean;
    readonly staggered: boolean;
    readonly tags: string[];
    readonly type: string;
    readonly updatedAt: Date;
    config?: PluginConfig;
    active: boolean;
    iframes: Map<string, {
        iframe: HTMLIFrameElement | ReactNativeWebView;
        listener?: (message: MessageEvent) => void;
    }>;
    enabledBy: string;
    private get roomJoined();
    constructor({ baseURL, createdAt, description, id, name, organizationId, picture, private: isPrivate, published, staggered, tags, type, updatedAt, }: DytePluginResponse, pluginSocketHandler: PluginSocketHandler, socketServerName: PluginSocketServerName, self: DyteSelf$1, participants: DyteParticipants$1, chat: Readonly<DyteChat$1>);
    sendIframeEvent(message: PluginIframeMessage | WebsocketMessage): void;
    private handleIframeMessage;
    sendData(payload: SendDataOptions): void;
    removePluginView(viewId?: string): void;
    addPluginView(iframe: HTMLIFrameElement | ReactNativeWebView, viewId?: string): void;
    private setActive;
    activateForSelf(): Promise<void>;
    deactivateForSelf(): void;
    enable(): Promise<void>;
    disable(): void;
    activate(): Promise<void>;
    deactivate(): Promise<void>;
}

type PluginMapEvents = {
    ['pluginAdded']: (plugin: DytePlugin$1) => void;
    ['pluginDeleted']: (plugin: DytePlugin$1) => void;
};
declare class DytePluginMap$1<T extends DytePlugin$1 = DytePlugin$1> extends DyteMap<PluginEvents, T, PluginMapEvents> {
    constructor();
    add(plugin: T, emitEvent?: boolean): this;
    delete(pluginId: string, emitEvent?: boolean, removeListeners?: boolean): boolean;
}

declare class DytePlugins$1 {
    readonly all: DytePluginMap$1;
    readonly active: DytePluginMap$1;
    constructor();
}

type PluginSocketServerName = 'socket-service' | 'room-node';

interface PollOption {
    text: string;
    votes: {
        id: string;
        name: string;
    }[];
    count: number;
}
interface Poll {
    id: string;
    question: string;
    options: PollOption[];
    anonymous: boolean;
    hideVotes: boolean;
    createdBy: string;
    createdByUserId: string;
    voted: string[];
}
type PollsEvents = {
    ['pollsUpdate']: (payload: {
        polls: Poll[];
        newPoll: boolean;
    }) => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DytePolls$1 extends DyteTypedEventEmitter<PollsEvents> {
    #private;
    items: Poll[];
    private get roomJoined();
    constructor(self: DyteSelf$1);
    create(question: string, options: string[], anonymous?: boolean, hideVotes?: boolean): Promise<void>;
    vote(id: string, index: number): Promise<void>;
}

declare enum RemoteRequestState {
    PENDING = "PENDING",
    ACCEPTED = "ACCEPTED",
    REJECTED = "REJECTED",
    ENDED = "ENDED"
}
interface RemoteRequest {
    requestId: string;
    hostPeerId: string;
    remotePeerId: string;
    state: RemoteRequestState;
}
interface RemoteUpdatePayload {
    request: {
        id: string;
        hostPeerId: string;
        remotePeerId: string;
    };
    meta?: {
        [key: string]: any;
    };
}
declare enum RemoteUpdateType {
    REQUEST_RECEIVED = "REQUEST_RECEIVED",
    REQUEST_SENT = "REQUEST_SENT",
    INCOMING_REQUEST_ACCEPTED = "INCOMING_REQUEST_ACCEPTED",
    OUTGOING_REQUEST_ACCEPTED = "OUTGOING_REQUEST_ACCEPTED",
    INCOMING_REQUEST_ENDED = "INCOMING_REQUEST_ENDED",
    OUTGOING_REQUEST_ENDED = "OUTGOING_REQUEST_ENDED"
}
declare class DyteRemoteRequest extends DyteEventEmitter<string | symbol> {
    id: string;
    remotePeerId: string;
    hostPeerId: string;
    state: RemoteRequestState;
    constructor(request: RemoteRequest);
}

type RemoteMapEvents = {
    ['remoteRequestAdd']: (request: DyteRemoteRequest) => void;
    ['remoteRequestRemove']: (request: DyteRemoteRequest) => void;
};
declare class DyteRemoteMap<T extends DyteRemoteRequest = DyteRemoteRequest> extends DyteMap<RemoteEvents, T, RemoteMapEvents> {
    constructor();
    add(request: T, emitEvent?: boolean): this;
    delete(requestId: string, emitEvent?: boolean, removeListeners?: boolean): boolean;
}

type RemoteEvents = {
    ['remoteUpdate']: (data: {
        payload: RemoteUpdatePayload;
        type: RemoteUpdateType;
    }) => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DyteRemote extends DyteTypedEventEmitter<RemoteEvents> {
    #private;
    incomingRequests: DyteRemoteMap;
    outgoingRequests: DyteRemoteMap;
    active: DyteRemoteRequest | null;
    constructor(self: DyteSelf$1, participants: DyteParticipants$1);
    requestControl(peerId: string): Promise<string>;
    acceptControl(requestId: string): Promise<void>;
    endControl(): Promise<void>;
    keyboardEvent(event: KeyboardEvent): Promise<void>;
    mouseEvent(event: MouseEvent | WheelEvent, screenShareVideoElement: HTMLVideoElement): Promise<void>;
    private static getFormattedRemoteMouseEvent;
    private static getFormattedKeyboardEvent;
}

declare global {
    interface Window {
        DyteRobot: {
            mouse: {
                moveTo: (x: number, y: number, browserScreen: {
                    width: number;
                    height: number;
                }) => Promise<any>;
                leftClick: (x: number, y: number, browserScreen: {
                    width: number;
                    height: number;
                }) => Promise<any>;
                rightClick: (x: number, y: number, browserScreen: {
                    width: number;
                    height: number;
                }) => Promise<any>;
            };
            keyboard: {
                type: (text: string) => Promise<any>;
                press: (text: string) => Promise<any>;
            };
        };
    }
}

type RecordingState = 'IDLE' | 'STARTING' | 'RECORDING' | 'PAUSED' | 'STOPPING';
type RecordingInfo = {
    state: RecordingState;
    id: string;
};
type RecordingEvents = {
    ['recordingUpdate']: (state: RecordingState) => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DyteRecording$1 extends DyteTypedEventEmitter<RecordingEvents> {
    #private;
    recordingPeerIds: string[];
    get recordingState(): RecordingState;
    recordings: RecordingInfo[];
    constructor(self: DyteSelf);
    updateRecordings(recordings: RecordingInfo[]): void;
    start(opts?: {
        allowMultiple: boolean;
    }): Promise<void>;
    stop(recordingId?: string): Promise<void>;
    pause(recordingId?: string): Promise<void>;
    resume(recordingId?: string): Promise<void>;
}

declare class BrowserDetection {
    _bowser: any;
    _name: any;
    _version: any;
    init(browserInfo?: any): void;
    getName(): any;
    isChrome(): boolean;
    isOpera(): boolean;
    isFirefox(): boolean;
    isIExplorer(): boolean;
    isSafari(): boolean;
    isNWJS(): boolean;
    isElectron(): boolean;
    isReactNative(): boolean;
    getVersion(): any;
    isMobile(): boolean;
    getDeviceInfo: () => {
        isMobile: boolean;
        browserName: any;
        osName: any;
        browserVersion: any;
        osVersionName: any;
        engineName: any;
    };
    _checkCondition(checkTree: any): any;
    isVersionGreaterThan(version: any): any;
    isVersionLessThan(version: any): any;
    isVersionEqualTo(version: any): any;
}

declare class BrowserCapabilities extends BrowserDetection {
    doesVideoMuteByStreamRemove(): boolean;
    supportsP2P(): boolean;
    isChromiumBased(): boolean;
    isWebKitBased(): boolean;
    isSupported(): boolean;
    isUserInteractionRequiredForUnmute(): any;
    supportsVideoMuteOnConnInterrupted(): boolean;
    supportsBandwidthStatistics(): boolean;
    supportsCodecPreferences(): boolean;
    supportsDeviceChangeEvent(): boolean;
    supportsLocalCandidateRttStatistics(): boolean;
    supportsPerformanceObserver(): boolean;
    supportsReceiverStats(): boolean;
    supportsRTTStatistics(): boolean;
    usesPlanB(): boolean;
    usesSdpMungingForSimulcast(): boolean;
    usesUnifiedPlan(): boolean;
    usesNewGumFlow(): boolean;
    usesAdapter(): boolean;
    usesRidsForSimulcast(): boolean;
    supportsGetDisplayMedia(): boolean;
    supportsInsertableStreams(): boolean;
    supportsAudioRed(): boolean;
    supportsSdpSemantics(): boolean;
    _getChromiumBasedVersion(): number;
    isIOSMobile(): boolean;
}

declare class DyteFeatures {
    static hasFeature(featureName: string): boolean;
    static getFeatureValue(featureName: string): string;
    static getAllFeatures(): {};
}

declare const enum PRODUCERS_TYPE {
    WEBCAM = "webcam",
    MIC = "mic",
    SCREENSHARE_VIDEO = "screenshare_video",
    SCREENSHARE_AUDIO = "screenshare_audio"
}

declare function createSafeToLogError(ex: any): {
    stack?: string;
    message?: string;
    name?: string;
    reason?: string;
    code?: number | string;
};

type SupportedEventSeverities = 'info' | 'error' | 'debug' | 'log' | 'warn';
type LogData$2 = {
    error?: ReturnType<typeof createSafeToLogError>;
    flags?: string | {
        [key: string]: {
            enabled: boolean;
            value: string | number | boolean;
        };
    };
    devices?: string | MediaDeviceInfo[];
    debuggingHint?: string;
    constraints?: string | DyteMediaStreamConstraints;
    timeout?: number;
    execTime?: number;
    media?: {
        audio?: {
            enabled: boolean;
            deviceName?: string;
            deviceId?: string;
            trackId?: string;
            permission?: keyof typeof MediaPermission;
            canProduce?: CanProduceType | MediaProductionPermissionType;
        };
        video?: {
            enabled?: boolean;
            deviceName?: string;
            deviceId?: string;
            trackId?: string;
            permission?: keyof typeof MediaPermission;
            canProduce?: CanProduceType | MediaProductionPermissionType;
            layer?: number;
        };
        screenshare?: {
            enabled: boolean;
            count?: number;
            maxAllowedCount?: number;
            permission?: keyof typeof MediaPermission;
            deviceName?: string;
            deviceId?: string;
            audio?: {
                enabled: boolean;
                trackId?: string;
            };
            video?: {
                enabled: boolean;
                trackId?: string;
            };
            canProduce?: CanProduceType | MediaProductionPermissionType;
        };
    };
    preferredDevice?: {
        kind: 'audio' | 'video';
        preferredDeviceId?: string;
        lastUsedPreferredDeviceId?: string;
    };
    mediaPermissionsErrors?: {
        kind: 'audio' | 'video' | 'screenshare';
        message: string;
        deviceId?: string;
    };
    memoize?: {
        doubleInvoked?: {
            property: string;
        };
    };
    dyteClientInitOptions?: DyteClientOptions;
    plugin?: {
        id?: string;
        name?: string;
        enabledBy?: string;
        duration?: number;
        storeName?: string;
    };
    roomJoined?: boolean;
    transport?: {
        id?: string;
        type?: 'send' | 'recv';
        status?: RTCPeerConnectionState | 'reconnecting';
        lastDisconnectedTime?: string;
        lastDisconnectedTimeOffset?: number;
        durationPassed?: number;
        remoteOfferAnswer?: RTCSessionDescriptionInit;
        serverId?: string;
    };
    iceCandidate?: RTCIceCandidate;
    iceRestart?: {
        status?: RTCPeerConnectionState | 'reconnecting';
        isSendTransport?: boolean;
        isRecvTransport?: boolean;
        currentAttempt?: number;
    };
    producer?: {
        id: string;
        peerId?: string;
        kind: PRODUCERS_TYPE | any;
        status?: 'initializing' | 'producing' | 'paused' | 'failed' | 'closed' | 'UNKNOWN';
        appData: {
            screenShare?: boolean;
            supportsRemoteControl?: boolean;
        };
        closureReason?: string;
        remoteAnswer?: SessionDescription;
        trackId?: string;
    };
    consumer?: {
        id: string;
        peerId?: string;
        kind?: any;
        appData?: {
            screenShare?: boolean;
            supportsRemoteControl?: boolean;
        };
        remotelyPaused?: boolean;
        producerId?: string;
        closureReason?: string;
    };
    consumerState?: ConsumerState;
    consumerStateMap?: {
        [key: string]: ConsumerState;
    };
    rtcChannel?: {
        label?: string;
        message?: DCMessage;
        messageStringified?: string;
    };
    localStorage?: {
        key?: string;
        value?: string;
    };
    spotlight?: {
        spotlighter?: {
            id?: string;
        };
        currentTab?: {
            id?: string;
            type?: ActiveTabType;
        };
    };
    networkCall?: {
        status?: number;
        statusText?: string;
        baseURL?: string;
        url?: string;
        retries?: number;
        method?: string;
        isOnline?: string;
        ip?: any;
        timezone?: string;
    };
    ipInfo?: {
        city: string;
        country: string;
        region: string;
        loc: string;
        timezone: string;
        ip: string;
        postal: string;
    };
    dytePolls?: {
        hasQuestion?: boolean;
        optionsLength?: number;
    };
    dyteChat?: {
        imageType?: string;
        messageType?: string;
    };
    dyteParticipant?: {
        id: string;
    };
    actions?: {
        disableAllAudio?: {
            allowUnmute?: boolean;
        };
        trackRobustness?: {
            reacquireTrack?: boolean;
            eventType?: string;
        };
    };
    recording?: {
        id?: string;
        state?: RecordingState;
    };
    selectedPeer?: {
        oldIndex?: number;
        newIndex?: number;
        peerId?: string;
    };
    pageNavigation?: {
        viewMode: string;
        currentPage: number;
        pageCount: number;
        maxActiveParticipantsCount: number;
        settingPage?: number;
    };
    connectedMeetings?: {
        movement?: {
            sourceMeetingId?: string;
            destinationMeetingId?: string;
            totalParticipantsToMove?: number;
        };
    };
    webinar?: {
        stageStatus?: WebinarStageStatus;
    };
    livestream?: {
        stageStatus?: StageStatus;
        latency?: number;
    };
    moduleExists?: {
        self?: boolean;
    };
    performanceObserver?: {
        api: PerformanceEntry;
    };
    dyteLocker?: {
        methodName: string;
        lockName: string;
    };
    socket?: {
        retryAttempt: number;
    };
    source?: string;
    eventListener?: {
        eventName: string;
        listenerCount: number;
    };
};

type EventSeverities = SupportedEventSeverities;
type LogData$1 = LogData$2;
declare class DyteTelemetry {
    static logsCache: {
        [key: string]: any;
    }[];
    static logsProcessorTimer: NodeJS.Timer;
    static get logsEndpoint(): string;
    static tracingEnabled: boolean;
    static initialized: boolean;
    static readonly logsProcessingInterval = 7000;
    static logExclusionList: string[];
    static meetingMetadata: {
        peerId?: string;
        roomName?: string;
        organizationId?: string;
        sdkVersion?: string;
        deviceInfo?: object;
        visitedUrl?: string;
        userId?: string;
    };
    static init(peerId: string, enableTracing: boolean): void;
    static trace(spanName: string): (_target: Object, _propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
    static injectContext(injectionReceiver: any): void;
    static addLogInCurrentSpan(eventSeverity: EventSeverities, eventName: string, metadata?: LogData$1, noCache?: boolean): void;
    static sendOtelLogsToNewRelic(logs: object[]): void;
    static processCachedLogs(): void;
    static destruct(): void;
}

type LogData = LogData$1;
declare class DyteLogger {
    static info(humanReadableLogIdentifier: string, logData?: LogData, isCrucial?: boolean): void;
    static error(humanReadableLogIdentifier: string, logData?: LogData, isCrucial?: boolean): void;
    static debug(humanReadableLogIdentifier: string, logData?: LogData, isCrucial?: boolean): void;
    static log(humanReadableLogIdentifier: string, logData?: LogData, isCrucial?: boolean): void;
    static warn(humanReadableLogIdentifier: string, logData?: LogData, isCrucial?: boolean): void;
}

declare class DyteInternals {
    logger: typeof DyteLogger;
    features: typeof DyteFeatures;
    browserSpecs: BrowserCapabilities;
    constructor(logger: typeof DyteLogger, features: typeof DyteFeatures);
    static init(): DyteInternals;
}

type LivestreamState = 'IDLE' | 'STARTING' | 'LIVESTREAMING' | 'STOPPING';
type LivestreamEvents = {
    ['livestreamUpdate']: (state: LivestreamState) => void;
    ['viewerCountUpdate']: (count: number) => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DyteLivestream$1 extends DyteTypedEventEmitter<LivestreamEvents> {
    #private;
    state: LivestreamState;
    playbackUrl: string | undefined;
    viewerCount: number;
    constructor(self: DyteSelf);
    setLivestreamState(livestreamState: LivestreamState): void;
    private emitCurrentLivestreamState;
    start(): Promise<void>;
    stop(): Promise<void>;
}

type MicMetadata$1 = {
    label?: string;
    channelCount?: number;
    channelCountMode?: ChannelCountMode;
    channelType?: 'MONO' | 'STEREO' | 'QUAD';
    channelInterpretation?: ChannelInterpretation;
    outputs?: number;
};

declare class WebMediaInterface extends BaseMediaInterface {
    #private;
    constructor(mediaConstraints?: MediaConstraints);
    get constraintsBuilder(): ConstraintBuilder;
    destruct(): Promise<void>;
    private handlePermissionErrors;
    getAudioAndVideoTrack(): Promise<{
        audioTrack: MediaStreamTrack;
        videoTrack: MediaStreamTrack;
    }>;
    getAudioTrack(isMutedOnInit: boolean, deviceId?: string): Promise<MediaStreamTrack>;
    getScreenShareTracks(): Promise<{
        audioTrack: MediaStreamTrack;
        videoTrack: MediaStreamTrack;
    }>;
    private getCurrentDeviceLabel;
    getVideoTrack(deviceId?: string): Promise<MediaStreamTrack>;
    getAvailableDevices(): Promise<InputDeviceInfo[]>;
    getAvailableDevicesByKind(kind: MediaDeviceInfo['kind']): Promise<MediaDeviceInfo[]>;
    getDevice(deviceId: string): Promise<MediaDeviceInfo>;
    onDeviceChange(callback: (ev?: Event, changedDevices?: {
        added: MediaDeviceInfo[];
        removed: MediaDeviceInfo[];
    }, skipDeviceChange?: boolean) => void): Promise<void>;
}

declare class DyteAudioTroubleshooter extends DyteEventEmitter<TroubleshooterEvents> {
    #private;
    constructor(self: DyteSelf$1, media: WebMediaInterface);
    get mediaPermission(): MediaPermission$1;
    getTrackMetadata(forced?: boolean): Promise<MicMetadata$1>;
    startTrackAnalysis(forced?: boolean): Promise<boolean>;
    stopTrackAnalysis(): boolean;
}

type NetworkMetadata = {
    connectivity: {
        reflexive: boolean;
        host: boolean;
        relay: boolean;
    };
    effectiveNetworkType: string;
    RTT: number;
    backendRTT: number;
    throughput: number;
    jitter: number;
    turnConnectivity: boolean;
    ipDetails: {
        city: string;
        country: string;
        region: string;
        ip: string;
        privacy: {
            hosting: boolean;
            proxy: boolean;
            vpn: boolean;
            relay: boolean;
            tor: boolean;
            service: string;
        };
    };
};
declare class DyteNetworkTroubleshooter extends DyteEventEmitter<TroubleshooterEvents> {
    #private;
    constructor();
    getNetworkMetadata(): Promise<NetworkMetadata>;
    startNetworkAnalysis(): boolean;
    stopNetworkAnalysis(): boolean;
}

type CameraMetadata = {
    label?: string;
    resolution?: number[];
};

declare class DyteScreenshareTroubleshooter extends DyteEventEmitter<TroubleshooterEvents> {
    #private;
    constructor(self: DyteSelf$1);
    get mediaPermission(): MediaPermission$1;
    getAudioTrackMetaData(): MicMetadata$1;
    getVideoTrackMetaData(): CameraMetadata;
    startAudioTrackAnalysis(): Promise<boolean>;
    startVideoTrackAnalysis(): Promise<boolean>;
    stopAudioTrackAnalysis(): boolean;
    stopVideoTrackAnalysis(): boolean;
}

declare class DyteVideoTroubleshooter extends DyteEventEmitter<TroubleshooterEvents> {
    #private;
    preview: boolean;
    constructor(self: DyteSelf$1, media: WebMediaInterface);
    get mediaPermission(): MediaPermission$1;
    getTrackMetadata(): CameraMetadata;
    startTrackAnalysis({ preview }?: {
        preview: boolean;
    }): Promise<boolean>;
    stopTrackAnalysis(): void;
    startPreview(): Promise<MediaStreamTrack>;
    stopPreview(): void;
    cleanup(): void;
}

declare class DyteTroubleshooter {
    audio: DyteAudioTroubleshooter;
    video: DyteVideoTroubleshooter;
    screenshare: DyteScreenshareTroubleshooter;
    network: DyteNetworkTroubleshooter;
    constructor(self: DyteSelf$1);
}

interface Modules {
    chat?: boolean;
    participant?: boolean;
    plugin?: boolean;
    poll?: boolean;
    self?: boolean;
    meta?: boolean;
    permissions?: boolean;
    theme?: boolean;
    remoteControl?: boolean;
    connectedMeetings?: boolean;
    recording?: boolean;
    livestream?: boolean;
    tracing?: boolean;
    devTools?: {
        logs: boolean;
        plugins?: {
            id: string;
            name: string;
            port: number;
            picture?: string;
            description?: string;
            staggered?: boolean;
        }[];
    };
    stage?: boolean;
    internals?: boolean;
    pip?: boolean;
}
interface DefaultOptions {
    video?: boolean;
    audio?: boolean;
    screenShare?: {
        displaySurface?: 'window' | 'monitor' | 'browser';
    };
    mediaConfiguration?: {
        video?: VideoQualityConstraints;
        audio?: AudioQualityConstraints;
        screenshare?: VideoQualityConstraints;
    };
    isNonPreferredDevice?: (device: MediaDeviceInfo) => boolean;
    autoSwitchAudioDevice?: boolean;
    recording?: RecordingConfig;
    mediaHandler?: DyteSelfMedia;
}
interface RoomDetails {
    roomNodeUrl: string;
    meetingTitle: string;
    useHiveMedia: boolean;
}
interface ControllerOptions {
    roomName?: string;
    authToken: string;
    apiBase?: string;
    defaults?: DefaultOptions;
    modules?: Modules;
    peerId?: string;
    overrides?: {
        [key: string]: boolean | string;
    };
    baseURI?: string;
    cachedUserDetails?: CachedUserDetails;
}

interface ConnectedMeetingParticipant {
    id?: string;
    customParticipantId?: string;
    presetId?: string;
    displayName?: string;
    displayPictureUrl?: string;
}
interface ConnectedMeeting {
    id?: string;
    title?: string;
    participants: ConnectedMeetingParticipant[];
}

type ConnectedMeetingsEvents = {
    ['meetingChanged']: (meeting: DyteClient) => void;
    ['stateUpdate']: (payload: {
        meetings: ConnectedMeeting[];
        parentMeeting: ConnectedMeeting;
    }) => void;
    ['changingMeeting']: (meetingId: string) => void;
    ['*']: (eventName: string, ...args: any[]) => void;
};
declare class DyteConnectedMeetings$1 extends DyteTypedEventEmitter<ConnectedMeetingsEvents> {
    #private;
    constructor(meeting: DyteClient);
    meetings: ConnectedMeeting[];
    parentMeeting: ConnectedMeeting;
    get supportsConnectedMeetings(): boolean;
    get isActive(): boolean;
    get currentMeetingId(): string;
    private validateConnectedMeetingsAction;
    getConnectedMeetings(): Promise<{
        parentMeeting: ConnectedMeeting;
        meetings: ConnectedMeeting[];
    }>;
    createMeetings(request: {
        title: string;
    }[]): Promise<{
        id: string;
        title: string;
    }[]>;
    updateMeetings(request: {
        id: string;
        title: string;
    }[]): Promise<void>;
    deleteMeetings(meetingIds: string[]): Promise<{
        id: string;
    }[]>;
    moveParticipants(sourceMeetingId: string, destinationMeetingId: string, participantIds: string[]): Promise<{
        success: boolean;
        error?: undefined;
    } | {
        success: boolean;
        error: any;
    }>;
}

interface DyteClientOptions {
    roomName?: string;
    authToken: string;
    apiBase?: string;
    defaults?: DefaultOptions;
    modules?: Modules;
    overrides?: {
        [key: string]: boolean | string;
    };
    baseURI?: string;
    cachedUserDetails?: CachedUserDetails;
}
declare class DyteClient {
    #private;
    private constructor();
    static init(options: DyteClientOptions): Promise<DyteClient>;
    joinRoom(): Promise<boolean>;
    leaveRoom(state?: leaveRoomState): Promise<boolean>;
    join(): Promise<boolean>;
    leave(state?: leaveRoomState): Promise<boolean>;
    static DyteSelfMedia: typeof DyteSelfMedia;
    self: DyteSelf$1;
    participants: DyteParticipants$1;
    meta: DyteMeta$1;
    ai: DyteAi;
    plugins: DytePlugins$1;
    chat: DyteChat$1;
    polls: DytePolls$1;
    remote: DyteRemote;
    get connectedMeetings(): Readonly<DyteConnectedMeetings$1>;
    recording: DyteRecording$1;
    livestream: DyteLivestream$1;
    stage: DyteStage;
    troubleshoot: DyteTroubleshooter;
    __internals__: DyteInternals;
}

type DyteConfigOptions = Omit<ControllerOptions, 'peerId'>;

type DyteParticipant = Readonly<DyteParticipant$1>;

type DyteParticipants = Readonly<DyteParticipants$1>;
type DyteParticipantMap = Readonly<DyteParticipantMap$1>;

type DytePlugin = Readonly<DytePlugin$1>;
type DytePlugins = Readonly<DytePlugins$1>;
type DytePluginMap = Readonly<DytePluginMap$1>;
type DyteMeta = Readonly<DyteMeta$1>;
type DyteSelf = Readonly<DyteSelf$1>;
type DyteChat = Readonly<DyteChat$1>;
type DytePolls = Readonly<DytePolls$1>;
type DyteRecording = Readonly<DyteRecording$1>;

type DyteLivestream = Readonly<DyteLivestream$1>;

type DyteConnectedMeetings = Readonly<DyteConnectedMeetings$1>;

type DytePermissionsPresetV1 = Readonly<DytePermissionsPresetV1$1>;
type DytePermissionsPreset = Readonly<DytePermissionsPreset$1>;
type DyteThemePresetV1 = Readonly<DyteThemePresetV1$1>;
type DyteThemePreset = Readonly<DyteThemePreset$1>;
type MicMetadata = Readonly<MicMetadata$1>;

type DyteType = {
    callStats?: unknown;
    DyteTelemetry?: typeof DyteTelemetry;
};
declare global {
    interface Navigator {
        RNLocalMediaHandlerImpl?: any;
        isReactNative?: boolean;
    }
    interface Window {
        Dyte?: DyteType;
        FAST_DYTE?: boolean;
        MediaStreamTrackProcessor?: any;
        MediaStreamTrackGenerator?: any;
        TransformStream?: any;
    }
}

export { ActiveTab, ActiveTabType, AudioMiddleware, BroadcastMessagePayload, CachedUserDetails, ChatChannel, ChatUpdateParams, CustomMessage, DeviceConfig, DyteBasicParticipant, DyteBasicParticipantsMap, DyteChat, DyteConfigOptions, DyteConnectedMeetings, DyteLivestream, DyteMeta, DyteParticipant, DyteParticipantMap, DyteParticipants, DytePermissionsPreset, DytePermissionsPresetV1, DytePlugin, DytePluginMap, DytePlugins, DytePolls, DyteRecording, DyteSelf, DyteThemePreset, DyteThemePresetV1, FileMessage, ImageMessage, JoinedPeer, LivestreamState, MediaPermission, Message, MicMetadata, RecordingState, RemoteUpdatePayload, RequestToJoinType, StageStatus, TextMessage, UserDetailsResponseV2, VideoMiddleware, VideoQualityConstraints, WebinarStageStatus, DyteClient as default, leaveRoomState };
