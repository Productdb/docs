import type { Message } from '@dytesdk/web-core';
import { Peer } from '../types/dyte-client';
import { ChatChannel, ChatMessage } from '../types/props';
export declare const parseMessageForTarget: (message: any) => Message;
export declare function alphabeticalSorter(a: string, b: string): number;
/**
 * Generate a unique chat group key used in `<dyte-chat-messages-ui />`
 * @param ids An array of user ids
 * @returns A unique key from the user ids
 */
export declare function generateChatGroupKey(ids: string[]): string;
export declare function handleFilesDataTransfer(items: DataTransferItemList, callback: (type: 'image' | 'file', file: File) => void): boolean;
interface GetChatGroupsOptions {
  messages: Message[];
  participants: Pick<Peer, 'name' | 'userId'>[];
  selfUserId: string;
}
export declare function getChatGroups({ messages, participants, selfUserId }: GetChatGroupsOptions): Record<string, ChatMessage[]>;
export declare type GetUnreadChatCountsOptions = {
  messages: Message[];
  selfUserId: string;
  selectedGroupId: string;
  participants: Pick<Peer, 'name' | 'userId'>[];
};
export declare function getUnreadChatCounts({ messages, selfUserId, selectedGroupId, participants, }: GetUnreadChatCountsOptions): Record<string, number>;
export declare function getParticipantUserId({ groupId, selfUserId, }: {
  groupId: string;
  selfUserId: string;
}): string;
export declare const TEMPORARY_CHANNEL_PREFIX = "dm__";
export declare function isDirectMessageChannel(channel: ChatChannel): boolean;
export declare function getDMComparator(memberIds: string[]): string;
export declare function reverse(str: string): string;
export declare const emailPattern: RegExp;
export declare const boldPattern: RegExp;
export declare const italicsPattern: RegExp;
export declare const strikethroughPattern: RegExp;
export declare const linkPattern: RegExp;
export declare const replyBlockPattern: RegExp;
export declare function extractReplyBlock(message: string, excludeTags?: boolean): string;
export declare function stripOutReplyBlock(message: string): string;
export declare const MAX_TEXT_LENGTH = 2000;
export interface Token {
  type: string;
  content: Token[] | string;
}
export declare function parseRichText(text: string): Token[];
export declare function tokenizeRichText(text: string, endTag?: string): [Token[], number];
export {};
