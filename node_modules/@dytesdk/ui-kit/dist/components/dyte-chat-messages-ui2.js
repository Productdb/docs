import { proxyCustomElement, HTMLElement, createEvent, writeTask, h, Host } from '@stencil/core/internal/client';
import { s as state } from './store.js';
import './breakout-rooms-manager.js';
import './livestream.js';
import { d as defaultIconPack } from './default-icon-pack.js';
import { u as useLanguage } from './index2.js';
import { c as chatUnreadTimestamps } from './user-prefs.js';
import { d as differenceInMinutes, f as formatDateTime, e as elapsedDuration } from './date.js';
import { s as smoothScrollToBottom } from './scroll.js';
import { d as defineCustomElement$d } from './dyte-avatar2.js';
import { d as defineCustomElement$c } from './dyte-button2.js';
import { d as defineCustomElement$b } from './dyte-file-message-view2.js';
import { d as defineCustomElement$a } from './dyte-icon2.js';
import { d as defineCustomElement$9 } from './dyte-image-message-view2.js';
import { d as defineCustomElement$8 } from './dyte-markdown-view2.js';
import { d as defineCustomElement$7 } from './dyte-menu2.js';
import { d as defineCustomElement$6 } from './dyte-menu-item2.js';
import { d as defineCustomElement$5 } from './dyte-menu-list2.js';
import { d as defineCustomElement$4 } from './dyte-message-view2.js';
import { d as defineCustomElement$3 } from './dyte-spinner2.js';
import { d as defineCustomElement$2 } from './dyte-text-message-view2.js';
import { d as defineCustomElement$1 } from './dyte-tooltip2.js';

const dyteChatMessagesUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));word-break:break-word}.chat-container{box-sizing:border-box;display:flex;flex-direction:column;padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);flex:1 0 0px;overflow-y:scroll}.chat-container .spacer{flex:1 1 auto}.chat-container .chat{flex:0 0 auto}.file-picker{display:none}.chat .head{display:flex;align-items:center}.chat .head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.chat .head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat .body{margin-top:var(--dyte-space-2, 8px);overflow-wrap:break-word;line-height:1.375}.chat .body .emoji{font-size:24px}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-message-view{margin-top:var(--dyte-space-4, 16px);display:block;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}dyte-message-view::part(message){flex-grow:1}*[is-continued] dyte-message-view{margin-top:var(--dyte-space-1, 4px)}.pinned .message-wrapper{position:relative}.pinned .pin-button{position:absolute;right:var(--dyte-space-4, 16px);top:calc(var(--dyte-space-4, 16px) * -1);display:flex;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.pinned .pin-button:hover dyte-button{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-bg-opacity))}.pinned dyte-message-view{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.new-chat-marker{display:flex;width:100%;align-items:center;gap:var(--dyte-space-2, 8px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.new-chat-marker::before{content:'';height:1px;flex:1 1 0%;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.show-new-messages-ctr{pointer-events:none;display:flex;justify-content:flex-end;padding:var(--dyte-space-3, 12px);z-index:0;margin-top:calc(var(--dyte-space-14, 56px) * -1)}.show-new-messages{pointer-events:auto;--tw-translate-y:var(--dyte-space-16, 64px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}";

const DyteChatMessagesUi = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.onPinMessage = createEvent(this, "pinMessage", 7);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.observingEl = [];
    this.autoScrollEnabled = true;
    this.onScroll = (e) => {
      const target = e.target;
      writeTask(() => {
        const { scrollTop, clientHeight, scrollHeight } = target;
        const fromTop = scrollTop + clientHeight;
        if (fromTop + 10 >= scrollHeight) {
          // at bottom
          this.autoScrollEnabled = true;
          this.showLatestMessageButton = false;
        }
        else {
          // not at bottom
          this.autoScrollEnabled = false;
        }
      });
    };
    this.scrollToBottom = () => {
      smoothScrollToBottom(this.$chat);
    };
    this.observeMessage = (el) => {
      if (el) {
        this.observingEl.push(el);
      }
      try {
        this.intersectionObserver.observe(el);
      }
      catch (_a) { }
    };
    this.getMessageActions = (message) => {
      const actions = [];
      if (!message.pinned && this.canPinMessages) {
        actions.push({
          id: 'pin_message',
          label: this.t('pin'),
          icon: this.iconPack.pin,
        });
      }
      return actions;
    };
    this.onMessageActionHandler = (actionId, message) => {
      switch (actionId) {
        case 'pin_message':
          this.onPinMessage.emit(message);
          break;
      }
    };
    this.selectedGroup = undefined;
    this.messages = [];
    this.selfUserId = undefined;
    this.canPinMessages = false;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.now = new Date();
    this.showLatestMessageButton = false;
  }
  connectedCallback() {
    var _a;
    this.lastReadTimestamp = (_a = chatUnreadTimestamps['everyone']) !== null && _a !== void 0 ? _a : new Date('0001-01-01T00:00:00Z');
    this.intersectionObserver = new IntersectionObserver((entries) => {
      if (!document.hasFocus())
        return;
      writeTask(() => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            const currTimestamp = parseInt(entry.target.getAttribute('data-timestamp'));
            if (currTimestamp > this.lastReadTimestamp.getTime()) {
              // this.lastReadTimestamp = new Date();
              chatUnreadTimestamps[this.selectedGroup] = new Date();
            }
          }
        }
      });
    });
    // update current time every minute
    const updateNow = () => {
      this.now = new Date();
      this.timeout = setTimeout(() => {
        if (this.request != null) {
          this.request = requestAnimationFrame(updateNow);
        }
      }, 60 * 1000);
    };
    this.request = requestAnimationFrame(updateNow);
    this.chatChanged(this.messages);
  }
  componentDidLoad() {
    this.$chat.addEventListener('scroll', this.onScroll);
    this.$chat.scrollTop = this.$chat.scrollHeight;
  }
  componentDidRender() {
    if (this.autoScrollEnabled) {
      smoothScrollToBottom(this.$chat);
    }
    else if (this.autoScrollEnabled == null) {
      // scroll to bottom on first render
      smoothScrollToBottom(this.$chat, false);
    }
  }
  chatChanged(messages) {
    if (this.$chat == null)
      return;
    if (this.autoScrollEnabled || this.$chat.clientHeight === this.$chat.scrollHeight)
      return;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].message.time > this.lastReadTimestamp &&
        messages[i].message.userId !== this.selfUserId) {
        // show latest message button when you have new messages
        // and chat container is scrollable and autoscroll is not enabled
        this.showLatestMessageButton = true;
        break;
      }
    }
  }
  selectedBucketChanged() {
    this.autoScrollEnabled = undefined;
    this.observingEl.forEach((el) => {
      this.intersectionObserver.unobserve(el);
    });
    this.observingEl = [];
  }
  disconnectedCallback() {
    this.$chat.removeEventListener('scroll', this.onScroll);
    this.intersectionObserver.disconnect();
    clearTimeout(this.timeout);
    cancelAnimationFrame(this.request);
  }
  render() {
    var _a;
    let prevMessage = null;
    let reachedFirstUnread = false;
    return (h(Host, null, h("div", { class: "chat-container scrollbar", ref: (el) => (this.$chat = el), part: "container" }, h("div", { class: "spacer", part: "spacer" }), h("div", { class: "chat", part: "chat" }, (_a = this.messages) === null || _a === void 0 ? void 0 : _a.map((item) => {
      if (item.type === 'chat') {
        const { message } = item;
        const isSelfMessage = message.userId === this.selfUserId;
        const isUnread = !isSelfMessage &&
          !this.autoScrollEnabled &&
          !reachedFirstUnread &&
          message.time > this.lastReadTimestamp;
        if (isUnread)
          reachedFirstUnread = isUnread;
        const isContinued = !isUnread &&
          message.userId === (prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.userId) &&
          differenceInMinutes(message.time, prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.time) < 2;
        prevMessage = message;
        return (h("div", { "is-continued": isContinued, key: item.message.id, ref: this.observeMessage, "data-timestamp": message.time.getTime(), class: message.pinned ? 'pinned' : '' }, isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("div", { class: "message-wrapper" }, h("dyte-message-view", { time: message.time, actions: this.getMessageActions(message), authorName: message.displayName, hideAvatar: true, hideAuthorName: true, hideMetadata: true, viewType: 'incoming', variant: "plain", onAction: (event) => this.onMessageActionHandler(event.detail, message) }, h("div", null, !isContinued && (h("div", { class: "head" }, h("div", { class: "name" }, message.displayName), !!message.time && (h("div", { class: "time", title: formatDateTime(message.time) }, elapsedDuration(message.time, new Date(Date.now())))))), h("div", { class: "body" }, message.type === 'text' && (h("dyte-text-message-view", { text: message.message, isMarkdown: true })), message.type === 'file' && (h("dyte-file-message-view", { name: message.name, url: message.link, size: message.size })), message.type === 'image' && (h("dyte-image-message-view", { url: message.link, onPreview: () => {
            this.stateUpdate.emit({ image: message });
            state.image = message;
          } }))))), message.pinned && (h("div", { class: "pin-button", part: "pin-button" }, h("dyte-tooltip", { label: this.t('unpin'), iconPack: this.iconPack, t: this.t }, h("dyte-button", { kind: "icon", variant: "ghost", onClick: () => this.onMessageActionHandler('pin_message', message), iconPack: this.iconPack, t: this.t, disabled: !this.canPinMessages }, h("dyte-icon", { icon: this.iconPack.pin, iconPack: this.iconPack, t: this.t, size: "sm" }))))))));
      }
      return null;
    }))), h("div", { class: "show-new-messages-ctr" }, h("dyte-button", { class: {
        'show-new-messages': true,
        active: this.showLatestMessageButton,
      }, kind: "icon", part: "show-new-messages", onClick: this.scrollToBottom, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t })))));
  }
  static get watchers() { return {
    "messages": ["chatChanged"],
    "selectedGroup": ["selectedBucketChanged"]
  }; }
  static get style() { return dyteChatMessagesUiCss; }
}, [1, "dyte-chat-messages-ui", {
    "selectedGroup": [1, "selected-group"],
    "messages": [16],
    "selfUserId": [1, "self-user-id"],
    "canPinMessages": [4, "can-pin-messages"],
    "size": [513],
    "iconPack": [16],
    "t": [16],
    "now": [32],
    "showLatestMessageButton": [32]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["dyte-chat-messages-ui", "dyte-avatar", "dyte-button", "dyte-file-message-view", "dyte-icon", "dyte-image-message-view", "dyte-markdown-view", "dyte-menu", "dyte-menu-item", "dyte-menu-list", "dyte-message-view", "dyte-spinner", "dyte-text-message-view", "dyte-tooltip"];
  components.forEach(tagName => { switch (tagName) {
    case "dyte-chat-messages-ui":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, DyteChatMessagesUi);
      }
      break;
    case "dyte-avatar":
      if (!customElements.get(tagName)) {
        defineCustomElement$d();
      }
      break;
    case "dyte-button":
      if (!customElements.get(tagName)) {
        defineCustomElement$c();
      }
      break;
    case "dyte-file-message-view":
      if (!customElements.get(tagName)) {
        defineCustomElement$b();
      }
      break;
    case "dyte-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$a();
      }
      break;
    case "dyte-image-message-view":
      if (!customElements.get(tagName)) {
        defineCustomElement$9();
      }
      break;
    case "dyte-markdown-view":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
    case "dyte-menu":
      if (!customElements.get(tagName)) {
        defineCustomElement$7();
      }
      break;
    case "dyte-menu-item":
      if (!customElements.get(tagName)) {
        defineCustomElement$6();
      }
      break;
    case "dyte-menu-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$5();
      }
      break;
    case "dyte-message-view":
      if (!customElements.get(tagName)) {
        defineCustomElement$4();
      }
      break;
    case "dyte-spinner":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "dyte-text-message-view":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
    case "dyte-tooltip":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}

export { DyteChatMessagesUi as D, defineCustomElement as d };
