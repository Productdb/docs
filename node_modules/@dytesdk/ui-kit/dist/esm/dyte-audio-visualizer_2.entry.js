import { r as registerInstance, h, H as Host, c as createEvent } from './index-926e26e8.js';
import { h as hark } from './hark-c1808fa5.js';
import { d as defaultIconPack } from './default-icon-pack-307ffa7c.js';
import { u as useLanguage } from './index-7b89c939.js';

/**
 * Draws audio visualizer of variant `bars`
 * @param canvas Canvas element
 * @param volume Current volume
 */
const drawBarsVisualizer = (canvas, volume) => {
  if (canvas == null) {
    return;
  }
  const nSlices = 3;
  const halfwaySlice = Math.round(nSlices / 2);
  const sample = [...Array(nSlices)].map((_, i) => {
    let index = i;
    if (index > halfwaySlice - 1) {
      index = nSlices - index - 1;
    }
    return Math.round(((index + 1) / (halfwaySlice + 1)) * volume);
  });
  const { width, height } = canvas;
  const context = canvas.getContext('2d');
  let x = 2;
  const sliceGraphicWidth = 4;
  const sliceWidth = (width * 1.0) / sample.length;
  const slicePadding = sliceWidth - sliceGraphicWidth;
  context.clearRect(0, 0, width, height);
  context.fillStyle = 'rgb(0,0,0,0.0)';
  context.fillRect(0, 0, width, height);
  const color = getComputedStyle(canvas).getPropertyValue('color');
  context.fillStyle = color;
  context.strokeStyle = color;
  context.lineCap = 'round';
  context.lineWidth = 4;
  context.beginPath();
  for (const item of sample) {
    const y = Math.min(-Math.abs(((item * 1.2) / 10) * height) + height / 2, height / 2 - 2.5);
    const sliceHeight = Math.max((height / 2 - y) * 2, 5);
    context.moveTo(x + slicePadding / 2, y);
    context.lineTo(x + slicePadding / 2, y + sliceHeight);
    x += sliceWidth;
  }
  context.stroke();
};

const dyteAudioVisualizerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:var(--dyte-space-6, 24px);width:-moz-fit-content;width:fit-content}canvas,dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){transform:scale(0.9)}canvas{display:none}canvas.visible{display:block}canvas.bars{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

const DyteAudioVisualizer = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.variant = 'bars';
    this.participant = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.isScreenShare = false;
    this.audioEnabled = undefined;
    this.volume = 0;
  }
  connectedCallback() {
    this.participantChanged(this.participant);
  }
  componentDidLoad() {
    drawBarsVisualizer(this.visualizer, 0);
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.hark) === null || _a === void 0 ? void 0 : _a.stop();
    this.audioUpdateListener &&
      ((_b = this.participant) === null || _b === void 0 ? void 0 : _b.removeListener('audioUpdate', this.audioUpdateListener));
    this.screenShareUpdateListener &&
      ((_c = this.participant) === null || _c === void 0 ? void 0 : _c.removeListener('screenShareUpdate', this.screenShareUpdateListener));
  }
  participantChanged(participant) {
    if (participant != null) {
      this.audioUpdateListener = ({ audioEnabled, audioTrack }) => {
        var _a;
        (_a = this.hark) === null || _a === void 0 ? void 0 : _a.stop();
        if (audioEnabled && audioTrack != null) {
          this.audioEnabled = true;
          const stream = new MediaStream();
          stream.addTrack(audioTrack);
          this.calcVolume(stream);
          // initial draw with volume: 0
          drawBarsVisualizer(this.visualizer, 0);
        }
        else {
          this.volume = 0;
          this.audioEnabled = false;
        }
      };
      if (this.isScreenShare) {
        this.screenShareUpdateListener = ({ screenShareEnabled, screenShareTracks }) => {
          this.audioUpdateListener({
            audioEnabled: screenShareEnabled && screenShareTracks.audio != null,
            audioTrack: screenShareTracks.audio,
          });
        };
        this.screenShareUpdateListener({
          screenShareEnabled: participant.screenShareEnabled,
          screenShareTracks: {
            audio: participant.screenShareTracks.audio,
            video: participant.screenShareTracks.video,
          },
        });
        participant.addListener('screenShareUpdate', this.screenShareUpdateListener);
      }
      else {
        this.audioUpdateListener(participant);
        participant.addListener('audioUpdate', this.audioUpdateListener);
      }
    }
  }
  /**
   * Determines the volume from a given MediaStream and updates the components state
   * @param stream A MediaStream with AudioTrack(s) added
   */
  calcVolume(stream) {
    this.hark = hark(stream, {
      play: false,
      interval: 1000 / 10,
    });
    this.hark.on('volume_change', (dBs) => {
      const prevVolume = this.volume;
      // The exact formula to convert from dBs (-100..0) to linear (0..1) is:
      //   Math.pow(10, dBs / 20)
      // However it does not produce a visually useful output, so let exagerate
      // it a bit. Also, let convert it from 0..1 to 0..10 and avoid value 1 to
      // minimize component renderings.
      // if dBs is -Inifnity, set vol to 0
      let audioVol = Math.round(10 ** (dBs / 115) * 10);
      if (audioVol < 3)
        audioVol = 0;
      let volume = Math.round((prevVolume * 2 + audioVol) / 3);
      if (prevVolume !== volume) {
        this.volume = volume;
        drawBarsVisualizer(this.visualizer, this.volume);
      }
    });
  }
  render() {
    return (h(Host, null, h("canvas", { width: "24", height: "24", class: {
        bars: true,
        visible: this.audioEnabled,
      }, ref: (el) => (this.visualizer = el), part: "canvas" }), !this.isScreenShare && !this.audioEnabled && (h("dyte-icon", { icon: this.iconPack.mic_off, part: "mic-off-icon", iconPack: this.iconPack, t: this.t }))));
  }
  static get watchers() { return {
    "participant": ["participantChanged"]
  }; }
};
DyteAudioVisualizer.style = dyteAudioVisualizerCss;

const dyteSwitchCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:inline-flex;height:var(--dyte-space-6, 24px);width:var(--dyte-space-10, 40px);align-items:center;padding:var(--dyte-space-1, 4px);border-radius:9999px;background-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));cursor:pointer}.switch{box-sizing:border-box;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);background-color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));border-radius:9999px;transition-property:var(--dyte-transition-property, all);transition-duration:200ms}:host(.checked){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host(.checked) .switch{transform:translateX(100%)}:host([readonly]),:host([disabled]){cursor:not-allowed;opacity:0.6}";

const DyteSwitch = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dyteChange = createEvent(this, "dyteChange", 4);
    this.onClick = () => {
      if (!this.readonly && !this.disabled) {
        this.checked = !this.checked;
      }
    };
    this.onKeyPress = (e) => {
      if (this.readonly)
        return;
      switch (e.key) {
        // Enter or Space
        case 'Enter':
        case ' ':
          this.checked = !this.checked;
          break;
      }
    };
    this.checked = false;
    this.readonly = false;
    this.disabled = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    this.checkedChange(this.checked);
  }
  checkedChange(checked) {
    this.checked = checked;
    this.dyteChange.emit(checked);
  }
  render() {
    return (h(Host, { role: "switch", tabIndex: this.disabled && 0, "aria-readonly": this.readonly, "aria-checked": this.checked, "aria-disabled": this.disabled, class: { checked: this.checked }, onClick: this.onClick, onKeyPress: this.onKeyPress }, h("div", { class: "switch", part: "switch" })));
  }
  static get watchers() { return {
    "checked": ["checkedChange"]
  }; }
};
DyteSwitch.style = dyteSwitchCss;

export { DyteAudioVisualizer as dyte_audio_visualizer, DyteSwitch as dyte_switch };
