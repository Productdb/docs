import { h } from '@stencil/core';
import { MAX_TEXT_LENGTH, extractReplyBlock, parseRichText, stripOutReplyBlock, } from '../../utils/chat';
export class DyteMarkdownView {
  constructor() {
    this.restoreEmpty = (content, tag, renderCallback) => {
      return content.trim().length === 0 ? `${tag}${content}${tag}` : renderCallback(content);
    };
    this.renderLink = (content) => {
      return (h("a", { class: "link", href: content, target: "_blank", rel: "noopener noreferrer" }, content));
    };
    this.renderBold = (content) => {
      if (typeof content === 'string') {
        return this.restoreEmpty(content, '*', (c) => h("b", null, c));
      }
      return h("b", null, this.renderTokens(content));
    };
    this.renderItalic = (content) => {
      if (typeof content === 'string') {
        return this.restoreEmpty(content, '_', (c) => h("i", null, c));
      }
      return h("i", null, this.renderTokens(content));
    };
    this.renderStrikethrough = (content) => {
      if (typeof content === 'string') {
        return this.restoreEmpty(content, '~', (c) => h("s", null, c));
      }
      return h("b", null, this.renderTokens(content));
    };
    this.renderPlainText = (content) => {
      if (typeof content === 'string') {
        return content;
      }
      return h("p", null, this.renderTokens(content));
    };
    this.renderTokens = (tokens) => {
      return tokens.map((token) => {
        switch (token.type) {
          case 'a':
            if (typeof token.content === 'string') {
              return this.renderLink(token.content);
            }
          case 'b':
            return this.renderBold(token.content);
          case 'i':
            return this.renderItalic(token.content);
          case 's':
            return this.renderStrikethrough(token.content);
          case 'q':
            return h("span", { class: "block-quote" });
          case 'plain_text':
          default:
            return this.renderPlainText(token.content);
        }
      });
    };
    this.text = undefined;
    this.maxLength = MAX_TEXT_LENGTH;
  }
  render() {
    const slicedMessage = this.text.slice(0, this.maxLength);
    const withReply = extractReplyBlock(slicedMessage, true);
    const withoutReply = stripOutReplyBlock(slicedMessage);
    return (h("p", null, withReply.length !== 0 && (h("blockquote", null, withReply.split('\n').map((line) => {
      const tokens = parseRichText(line);
      return h("p", null, this.renderTokens(tokens));
    }))), withoutReply.split('\n').map((line) => {
      const tokens = parseRichText(line);
      return h("p", null, this.renderTokens(tokens));
    })));
  }
  static get is() { return "dyte-markdown-view"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dyte-markdown-view.css"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dyte-markdown-view.css"]
    };
  }
  static get properties() {
    return {
      "text": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "raw text to render as markdown"
        },
        "attribute": "text",
        "reflect": false
      },
      "maxLength": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "max length of text to render as markdown"
        },
        "attribute": "max-length",
        "reflect": false,
        "defaultValue": "MAX_TEXT_LENGTH"
      }
    };
  }
}
