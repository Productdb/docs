import { h } from '@stencil/core';
/**
 * A component which renders a text composer
 */
export class DyteTextComposerView {
  constructor() {
    this.onInputHandler = () => {
      const text = this.$textArea.value.trim();
      this.maybeResize(text);
      this.onTextChange.emit(text);
    };
    this.maybeResize = (text) => {
      const newLines = [...text.matchAll(/\n/g)].length;
      this.$textArea.style.height = `${Math.min(200, 60 + 20 * newLines)}px`;
    };
    this.disabled = false;
    this.placeholder = undefined;
    this.value = undefined;
    this.maxLength = undefined;
    this.keyDownHandler = () => { };
  }
  componentDidLoad() {
    if (this.maxLength) {
      this.$textArea.maxLength = this.maxLength;
    }
    const text = this.$textArea.value.trim();
    if (text !== '') {
      this.maybeResize(text);
    }
  }
  /** Sets value of the text input */
  async setText(text, focus = false) {
    this.$textArea.value = text;
    this.maybeResize(text);
    if (focus) {
      this.$textArea.focus();
    }
    this.onTextChange.emit(text);
  }
  render() {
    return (h("div", { class: "chat-input", part: "chat-input-container" }, h("textarea", { ref: (el) => (this.$textArea = el), placeholder: this.placeholder, disabled: this.disabled, onInput: this.onInputHandler, onKeyDown: this.keyDownHandler, part: "chat-input", value: this.value })));
  }
  static get is() { return "dyte-text-composer-view"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dyte-text-composer-view.css"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dyte-text-composer-view.css"]
    };
  }
  static get properties() {
    return {
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Disable the text input (default = false)"
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "placeholder": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Placeholder text"
        },
        "attribute": "placeholder",
        "reflect": false
      },
      "value": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Default value for text input"
        },
        "attribute": "value",
        "reflect": false
      },
      "maxLength": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Max length for text input"
        },
        "attribute": "max-length",
        "reflect": false
      },
      "keyDownHandler": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "(e: KeyboardEvent) => void",
          "resolved": "(e: KeyboardEvent) => void",
          "references": {
            "KeyboardEvent": {
              "location": "global"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Keydown event handler function"
        },
        "defaultValue": "() => {}"
      }
    };
  }
  static get events() {
    return [{
        "method": "onTextChange",
        "name": "textChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Event emitted when text changes"
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "setText": {
        "complexType": {
          "signature": "(text: string, focus?: boolean) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }, {
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets value of the text input",
          "tags": []
        }
      }
    };
  }
}
