'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const store = require('./store-7f623fdb.js');
const breakoutRoomsManager = require('./breakout-rooms-manager-87997e6a.js');
const config = require('./config-ba1005b1.js');
const cloneDeep = require('./cloneDeep-48e6fb57.js');
const defaultUiConfig = require('./default-ui-config-d5874568.js');
const defaultIconPack = require('./default-icon-pack-ddb6b86f.js');
const index = require('./index-d63f2c88.js');
const notification = require('./notification-b9f180db.js');
const chat = require('./chat-54c798a0.js');
require('./index-f5ba2db8.js');
require('./user-prefs-cefc791a.js');
require('./breakout-rooms-23529df9.js');
require('./flags-88945715.js');
require('./livestream-3ff039ea.js');
require('./keysIn-c1d310a7.js');
require('./isObjectLike-890299f1.js');
require('./logger-8a621331.js');

/**
 * Send notification which will be displayed in the `<dyte-notifications />` component.
 * @param notification Notification object
 * @param playSound Sound type, if sound type is sent plays that sound with the notification.
 * @returns Return value of emitting the event
 */
const sendNotification = (notification, playSound = undefined) => {
  if (typeof document === 'undefined')
    return false;
  const event = new CustomEvent('dyteNotification', {
    detail: Object.assign(Object.assign({}, notification), { playSound }),
    composed: true,
  });
  return document.dispatchEvent(event);
};

/* eslint-disable no-console */
/*
    Elements can be of two types
    'dyte-mic-toggle' or ['dyte-mic-toggle', {prop: 1}]
    Custom findByName function to check for both
*/
function getFinder(query) {
  return (value) => {
    if (Array.isArray(value)) {
      return value[0] === query;
    }
    return value === query;
  };
}
/*
    Elements can be of two types
    'dyte-mic-toggle' or ['dyte-mic-toggle', {prop: 1}]
    Custom filterByName function to check for both
*/
function getFilter(query) {
  return (value) => {
    if (Array.isArray(value)) {
      return value[0] !== query;
    }
    return value !== query;
  };
}
/*
    transform JSX Component Name -> web component format
    eg. DyteMicToggle -> dyte-mic-toggle
*/
function convertComponentName(jsxName) {
  return jsxName.replace(/([a-z])([A-Z])/g, (g) => `${g[0]}-${g[1]}`.toLowerCase());
}
class UIElemEditor {
  constructor(elem, config, keyString) {
    this.elem = elem;
    this.config = config;
    this.keyString = keyString;
  }
  /**
   * Adds an element to the chilren
   * @param el :Name of the element - `dyte-mic-toggle`
   * @param props :Optional props for the element `{variant: 'solid'}`
   */
  add(el, props = {}) {
    var _a;
    el = convertComponentName(el);
    let composedElem = el;
    if (Object.keys(props).length > 0) {
      composedElem = [el, props];
    }
    if (Array.isArray(this.elem)) {
      this.elem.push(composedElem);
    }
    else if ('children' in this.elem && Array.isArray(this.elem.children)) {
      this.elem.children = [...this.elem.children, composedElem];
    }
    else if ('remove' in this.elem &&
      Array.isArray(this.elem.remove) &&
      this.elem.remove.find(getFinder(el))) {
      this.elem.remove = this.elem.remove.filter(getFilter(el));
    }
    else {
      if (!('add' in this.elem)) {
        this.elem.add = [];
      }
      (_a = this.elem.add) === null || _a === void 0 ? void 0 : _a.push(composedElem);
    }
    return this;
  }
  /**
   * Removes an element from the chilren
   * @param el :Name of the element to remove - `dyte-mic-toggle`
   */
  remove(el) {
    var _a;
    el = convertComponentName(el);
    if (Array.isArray(this.elem)) {
      const idx = this.elem.findIndex(getFinder(el));
      if (idx > -1) {
        this.elem.splice(idx, 1);
      }
    }
    else if ('children' in this.elem && Array.isArray(this.elem.children)) {
      this.elem.children = this.elem.children.filter(getFilter(el));
    }
    else if ('add' in this.elem &&
      Array.isArray(this.elem.add) &&
      this.elem.add.find((e) => e === el)) {
      this.elem.add = this.elem.add.filter(getFilter(el));
    }
    else {
      if (!('remove' in this.elem)) {
        this.elem.remove = [];
      }
      (_a = this.elem.remove) === null || _a === void 0 ? void 0 : _a.push(el);
    }
    return this;
  }
  set style(s) {
    console.log(s);
    // TODO: Not Implemented
  }
  setChildrenProps(childElem, props) {
    console.log(this.keyString, childElem, props);
    // TODO: Not Implemented
  }
  getChildrenProps(childElem) {
    console.log(this.keyString, childElem);
    // TODO: Not Implemented
    return {};
  }
  replace(e) {
    console.log(this.config, e);
    // TODO: Not Implemented
  }
}
/* eslint-enable no-console */
class DyteUIBuilder {
  constructor(config) {
    this.config = cloneDeep.cloneDeep(config || defaultUiConfig.defaultConfig);
  }
  /**
   * Find an element anywhere in the Dyte hierarachy and returns an editor object
   * @param elem = 'dyte-participant-tile'
   * @param states = { activeSidebar: true, activeSettings: true, meeting: 'joined'}
   * @returns `UIElemEditor`
   */
  find(elem, states = {}) {
    elem = convertComponentName(elem);
    // eg. [activeSidebar, activeSettings]
    const booleanStates = [];
    // eg. [[meeting,joined]]
    const nonBooleanStates = [];
    Object.keys(states || {}).forEach((key) => {
      if (typeof states[key] === 'boolean') {
        booleanStates.push(key);
      }
      else {
        nonBooleanStates.push([key, states[key]]);
      }
    });
    booleanStates.sort();
    const root = this.config.root;
    if (root === undefined)
      return;
    let keyString = elem;
    let booleanStateString = '';
    if (booleanStates.length > 0) {
      // eg. '.activeSettings.activeSidebar'
      booleanStateString = `.${booleanStates.join('.')}`;
      // eg. 'dyte-participant-tile.activeSettings.activeSidebar'
      keyString = `${elem}${booleanStateString}`;
      // An element will only re-render when a state described in its `states` key changes
      // If the element has no states defined, ie. just array of children
      // convert to a complex element type
      if (Array.isArray(root[elem])) {
        root[elem] = {
          states: [],
          children: root[elem],
        };
      }
      if (root[elem].states === undefined) {
        root[elem].states = [];
      }
      // Add each boolean state if it is not there already
      booleanStates.forEach((e) => {
        var _a, _b;
        if (((_a = root[elem].states) === null || _a === void 0 ? void 0 : _a.indexOf(e)) === -1) {
          (_b = root[elem].states) === null || _b === void 0 ? void 0 : _b.push(e);
        }
      });
    }
    if (nonBooleanStates.length > 0) {
      nonBooleanStates.forEach((k) => {
        // eg. '[meeting=joined]'
        const v = `[${k[0]}=${k[1]}]`;
        // eg. 'dyte-participant-tile[meeting=joined].activeSettings.activeSidebar'
        keyString = `${elem}${v}${booleanStateString}`;
        // An element will only re-render when a state described in its `states` key changes
        // If the element has no states defined, ie. just array of children
        // convert to a complex element type
        if (Array.isArray(root[elem])) {
          root[elem] = {
            state: k[0],
            children: root[elem],
          };
        }
      });
    }
    let target = root[keyString];
    if (target === undefined) {
      root[keyString] = {};
      target = root[keyString];
    }
    return new UIElemEditor(target, this.config, keyString);
  }
  build() {
    return this.config;
  }
}

/**
 * Register addons to the meeting
 * @param addons The list of addons to register
 * @param meeting The meeting object
 * @param config The current UIConfig
 * @returns The updated UIConfig
 */
function registerAddons(addons, meeting, config$1) {
  if (!config$1) {
    const generated = config.generateConfig(meeting.self.config, meeting);
    config$1 = generated.config;
  }
  addons.map((addon) => {
    config$1 = addon.register(config$1, meeting, (c) => new DyteUIBuilder(c));
  });
  return config$1;
}

exports.onStateStoreChange = store.onChange;
exports.statesStore = store.state;
exports.BreakoutRoomsManager = breakoutRoomsManager.BreakoutRoomsManager;
exports.extendConfig = config.extendConfig;
exports.generateConfig = config.generateConfig;
exports.provideDyteDesignSystem = config.provideDyteDesignSystem;
exports.defaultConfig = defaultUiConfig.defaultConfig;
exports.defaultIconPack = defaultIconPack.defaultIconPack;
exports.defaultLanguage = index.defaultLanguage;
exports.useLanguage = index.useLanguage;
exports.DyteNotificationsAudio = notification.DyteNotificationsAudio;
exports.generateChatGroupKey = chat.generateChatGroupKey;
exports.getChatGroups = chat.getChatGroups;
exports.getParticipantUserId = chat.getParticipantUserId;
exports.getUnreadChatCounts = chat.getUnreadChatCounts;
exports.DyteUIBuilder = DyteUIBuilder;
exports.registerAddons = registerAddons;
exports.sendNotification = sendNotification;
