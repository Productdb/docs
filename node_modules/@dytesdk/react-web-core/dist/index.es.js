var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import require$$0, { createContext, useState, useRef, useEffect, useContext, useReducer } from "react";
import DyteClient from "@dytesdk/web-core";
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = require$$0, g = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if ("function" === typeof Symbol && Symbol.for) {
  var h = Symbol.for;
  g = h("react.element");
  reactJsxRuntime_production_min.Fragment = h("react.fragment");
}
var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, k) {
  var b, d = {}, e = null, l = null;
  void 0 !== k && (e = "" + k);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (l = a.ref);
  for (b in a)
    n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: g, type: c, key: e, ref: l, props: d, _owner: m.current };
}
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
class DyteUpdates {
  constructor(meeting) {
    __publicField(this, "meeting");
    __publicField(this, "l");
    __publicField(this, "onUpdate", () => {
      this.l.forEach((l) => {
        l();
      });
    });
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    this.meeting = meeting;
    this.l = /* @__PURE__ */ new Set();
    (_a = this.meeting.self) == null ? void 0 : _a.addListener("*", this.onUpdate);
    (_b = this.meeting.meta) == null ? void 0 : _b.addListener("*", this.onUpdate);
    (_c = this.meeting.participants) == null ? void 0 : _c.addListener("*", this.onUpdate);
    (_e = (_d = this.meeting.participants) == null ? void 0 : _d.joined) == null ? void 0 : _e.addListener("*", this.onUpdate);
    (_g = (_f = this.meeting.participants) == null ? void 0 : _f.active) == null ? void 0 : _g.addListener("*", this.onUpdate);
    (_i = (_h = this.meeting.participants) == null ? void 0 : _h.waitlisted) == null ? void 0 : _i.addListener("*", this.onUpdate);
    (_j = this.meeting.stage) == null ? void 0 : _j.addListener("*", this.onUpdate);
    (_k = this.meeting.livestream) == null ? void 0 : _k.addListener("*", this.onUpdate);
    (_l = this.meeting.chat) == null ? void 0 : _l.addListener("*", this.onUpdate);
    (_m = this.meeting.plugins) == null ? void 0 : _m.all.addListener("*", this.onUpdate);
    (_n = this.meeting.recording) == null ? void 0 : _n.addListener("*", this.onUpdate);
    (_o = this.meeting.connectedMeetings) == null ? void 0 : _o.addListener("*", this.onUpdate);
    (_p = this.meeting.spotlight) == null ? void 0 : _p.addListener("*", this.onUpdate);
    (_q = this.meeting.remote) == null ? void 0 : _q.addListener("*", this.onUpdate);
    (_r = this.meeting.polls) == null ? void 0 : _r.addListener("*", this.onUpdate);
  }
  clean() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    (_a = this.meeting.self) == null ? void 0 : _a.removeListener("*", this.onUpdate);
    (_b = this.meeting.meta) == null ? void 0 : _b.removeListener("*", this.onUpdate);
    (_c = this.meeting.participants) == null ? void 0 : _c.removeListener("*", this.onUpdate);
    (_e = (_d = this.meeting.participants) == null ? void 0 : _d.joined) == null ? void 0 : _e.removeListener("*", this.onUpdate);
    (_g = (_f = this.meeting.participants) == null ? void 0 : _f.active) == null ? void 0 : _g.removeListener("*", this.onUpdate);
    (_i = (_h = this.meeting.participants) == null ? void 0 : _h.waitlisted) == null ? void 0 : _i.removeListener("*", this.onUpdate);
    (_j = this.meeting.stage) == null ? void 0 : _j.removeListener("*", this.onUpdate);
    (_k = this.meeting.livestream) == null ? void 0 : _k.removeListener("*", this.onUpdate);
    (_l = this.meeting.chat) == null ? void 0 : _l.removeListener("*", this.onUpdate);
    (_m = this.meeting.plugins) == null ? void 0 : _m.all.removeListener("*", this.onUpdate);
    (_n = this.meeting.recording) == null ? void 0 : _n.removeListener("*", this.onUpdate);
    (_o = this.meeting.connectedMeetings) == null ? void 0 : _o.removeListener("*", this.onUpdate);
    (_p = this.meeting.spotlight) == null ? void 0 : _p.removeListener("*", this.onUpdate);
    (_q = this.meeting.remote) == null ? void 0 : _q.removeListener("*", this.onUpdate);
    (_r = this.meeting.polls) == null ? void 0 : _r.removeListener("*", this.onUpdate);
  }
  addListener(listener) {
    this.l.add(listener);
  }
  removeListener(listener) {
    this.l.delete(listener);
  }
}
const DyteContext = createContext({
  meeting: void 0,
  updates: void 0
});
function DyteProvider({
  value,
  children,
  fallback
}) {
  const [updates, setUpdates] = useState();
  const updatesRef = useRef();
  useEffect(() => {
    if (value) {
      setUpdates(new DyteUpdates(value));
    }
    return () => {
      var _a;
      (_a = updatesRef.current) == null ? void 0 : _a.clean();
    };
  }, [value]);
  return /* @__PURE__ */ jsx(DyteContext.Provider, {
    value: {
      meeting: value,
      updates
    },
    children: value ? children : fallback
  });
}
const useDyteMeeting = () => {
  const {
    meeting
  } = useContext(DyteContext);
  if (!meeting)
    throw new Error("useDyteMeeting must be used within the DyteProvider");
  return {
    meeting
  };
};
const useDyteClient = (dyteClientParams) => {
  const isRunning = useRef(false);
  const [client, setClient] = useState();
  const resetOnLeave = dyteClientParams == null ? void 0 : dyteClientParams.resetOnLeave;
  const initClient = async (options) => {
    if (isRunning.current)
      return void 0;
    isRunning.current = true;
    return DyteClient.init(options).then((meeting) => {
      setClient(meeting);
      if (resetOnLeave) {
        meeting.self.on("roomLeft", () => setClient(void 0));
      }
      meeting.connectedMeetings.on("meetingChanged", (newClient) => {
        setClient(newClient);
      });
      return meeting;
    }).finally(() => {
      isRunning.current = false;
    });
  };
  return [client, initClient];
};
const shouldUpdate = (slice, newSlice) => {
  if (slice !== newSlice) {
    return true;
  }
  if (Array.isArray(slice) && Array.isArray(newSlice)) {
    if (slice.length !== newSlice.length) {
      return true;
    }
  }
  return false;
};
const useDyteSelector = (selector) => {
  const { meeting, updates } = useContext(DyteContext);
  if (!meeting)
    throw new Error("useDyteSelector must be used within the DyteProvider");
  const state = useRef(selector(meeting));
  const [, forceUpdate] = useReducer((c) => c + 1, 0);
  useEffect(() => {
    const currentState = meeting && selector(meeting);
    const listener = () => {
      const newStateSlice = meeting && selector(meeting);
      if (shouldUpdate(state.current, newStateSlice)) {
        state.current = newStateSlice;
        forceUpdate();
      }
    };
    if (currentState && typeof currentState === "object" && "addListener" in currentState) {
      currentState.addListener("*", forceUpdate);
      return () => {
        currentState.removeListener("*", forceUpdate);
      };
    }
    updates == null ? void 0 : updates.addListener(listener);
    return () => {
      updates == null ? void 0 : updates.removeListener(listener);
    };
  }, [meeting, updates]);
  return state.current;
};
export { DyteContext, DyteProvider, useDyteClient, useDyteMeeting, useDyteSelector };
